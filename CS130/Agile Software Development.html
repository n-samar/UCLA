<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:26:35 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:26:54 +0000"/><title>Agile Software Development</title></head><body><div/><div><span style="font-weight: bold;">Sommerville: Chapter 3 — Agile Software Development</span></div><hr/><ul><li>Due to today’s business environment, a rapid development and delivery schedule is often the most critical requirement for software systems.</li><li>Faster development is increasingly more important than software quality</li><li>Characteristics of agile development approaches</li><ul><li>The processes of specification, design, and implementation are interleaved</li><li>The system is developed in a series of versions. End-users and other system stakeholders are involved in specifying and evaluating each version</li><li>System user interfaces are often developed using an interactive development system.</li></ul><li>Typically, new releases of the system are created and made available to customers every two or three weeks.</li><li>The overhead of detailed planning, designing, and documentation is justified in</li><ul><li>critical systems</li><li>development environments with multiple teams that require coordination</li><li>case many people will be involved in maintaining the software over its lifetime</li></ul><li>Core principles of agile development</li><ul><li><span style="font-style: italic;">Customer involvement.</span></li><li><span style="font-style: italic;">Incremental delivery.</span></li><li><span style="font-style: italic;">People not process.</span>People should be left to develop their own ways of working without prescriptive processes.</li><li><span style="font-style: italic;">Embrace change</span></li><li><span style="font-style: italic;">Maintain simplicity. </span>Applies both to the software being developed and the development process.</li></ul><li>Possible issues with agile approaches</li><ul><li>Customer may not be willing to constantly interact</li><li>Individual team members may not be suitable personalities for the intense involvement required in agile teams</li><li>Prioritizing changes can be very difficult, especially if there are many stakeholders</li><li>Maintaining simplicity requires extra work.</li><li>It may be hard for teams to adapt to a new development model.</li><li>Difficult to use for outsourcing, since agile does not require (and discourages) writing detailed specifications prior to development.</li></ul><li>What to consider when deciding on agile for software maintenance projects:</li><ul><li>Are systems that are developed using an agile approach maintainable, given the emphasis in the development process of minimizing formal documentation?</li><li>Can agile methods be used effectively for evolving a system in response to customer change requests?</li></ul><li>Formal documentation is supposed to describe the system and so make it easier for people changing the system to understand. In practice, formal documentation is often not kept up to date and so does not accurately reflect the program code. Agile, on the other hand, focuses on writing well-structured and maintainable code. Nevertheless, the System Requirement Specification is still one of the most useful documentations in software, and is often necessary for efficient maintenance of software and is often up to date in practice in comparison to other types of documentation.</li><li>Another agile maintainability issue is that team members might leave the team, yet agile depends on the fact that implicitly each team member understands fully some portion of the code because they built it. Lack of documentation make bringing in new people hard.</li></ul><div><br/></div><div><span style="font-weight: bold;">Plan-driven and agile development</span></div><div><br/></div><div><img src="Agile%20Software%20Development.resources/Screen%20Shot%202018-01-23%20at%208.16.28%20PM.png" height="349" width="460"/></div><ul><li>A plan-driven software process can support incremental development and delivery.</li><li>An agile team may be willing to dedicate a full iteration cycle to just writing up-to-date specification of the software developed so far</li><li>In deciding between plan-based and agile approaches, keep the following questions in mind:</li><ul><li>Is it important to have a detailed specification and design before moving to implementation?</li><li>Is an incremental delivery strategy realistic?</li><li>How large is the system being developed? Agile is most effective when the system can be developed with a small co-located team who can communicate informally.</li><li>What type of system is being developed?</li><li>What is the expected system lifetime? Long-lifetime systems may require more design documentation.</li><li>What technologies are available to support system development?</li><li>How is the development team organized?</li><li>Are there cultural issues that may affect the system development?</li><li>How good are the designers and programmers in the development team? Sometimes it is argued that agile methods require higher skill levels than plan-based approaches.</li><li>Is the system subject to external regulation?</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Extreme Programming</span></div><div><img src="Agile%20Software%20Development.resources/Screen%20Shot%202018-01-23%20at%208.24.13%20PM.png" height="197" width="485"/></div><ul><li>In extreme programming:</li><ul><li>Requirements are expressed as scenarios (called user stories) which are implemented directly as a series of tasks.</li><li>Programmers work in pairs and develop tests for each task before writing the code. All tests must be successfully executed when new code is integrated into the system</li><li>Short time gap between releases</li><li>Constant refactoring for maintainability</li></ul><li><span style="font-style: italic;">Spikes — </span>Iterations where no software construction is done. Instead, the team focuses on prototyping, writing documentation, talking to stakeholders…</li><li>Focus on maintainability by making programmers refactor any code they think might look better, even if it is not main priority.</li><li>Key features of testing in XP include:</li><ul><li>Test-first development</li><li>Incremental test development from scenarios</li><li>User involvement in the test development and validation</li><li>the use of automated testing frameworks</li></ul><li>An automated test framework is a system that makes it easy to write executable tests and submit a set of tests for execution.</li><li>Test-driven development may not yield a thorough set of tests:</li><ul><li>Programmers prefer programming to testing and sometimes may write incomplete tests in order to start writing ‘the real code’.</li><li>Some tests may be hard to write incrementally.</li><li>It is difficult to judge the completeness of a set of tests</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Pair programming</span></div><ul><li>Crucial aspect of XP. A pair of programmers sit at the same workstation and develop the software.</li><li>Pairs created dynamically so that all team members work with each other during the development process.</li><li>Advantages of pair programming:</li><ul><li>Supports the idea of <span style="font-style: italic;">collective ownership and responsibility for the system.</span> Egoless programming — individuals are not held accountable for problems in code, instead team has collective responsibility.</li><li>Acts as informal review process because each line is looked at by two people.</li><li>It helps support refactoring. Where pair programming and collective ownership are used, others benefit immediately from the refactoring so they are likely to support the process.</li><li>Pair programming reduces risks associated with a team member leaving the project early because knowledge of the code base is shared among pairs.</li></ul><li>There have been studies that state that pair programming is just as effective in code produced as two programmers working independently.</li></ul><div><br/></div><div><span style="font-weight: bold;">Agile project management</span></div><ul><li>Principal responsibility of project managers is to ensure the project is delivered on time and within budget<img src="Agile%20Software%20Development.resources/Screen%20Shot%202018-01-23%20at%208.54.23%20PM.png" height="173" width="497"/></li><li><span style="font-style: italic;">Scrum — </span>an approach to project management for agile teams. Key characteristics:</li><ul><li>Sprints are fixed length (2-4 weeks usually)</li><li>The starting point for planning is the<span style="font-style: italic;"> product backlog</span> (list of work to be done on the project). During assessment, this backlog is reviewed and priorities and risks are assigned, features are selected for development, and the software is implemented.</li><li>Short daily meetings involving all team members are held to review progress and reprioritize work if necessary.</li><li>At end of sprint, work done is reviewed and presented to stakeholders.</li></ul><li>Noted advantages of Scrum</li><ul><li>The product is broken down into manageable and understandable chunks</li><li>Unstable requirements do not hold up progress</li><li>The whole team has visibility of everything and team communication is improved</li><li>Customers gain constant feedback on project state</li><li>Trust between customers and developers is established</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Scaling agile methods</span></div><ul><li>Difference between large team and small team development projects include</li><ul><li>Large teams are frequently in different geographical locations or time zones each developing a largely independent part of the larger system.</li><li>Large systems tend to interact with many already existing systems. These other systems may not lend themselves to easily to agile practices.</li><li>In large interacting systems, a lot of the development time is spent on configuring systems so that they work properly with each other. This may not be compatible with incremental development.</li><li>The development processes of large systems are often constrained by external rules.</li><li>People may move out of the team during the development process since this may last for years.</li><li>Diverse set of stakeholders in large systems is a problem for iterative design and tight feedback loops.</li></ul><li>Two perspectives on scaling of agile methods:</li><ul><li><span style="font-style: italic;">Scaling up</span>: how to use agile to build large systems?</li><li><span style="font-style: italic;">Scaling out</span>: how can agile methods be introduced across a large organization with many years of software developer experience?</li></ul><li>Possible ways in which agile could be modified to account for larger systems:</li><ul><li>Do more up-front design and system documentation. Critical aspects of the system must be documented.</li><li>Cross-team communication mechanisms have to be designed and used for specific cases.</li><li>Continuous integration is practically impossible in large systems due to impracticality of frequent deployment. There is a need for new configuration management tools that would support multi-team software development.</li></ul><li>Difficulties in introducing agile to large companies include</li><ul><li>Project managers do not have experience with agile and may be unwilling to accept it.</li><li>Large organizations have quality procedures and standards that all projects are expected to follow and are usually pretty bureaucratic.</li><li>Agile works best when team members are relatively qualified programmers.</li><li>Cultural resistence</li></ul></ul><div><br/></div></body></html>