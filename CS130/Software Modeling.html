<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:19:56 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:28:30 +0000"/><title>Software Modeling</title></head><body><div><hr/></div><div><span style="font-weight: bold;">Lecture Notes: January 31 — Modeling the Problem</span></div><hr/><ul><li>use cases</li><li>The reason for writing use cases is to understand the possible problems that might arise given a use case:</li><ul><li><span style="text-decoration: underline;">performance problems</span>: what to do if performance is low?</li><li><span style="text-decoration: underline;">input validation</span>: how much input validation do we need?</li><li><span style="text-decoration: underline;">bad actor</span>: what is customer doesn’t act as intended?</li><ul><li>due to lack of understanding</li><li>due to trying to subvert the system</li></ul></ul><li><span style="text-decoration: underline;">primary scenario</span>: normal case</li><li><span style="text-decoration: underline;">secondary scenario</span> (the real reason we write use cases): </li><ul><li>errors</li><li>alternatives</li></ul><li>How to analyze use cases and problems?</li><ul><li>many modeling techniques (UML supported):</li><ul><li><span style="font-style: italic; text-decoration: underline;">sequence diagram</span> (behavioral model)</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Model-driven architecture (MDA)</span></li><li><span style="font-style: italic; text-decoration: underline;">Model-driven engineering (MDE)</span></li><li><span style="font-style: italic; text-decoration: underline;">Architecture design</span></li><ul><li>Describes how components connect, not what they actually do</li><li>Why architectural design?</li><ul><li>Help design system</li><li>Document decisions</li><li>large scale reuse</li><li>system analysis</li><li>stakeholder communication</li><li>Provides conceptual integrity</li><li>Partitions work</li></ul><li>What we want of architectural design?</li><ul><li>program organization</li><li>data</li><li>business rules</li><li>resource management</li><li>security</li><li>performance and scalability</li><li>interoperability</li><li>internationalization</li><li>error processing</li><li>Somerville adds persistence, access control, concurrency</li></ul></ul><li>Architectural Patterns:</li><ul><li>Repository architecture</li><li>Pipe and filter</li><li>Call-and-return architecture</li><li>Message-passing architecture</li><li>Layered architecture</li><li>Event-driven architecture</li><li>Master-slave architecture</li><li>Fat client vs. thin client architecture</li></ul></ul><div/><div><span style="font-weight: bold;">Sommerville: Chapter 5 — System Modeling</span></div><hr/><ul><li>System modeling is the process of developing abstract models of a system, with each model presenting a different view or perspective of that system. </li><li>Usually done in the <span style="font-style: italic; text-decoration: underline;">Unified Modeling Language (UML)</span></li><li>Created during requirements engineering</li><li>Important to leave out detail in models.</li><li>Possible perspectives a model can be drawn for:</li><ul><li><span style="font-style: italic; text-decoration: underline;">External perspective</span>, where the context or environment of the system is modeled.</li><li><span style="font-style: italic; text-decoration: underline;">Interaction perspective</span>, where you model the interactions between a system and its environment or between the components of the system</li><li><span style="font-style: italic; text-decoration: underline;">Behavioral perspective</span>, where you model the dynamic behavior of the system and how it responds to events</li></ul><li>Essentials of UML are represented by following five diagram types:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Activity diagrams</span>, which show the activities involved in a process or in data processing.</li><li><span style="font-style: italic; text-decoration: underline;">Use case diagrams</span>, which show the interactions between a system and its environment</li><li><span style="font-style: italic; text-decoration: underline;">Sequence diagrams</span>, which show interaction between actors and the system and between system components.</li><li><span style="font-style: italic; text-decoration: underline;">Class diagrams</span>, which show the object classes in the system and the associations between these classes</li><li><span style="font-style: italic; text-decoration: underline;">State diagrams</span>, which show how the system reacts to internal and external events.</li></ul><li>How are models used?</li><ul><li>As a means of facilitating discussion about an existing or proposed system</li><li>As a way of documenting an existing system</li><li>As a detailed system description that can be used to generate a system implementation</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Context models</span></div><ul><li>Decide on system boundaries on early stages of system</li><li>Note that the system boundary may be determined by non-technical factors</li><li>Mental health system context model:</li></ul><div><img src="Software%20Modeling.resources/Screen%20Shot%202018-01-31%20at%209.26.19%20PM.png" height="385" width="667"/></div><div><br/></div><div><span style="font-weight: bold;">Interaction models</span></div><ul><li>Interaction models highlight communication issues that may arise</li><li>Two related approaches to interaction modeling:</li><ul><li>Use case modeling (usually used to model interaction between a system and external actors)</li><ul><li>Good support for requirements elicitation</li></ul><li>Sequence diagrams, used to model interactions between system components.</li></ul></ul><div><img src="Software%20Modeling.resources/Screen%20Shot%202018-01-31%20at%209.32.53%20PM.png" height="388" width="701"/></div><div><br/></div><div><span style="font-weight: bold;">Structural models</span></div><ul><li>Display the organization of a system in terms of the components that make up the system and their relationships</li></ul><div><br/></div><div><span style="font-weight: bold;">Class diagrams</span></div><ul><li>Used when developing an object-oriented system model to show the classes in a system and the associations between these classes.</li></ul><div><br/></div><div><span style="font-weight: bold;">Generalization diagrams</span></div><div><img src="Software%20Modeling.resources/Screen%20Shot%202018-01-31%20at%209.37.48%20PM.png" height="308" width="463"/></div><div><span style="font-weight: bold;">Behavioral models</span></div><ul><li>Models of dynamic behavior of system as it is executing.</li><li>Possible stimuli include:</li><ul><li><span style="font-style: italic;">Data </span>(<span style="font-style: italic; text-decoration: underline;">Data-driven modeling</span>)</li><li><span style="font-style: italic;">Events </span>(<span style="font-style: italic; text-decoration: underline;">Event-driven modeling</span>)</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Model-driven engineering (MDE)</span></div><ul><li>Models, rather than programs are the principal output of the development process</li><li>Programs are then generated from the models automatically</li><li>Arguments for MDE:</li><ul><li>Allows engineers to think about systems at a high level of abstraction</li><li>Reduces likelihood of errors</li><li>Speeds up design and implementation</li><li>Reusable, platform-independent application models</li><li>Same model, different platform</li></ul><li>Arguments against MDE:</li><ul><li>arguments for MDE are only valid for long-lifetime systems where the platforms become obsolete during a system’s lifetime. However, for this class of systems, implementation is not the major problem — requirements engineering, security and dependability, integration to legacy systems, and testing are all more significant.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Model-driven architecture (MDA)</span></div><ul><li>Uses a sub-set of UML models to describe a system<img src="Software%20Modeling.resources/Screen%20Shot%202018-01-31%20at%2010.15.40%20PM.png" height="236" width="547"/></li><li>MDA method recommends three types of abstract system models be produced:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Computation Independent Model (CIM)</span> that models the important domain abstractions used in the system. Often called domain models.</li><li><span style="font-style: italic; text-decoration: underline;">Platform independent model (PIM)</span> that models the operation of the system without reference to its implementation.</li><li><span style="font-style: italic; text-decoration: underline;">Platform specific models</span> which are transformations of the platform-independent model with a separate PSM for each application platform</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Executable UML</span></div><ul><li>Ideal of automated transformation of models to code</li></ul><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 6 — Architectural Design</span></div><hr/><ul><li>Even in agile processes, it is generally considered beneficial to include a comprehensive architecture stage at the beginning.</li><li>Software can be designed at two levels of abstraction:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Architecture in the small</span>. Concerned with the architecture of individual programs and how it is decomposed into components.</li><li><span style="font-style: italic; text-decoration: underline;">Architecture in the large</span>. Concerned with the architecture of complex enterprise systems that include other systems, programs, and components.</li></ul><li>Individual components implement the functional system requirements.</li><li>Non-functional requirements are largely affected by the interaction of these components (emergent property of the system)</li><li>Advantage of explicitly designing and documenting software architecture:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Stakeholder communication</span>. </li><li><span style="font-style: italic; text-decoration: underline;">System analysis</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Large-scale reuse</span>. Helps people understand the system and adapt it for reuse.</li></ul><li>Serves two purposes:</li><ul><li>design plan for the negotiation of system requirements</li><li>means of structuring discussions with clients, developers, and managers</li><li>Complexity management.</li></ul><li>Fundamental questions concerning any system:</li><ul><li>Is there a generic application architecture that can act as a template for the system that is being designed?</li><li>How will the system be distributed across a number of cores or processes?</li><li>What architectural patterns or styles might be used?</li><li>What will be the fundamental approach used to structure the system?</li><li>How will the structural components in the system be decomposed into subcomponents?</li><li>What strategy will be used to control the operation of the components in the system?</li><li>What is the impact of non-functional requirements on architectural decisions?</li><li>How will the architectural design be evaluated?</li><li>How will the architecture of the system be documented?</li></ul><li><span style="font-style: italic; text-decoration: underline;">Architectural patterns</span> are descriptions of a system organization (e.g. client-server organization, layered architecture)</li></ul><div><br/></div><div><span style="font-weight: bold;">Architectural Views</span></div><ul><li>What perspectives are useful when designing and documenting a system’s architecture?</li><li>What notations should be used for describing architectural models?</li><li><span style="font-style: italic; text-decoration: underline;">4+1 view model of software architecture</span> includes the following views:</li><ul><li><span style="text-decoration: underline;">A logical view.</span> Shows the key abstractions in the system as objects or object classes.</li><li><span style="text-decoration: underline;">A Process view</span>. How at run-time the system is composed of interacting processes. For non-functional requirements. </li><li><span style="text-decoration: underline;">A development view</span>.  Shows how the software is decomposed for development. For managers and programmers.</li><li><span style="text-decoration: underline;">A physical view</span><span style="font-style: italic;">. </span>Shows the system hardware and how software components are distributed across the processors in the system. Useful for systems engineers and system deployment.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Architectural Patterns</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Architectural Pattern</span>. A stylized, abstract description of good practice, tried and tested on different systems and environments.</li><li><span style="font-style: italic; text-decoration: underline;">Layered architecture</span>.</li><ul><li>Separation and independence for localizing possible future changes</li><li>Advantages include:</li><ul><li>Ability to replace entire layers so long as the interface is maintained.</li><li>Redundant facilities can be provided in each layer to increase dependability of entire system</li></ul><li>Disadvantages include:</li><ul><li>Hard to make a clean separation between layers</li><li>Performance impact due to inability to communicate between all layers</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Repository architecture</span>.</li><ul><li>Leverages a centralized database/repository for easy sharing of information between components.</li><li>No need for explicit data transfer (just put into repository and who needs it will pick it up)</li><li>Advantages include:</li><ul><li>Components can be largely independent</li><li>Changes made by one component can be propagated to all components</li><li>All data can be managed consistently when centralized</li></ul><li>Disadvantages include:</li><ul><li>Repository is single point of failure</li><li>Organizing all communication through the repository may be inefficient</li><li>Distributing the repository to a network of computers may be difficult</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Client-server architecture</span>.</li><ul><li>Common runtime organization for distributed systems</li><li>Functionality organized into services, with each service delivered from a separate server. Clients make use of these services through servers.</li><li>Advantages include:</li><ul><li>servers can be distributed across a network</li><li>functionality could be available to all clients and does not need to be implemented by all services.</li></ul><li>Disadvantages include:</li><ul><li>Each service is a single point of failure so susceptible to DoS attacks of server failure.</li><li>Performance may be unpredictable</li></ul><li>Defined by:</li><ul><li>A set of servers that offer services to other components.</li><li>A set of clients that call on the services offered by servers.</li><li>A network that allows the clients to access these services.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Pipe and filter architecture</span>.</li><ul><li>Each processing component (<span style="font-style: italic; text-decoration: underline;">filter</span>) is discrete and carries out one type of data transformation.</li><li>The data flows from one component to another for processing.</li><li>Advantages include:</li><ul><li>Easy to understand and supports transformation reuse</li><li>Workflow matches structure of many business processes</li><li>Evolution can be easily done by just adding filters to the pipe</li><li>Can be implemented either sequentially or concurrently</li></ul><li>Disadvantages include:</li><ul><li>The format for data transfer has to be agreed upon between communicating transformations</li><li>Each transformation must parse its input and then unbars its output to the agreed format, which increases system overhead.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Application Architectures</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Enterprise Resource Planning (ERP)</span>. Increasing trend in companies such as SAP and Oracle</li><li><span style="font-style: italic; text-decoration: underline;">Vertical software packages (COTS)</span>. </li><li>In these systems, a generic system is configured and adapted to create a specific business application.</li><li>How to use application architecture as a software designer</li><ul><li><span style="font-style: italic; text-decoration: underline;">As a starting point for the architectural design process</span>. Good to base your initial design on a generic application architecture if you are unfamiliar with the problem domain.</li><li><span style="font-style: italic; text-decoration: underline;">As a design checklist</span>. Use to check that your design is consistent with the generic architecture.</li><li><span style="font-style: italic; text-decoration: underline;">As a way of organizing the work of the development team</span>. Use to separate components out and assign tasks to teams since components can usually be developed in parallel.</li><li><span style="font-style: italic; text-decoration: underline;">As a means of assessing components for reuse</span>. Does the model suggest any components that you already have and that can be reused?</li><li><span style="font-style: italic; text-decoration: underline;">As a vocabulary for talking about types of applications</span>. </li></ul><li>Two types of applications will be discussed:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Transaction processing applications</span>. Database-centered applications that process user requests for information and update the information in a database. Include banking systems, e-commerce systems, information systems, booking systems.</li><li><span style="font-style: italic; text-decoration: underline;">Language processing systems</span>. E.g. compilers, command languages for databases, markup languages such as XML</li></ul><li><span style="font-style: italic; text-decoration: underline;">Transaction processing systems</span>.</li></ul><div><br/></div><div><img src="Software%20Modeling.resources/Screen%20Shot%202018-01-31%20at%2010.03.43%20AM.png" height="248" width="529"/></div><ul><li><span style="font-style: italic; text-decoration: underline;">Language Processing Systems</span>.</li></ul><div><img src="Software%20Modeling.resources/Screen%20Shot%202018-01-31%20at%2010.07.48%20AM.png" height="292" width="439"/></div><div><br/></div></body></html>