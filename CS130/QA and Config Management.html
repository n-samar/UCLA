<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:13:19 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:33:49 +0000"/><title>QA and Config Management</title></head><body><div><hr/></div><div><span style="font-weight: bold;">Lecture Notes: February 7 — Quality Assurance &amp; Configuration Management</span></div><hr/><div><span style="font-weight: bold;">Class Design</span></div><ul><li>Class is a collection of data and code</li><li>Want it to be cohesive</li><li>Can be looked at in isolation</li><li>Can be implemented in any language. Approaches:</li><ul><li><span style="font-style: italic; text-decoration: underline;">(int) handles</span>. As in int fd = open(…); which is an object-oriented view of files; open here is a constructor</li><li><span style="font-style: italic; text-decoration: underline;">an opaque type</span>. FILE *f = fopen(“…”, …); which is a pointer to an object-oriented object, with an obfuscated underlying structure that cannot be accessed (type of f here would be struct __FILE FILE).</li><li><span style="font-style: italic; text-decoration: underline;">implicit instances</span>. As in setlocale(LC_ALL, “en_US.UTF-8”); the locale here is somewhere in the system, but we cannot directly access it; it is fully maintained by the system; this is usually not a good idea, due to global effects.</li></ul><li>Question: Should I create a new class to do a thing; should i incorporate it into another class; should I split these classes into two; So, when to create a class?</li><ul><li><span style="font-style: italic; text-decoration: underline;">Complexity reduction</span>. If adding a class makes the program less complicated, add it.</li><li><span style="font-style: italic; text-decoration: underline;">Real-world object modeling</span>. Classes might not work that well for abstract objects vs. physical.</li><li><span style="font-style: italic; text-decoration: underline;">To package related operations</span>. Package a class about trigonometric operations.</li><li><span style="font-style: italic; text-decoration: underline;">To avoid excessive parameter passing</span>. If making a class reduces parameter passing, that’s great!</li></ul><li>When not to create a class?</li><ul><li><span style="font-style: italic; text-decoration: underline;">If your class name is a verb</span>. Class should focus on objects, not on actions.</li><li><span style="font-style: italic; text-decoration: underline;">If your class has no methods</span>.</li><li><span style="font-style: italic; text-decoration: underline;">If your class does everything</span>.</li></ul><li>Design principles for class-level design:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Leskov Substitution Principle</span>: If you have a class and you are using an instance of it, you should not care if the object is of the actual class type or of a derived class type.</li><li><span style="font-style: italic; text-decoration: underline;">Interface Segregation Principle</span>. You shouldn’t have a lot of direct children. Instead of a base class having 10 children, increase the number of abstraction levels (that is the depth of the tree) and decrease the number of children per parent.</li><li><span style="font-style: italic; text-decoration: underline;">Dependency Inversion Principle</span>. </li><ul><li>Only depend on class interfaces, not on implementation.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Open-Closed Principle</span>. </li><ul><li>Prefer subclassing to modifying the base class.</li><li>“Classes should be open to extension and closed to modification”</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Package Design Principles</span></div><ul><li>Packages serve a different purpose than classes</li><li>Packaging is about how software is <span style="font-style: italic; text-decoration: underline;">maintained and delivered</span>, classes are about how the program behaves at run-time.</li><li><span style="font-style: italic; text-decoration: underline;">Common Reuse Principle (CRP)</span>. Package together classes only if they are commonly used together.</li><li><span style="font-style: italic; text-decoration: underline;">Release Reuse Equivalency Principle</span>. Release packages, not classes. Maintainers and operations staff know the language of packages, and not of classes.</li><li><span style="font-style: italic; text-decoration: underline;">Common Closure Principle</span>. If changing one class typically involves changing the other, they should be packaged together.</li><li><span style="font-style: italic; text-decoration: underline;">Law of Demeter</span>. Avoid indirect connections from one class to another. Have on class depend on another class without that being a salient thing is bad. The idea is that this induces implicit dependencies.</li><ul><li>Object A can call its own methods</li><li>If Object A creates another object B, it can call B’s methods</li><li>However, Object A should avoid calling methods on objects provided by B.</li></ul></ul><div><br/></div><div>TODO: insert table of defect-detection rates here</div><div><br/></div><div><span style="font-weight: bold;">Quality Management</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Change Management</span></li><li><span style="font-style: italic; text-decoration: underline;">Configuration Management</span></li><li><span style="font-style: italic; text-decoration: underline;">Software Quality:</span></li><ul><li>What is it?</li><li>How can you improve?</li><li>How effective are the methods for improving it?</li><li>When should you improve on quality? </li><li>How much does the improvement cost?</li></ul><li><span style="font-style: italic; text-decoration: underline;">The Meyer’s Dilemma</span></li><ul><li>Ship fast, terrible quality, users hate it, you lose</li><li>Ship late, high quality, users already using something else, you lose</li><li>You want to be goldilocks</li></ul><li>What is quality?</li><ul><li>Etymology: from latin work qua which means what… So we don’t know what quality is</li><li>Basic idea is we are looking for attributes of quality</li><li>These attributes should be <span style="text-decoration: underline;">desirable</span><span style="font-style: italic;"> </span>and <span style="text-decoration: underline;">measurable</span></li></ul><li><span style="font-style: italic; text-decoration: underline;">Quality Control (QC)</span>. </li><ul><li>Measure that the product corresponds to the required quality attributes</li><li>If the quality of the product is too high with regards to the spec (i.e. it is higher that the required quality), figure out how to reduce quality and increase other attributes such as mean delivery time</li></ul><li><span style="font-style: italic; text-decoration: underline;">Correctness</span>. Means: does the product match the spec?</li><li><span style="font-style: italic; text-decoration: underline;">Reliability</span>. Means: What is our mean-time-to-failure?</li><li><span style="font-style: italic; text-decoration: underline;">Robustness</span>. Means: How does the system respond to odd conditions?</li><li><span style="font-style: italic; text-decoration: underline;">Integrity</span>. Means: How does the system resist tampering and screw ups?</li><li><span style="font-style: italic; text-decoration: underline;">Functionality</span>. Means: Does it provide the functions the users desire?</li><li><span style="font-style: italic; text-decoration: underline;">Efficiency</span>. Means: Low resource use</li><li><span style="font-style: italic; text-decoration: underline;">Usability</span>. Means: Is the software easy to learn and use?</li><li><span style="font-style: italic; text-decoration: underline;">Flexibility</span>. Means: Is it easy to modify?</li><li><span style="font-style: italic; text-decoration: underline;">Adaptability</span>. Means: Is this system useful in other domains?</li><li><span style="font-style: italic; text-decoration: underline;">Reusability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Testability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Maintainability</span>. Means: Easy to fix?</li><li><span style="font-style: italic; text-decoration: underline;">Portability</span>. Means: Is it easy to move the software to another platform?</li><li><span style="font-style: italic; text-decoration: underline;">Readability</span>. Small scale</li><li><span style="font-style: italic; text-decoration: underline;">Understandability</span>. Large scale, more abstract to readability. Can you see the large structure of the program?</li><li><span style="font-style: italic; text-decoration: underline;">User-visible attributes</span>. (External characteristics)</li><li><span style="font-style: italic; text-decoration: underline;">User-invisible attributes</span>. (Internal characteristics)</li><li>More attributes:</li><ul><li>Safety (software will not do anything dangerous), security, resilience (this system will keep working even if parts break down)</li></ul><li>Plan-driven QA:</li><ul><li>it’s somebody’s job, reports directly to upper management</li><li>If there is nobody that has a job to assure quality, there will be no quality</li><li>this person </li><ul><li>plans, </li><li>reviews software process, </li><li>review deviations from the software process as they occur,</li><li>audits software work products</li><li>documenting deviations</li></ul></ul><li>Agile:</li><ul><li>Quality is everybody’s responsibility (e.g. pair programming)</li><li>Keep code public (within the development team and project) — open source is a good idea because it facilitates this idea</li><li>Use good code as an example</li></ul></ul><div><hr/></div><div><span style="font-weight: bold;">Sommerville: Chapter 24 — Quality Management</span></div><hr/><ul><li>Three principal concerns of software quality management for software systems:</li><ul><li>At the organizational level, quality management is concerned with establishing a framework of organizational processes and standards that will lead to high-quality software.</li><li>At the project level, quality management involves the application of specific quality processes, checking that these planned processes have been followed, and ensuring that the project outputs are conferment with the standards that are applicable to that project.</li><li>Quality management at the project level is also concerned with establishing a quality plan for a project. This plan should set out the quality goals for the project and define what processes and standards are to be used.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Quality Assurance (QA)</span> is the definition of processes and standards that should lead to high-quality products and the introduction of quality processes into the manufacturing process.</li><li><span style="font-style: italic; text-decoration: underline;">Quality Control</span> is the application of these quality processes to weed out products that are not of the required level of quality</li><li>Quality management team should not be associated with any particular development group, but should rather have organization-wide responsibility for quality management.</li><li>The suggested outline structure for a quality plan:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Product introduction</span>. A description of the product, tis intended market, and the quality expectations</li><li><span style="font-style: italic; text-decoration: underline;">Product plans</span>. The critical release dates and responsibilities for the product, along with plans for distribution and product servicing.</li><li><span style="font-style: italic; text-decoration: underline;">Process descriptions</span>. The development and service processes and standards that should be used for product development and management.</li><li><span style="font-style: italic; text-decoration: underline;">Quality goals</span>. Including identification of justification of critical product quality attributes.</li><li><span style="font-style: italic; text-decoration: underline;">Risks and risk management</span>. The key risks that might affect product quality and the actions to be taken to address these risks. </li></ul><li>Quality managers should aim to develop a quality culture where everyone responsible for software development is committed to achieving a high level of product quality.</li></ul><div><br/></div><div><span style="font-weight: bold;">Software Quality</span></div><ul><li>QA team is required to review the tests that check a programs fitness for purpose.</li><li>It is difficult to assess software quality attributes, such as maintainability, without using the software for a long time.</li></ul><div><br/></div><div><span style="font-weight: bold;">Software Standards </span></div><ul><li>An important part of quality assurance is the definition or selection of standards that should apply to the software development process or product.</li><li>Why are software standards important?</li><ul><li>Standards capture wisdom that is of value to the organization. They are based on knowledge about the best or most appropriate practice for the company. They thus prevent remaking the same quality mistakes.</li><li>Standards provides  framework for defining what quality means in a particular setting.</li><li>Standards assist continuity when work carried out bu one person is taken up and continued by another. Standards ensure that all engineers within an organization adopt the same practices.</li></ul><li>Two related types of software engineering standards that may be used in software quality management:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Product standards</span>. Apply to the software product being developed. Include document standards, documentation standards, coding standards.</li><li><span style="font-style: italic; text-decoration: underline;">Process standards</span>.Define the processes that should be followed during software development. May define specification, design, and validation processes, process support tools, and a description of documents that should be written using these processes.</li></ul><li>The purpose of standards is to deliver value, in the form of increased product quality. They need to be designed so that they can be applied and checked in a cost-effective way.</li><li>Quality management teams that are developing standards for a company should normally base these company standards on national and international standards.</li><li>To minimize dissatisfaction and to encourage buy-in to standards, quality managers who set the standards should therefore take the following steps:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Involve software engineers in the selection of product standards</span>. Your standards document should include explanations why the development team agreed to follow the standards listed.</li><li><span style="font-style: italic; text-decoration: underline;">Review and modify standards regularly to reflect changing technologies</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Provide software tools to support standards</span>.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">The ISO 9001 standards framework</span></div><ul><li>An international set of standards that can be used in the development of quality management systems in all industries called ISO 9000.</li><li>ISO 9001 is the most general of the standards in the ISO 9000 family and pertains to organizations that design, develop, and maintain products, including software. </li><li>Nine core processes of ISO 9001:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Product delivery processes</span>:</li><ul><li>Business Acquisition</li><li>Design and Development</li><li>Test</li><li>Production and Delivery</li><li>Service and Support</li></ul><li><span style="font-style: italic; text-decoration: underline;">Supporting processes</span>:</li><ul><li>Business Management</li><li>Supplier Management</li><li>Inventory Management</li><li>Configuration Management</li></ul></ul><li>To be ISO 9001 compliant, a company must only define the specific quality processes listed above, with no restrictions on the definition.</li></ul><div><br/></div><div><span style="font-weight: bold;">Reviews and Inspections</span></div><ul><li>Reviews and inspections are QA activities that check the quality of project deliverables.</li><li>The review should check the consistency and completeness of the documents or code under review and make sure that quality standards have been followed.</li><li>The purpose of reviews and inspections is to improve software quality, not to asses the performance of people in the development team.</li><li><span style="font-style: italic; text-decoration: underline;">The Review process</span>. Three phases:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Pre-review activities</span>. Concerned with review planning and review preparation. The team may meet to get an overview of the software to be reviewed.</li><li><span style="font-style: italic; text-decoration: underline;">The review meeting</span>. An author of the document or program being reviewed should walk through the document with the review team during the review meeting. One team member should chair the review and another should formally record all review decisions and actions to be taken.</li><li><span style="font-style: italic; text-decoration: underline;">Post-review activities</span>. After the meeting is finished, the issues and problems raised during the review must be addressed.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Program inspections</span>.</li><ul><li>Peer reviews where team members collaborate to find bugs in the program that is being developed</li><li>During inspection, a checklist of common programming errors is often used to focus the search for bugs. This checklist is often programming language specific.</li><li>These checklists should be regularly updated.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Software measurement and metrics</span></div><ul><li>The long-term goal of software measurement is to use measurement in place of reviews to make judgments about software quality.</li><li>Examples of control or process metrics are the average effort and the time required to repair reported defects.</li><li>Predictor metrics are associated with the software itself.</li><li>Two ways in which measurements of a software system can be used</li><ul><li><span style="font-style: italic; text-decoration: underline;">To assign a value to system quality attributes</span>. </li><li><span style="font-style: italic; text-decoration: underline;">To identify the system components whose quality is substandard</span>.</li></ul><li>If the measure of the internal attribute is to be a useful predictor of the external software characteristic, three conditions must hold</li><ul><li>The internal attribute must be measured accurately.</li><li>A relationship must exist between the attribute that can be measured and the external quality attribute that is of interest.</li><li>This relationship between the internal and external attributes must be understood, validated, and expressed in terms of a formula or model.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Product metrics</span></li><ul><li>E.g., system size, measured in lines of code, or the number of methods associated with each object class.</li><li>Two categories of product metrics:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Dynamic metrics</span>. Collected by measurements made of a program in execution.</li><li><span style="font-style: italic; text-decoration: underline;">Static metrics</span>. Collected by measurements made of representations of the system.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Measurement ambiguity</span></li><ul><li>It is easy to misinterpret data and to make inferences that are incorrect.</li></ul></ul><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 25 — Configuration Management</span></div><hr/><ul><li>Configuration management is concerned with the policies, processes, and tools for mangling changing software systems.</li><li>Involves four closely related activities:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Change management</span>. Involves keeping track of requests for changes to the software from customers and developers</li><li><span style="font-style: italic; text-decoration: underline;">Version management</span>. </li><li><span style="font-style: italic; text-decoration: underline;">System building</span>. Process of assembling program components, data, and libraries, and then compiling and linking these to create an executable system.</li><li><span style="font-style: italic; text-decoration: underline;">Release management</span>. Involves preparing software for external release.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Change management</span>.</li><ul><li>Ensures that the changes are applied to the system in a controlled way.</li><li>Ensures priority is given to the most urgent and cost-effective changes.</li><li>Concerned with analyzing the costs and benefits of proposed changes.</li><li>Concerned with tracking changed components and histories </li><li>After a change request has been submitted, it has to be checked to ensure that it addresses a valid concern and that it is not caused by misunderstanding.</li><li>Significant factors that should be taken into account in deciding whether or not a change should be approved are</li><ul><li><span style="font-style: italic; text-decoration: underline;">The consequences of not making the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The benefits of the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The number of users affected by the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The cost of making the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The product release cycle</span>.</li></ul><li>A record must be maintained of each component as changes are introduced.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Version management</span>.</li><ul><li>Baselines may be specified using a configuration language, which allow you to define what components are included in a version of a particular system.</li><li>Features provided by version management systems:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Version and release identification</span>. Managed versions are assigned identifiers when they are submitted to the system.</li><li><span style="font-style: italic; text-decoration: underline;">Storage management</span>. To reduce the storage space required by multiple versions of components that differs only slightly, version management systems usually provide storage management facilities.</li><li><span style="font-style: italic; text-decoration: underline;">Change history recording</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Independent development</span>. Different developers may be working on the same component at the same time. System makes sure changes do not collide.</li><li><span style="font-style: italic; text-decoration: underline;">Project support</span>. </li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">System building</span></div><ul><li>System building is the process of creating a complete, executable system by compiling and linking the system components, external libraries, configuration files, … </li><li>Building is complex, because there may be three different system platforms involved:</li><ul><li><span style="font-style: italic; text-decoration: underline;">The development system</span>, which includes development tools such as compilers, source code editors, … This involves using local build tools that use checked-out versions of components in the private workspace.</li><li><span style="font-style: italic; text-decoration: underline;">The build server</span>, which is used to build definitive, executable versions of the system. This interacts closely with the version management system. This interacts closely with the version management system. The system build may rely on external libraries that are not included in the version management system.</li><li><span style="font-style: italic; text-decoration: underline;">The target environment</span>, which is the platform on which the system executes. It is often not possible to build and test the system on the development computer or on the build server.</li></ul><li>Features a build system may provide include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Build script generation</span>. Defines dependent components and lists all dependencies in a defined script language.</li><li><span style="font-style: italic; text-decoration: underline;">Version management system integration</span>.The build system should check out the required versions of components from the version management system.</li><li><span style="font-style: italic; text-decoration: underline;">Minimal recompilation</span>. The build system should work out what source code needs to be recompiled and set up compilations if required.</li><li><span style="font-style: italic; text-decoration: underline;">Executable system creation</span>. The build system should link the compiled object code files with each other and with other required files, such as libraries and configuration files, to create an executable system.</li><li><span style="font-style: italic; text-decoration: underline;">Test automation</span>. Check that the build has not been broken by changes.</li><li><span style="font-style: italic; text-decoration: underline;">Reporting</span>. The build system should provide reports about the success or failure of the build.</li><li><span style="font-style: italic; text-decoration: underline;">Documentation generation</span>. </li></ul><li>Signatures used to eliminate redundant recompilation:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Modification timestamps</span>. The signature on the source code file is the time and date when that file was modified. Recompile if compiled version is older than the last modified time of the source code.</li><li><span style="font-style: italic; text-decoration: underline;">Source code checksums</span>. The signature on the source code file is a checksum calculated from data in the full. If there is no object code with appropriate checksum signature, compile.</li></ul><li>Agile methods recommend that very frequent system builds should be carried out with automated testing to discover software problems.</li><li><span style="font-style: italic; text-decoration: underline;">Continuos integration</span> — idea of making changes to the end-system frequently. Steps in continuous integration:</li><ul><li>Check out the mainline system from the version management system into the developer’s private workspace</li><li>Build the system and run automated tests to ensure that the built system passes all tests. If not, the build is broken and you should inform whoever did the last commit.</li><li>Make the changes to the system components</li><li>Build the system in the private workspace and rerun system tests. If the tests fail, continue editing.</li><li>Once the system has passed its tests, check it into the build system but do not commit it as a new system baseline.</li><li>Build the system on the build server and run the tests. You need to do this in case others have modified other components since you checked out the system.</li><li>Once the system passes its tests on the build system, commit the changes you have made as a new baseline in the system mainline.</li></ul><li>Possible issues with continuous integration:</li><ul><li>If the system is very large, it may take a long time to build and test making continuous integration impractical.</li><li>If the development platform is different from the target platform, it may not be possible to run system tests in the developer’s private workspace.</li></ul><li>If continuous integration is not practical, a daily build system may be used:</li><ul><li>The development organization sets a delivery time for system components. If developers have new versions of the components that they are writing, they must deliver them by that time. Components may be incomplete but should provide some basic testable functionality.</li><li>A new version of the system is built from these components by compiling and linking them to form a complete system.</li><li>This system is then delivered to the testing team, which carries out a set of predefined system tests.</li><li>Faults that are discovered during system testing are documented and returned to the system developers. They repair these faults in a subsequent version of the component.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Release management</span></div><ul><li>A system release is a version of a software system that is distributed to customers.</li><li>The company must be able to reproduce the exact piece of software delivered to some customer at some point in time.</li><li>Make sure to record the versions of the operating system, libraries, compilers, and other tools used to build the software.</li><li>Careful thought must be given to release timing.</li><li>If releases are too frequent or require hardware upgrades, customers may not move to the new releases</li><li>If system releases are too infrequent, market share may be lost as customers move to alternative systems</li><li>A system release is not just the executable code of the system. It may also include:</li><ul><li>configuration files defining how the release should be configure for particular installations</li><li>data files needed for successful system operation</li><li>an installation program that is used to help install the system on target hardware</li><li>electronic and paper documentation designing the system</li><li>packaging and associated publicity that have been designed for that release.</li></ul><li>New releases of the system cannot rely on the installation of previous releases, because there is no guarantee these were performed by the customer.</li></ul><div><hr/></div><div/><div><span style="font-weight: bold;">McConnell: Chapter 20 — The Software-Quality Landscape</span></div><hr/><ul><li>This chapter surveys software-quality techniques from a construction point of view.</li></ul><div><br/></div><div><span style="font-weight: bold;">Characteristics of Software Quality</span></div><ul><li>Software has both internal and external quality characteristic</li><li>External characteristics are those the software user is aware of. These include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Correctness</span>. The degree to which a system is free from faults in its specification, design, and implementation</li><li><span style="font-style: italic; text-decoration: underline;">Usability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Efficiency</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Reliability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Integrity</span>. The degree to which a system prevents unauthorized or improper access to its programs and data.</li><li><span style="font-style: italic; text-decoration: underline;">Adaptability</span>. The extend to which a system can be used, without modification, in applications or environments other than those for which it was specifically designed.</li><li><span style="font-style: italic; text-decoration: underline;">Accuracy</span>. The degree to which a system is free from error, especially with respect to quantitative outputs. This is different from correctness; it determines how well a system does the job it’s built for rather than whether it was built correctly.</li><li><span style="font-style: italic; text-decoration: underline;">Robustness</span>. The degree tow which a system continues to function in the presence of invalid inputs.</li></ul><li>Internal quality characteristics include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Maintainability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Flexibility</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Portability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Reusability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Readability</span>. The ease with which you can read and understand the source code of the system.</li><li><span style="font-style: italic; text-decoration: underline;">Testability</span>. The degree to which you can unit test and system test a system</li><li><span style="font-style: italic; text-decoration: underline;">Understandability</span>. The ease at which you can comprehend a system at both the system-organizational and detailed-statement levels.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Techniques for Improving Software Quality</span></div><ul><li>Elements of a software quality program</li><ul><li><span style="font-style: italic; text-decoration: underline;">Software quality objectives</span>. Without explicit goals, programmers might work to maximize characteristics different from the ones you expect them to maximize.</li><li><span style="font-style: italic; text-decoration: underline;">Explicit quality assurance activity</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Testing strategy</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Software engineering guidelines</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Informal technical reviews</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Formal technical reviews</span>.</li><li><span style="font-style: italic; text-decoration: underline;">External audits</span>.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Development Process</span></li><ul><li><span style="font-style: italic; text-decoration: underline;">Change control procedures</span>. One big obstacle to achieving software quality is uncontrolled changes.</li><li><span style="font-style: italic; text-decoration: underline;">Measurement of results</span>. Unless results of a quality-assurance plan are measured, you’ll have no way to know whether the plan is working.</li><li><span style="font-style: italic; text-decoration: underline;">Prototyping</span>. </li></ul><li><span style="font-style: italic; text-decoration: underline;">Setting Objectives</span></li><ul><li>Programmers have high achievement motivation: They will work to the objectives specified, but they must be told what the objectives are.</li></ul><li>If project developers are striving for a higher defect-detection rate, they need to use a variation of techniques.</li><li>The most economical defect-detection practices result in the least cost per defect found, all other things being equal.</li><li>Inspections are usually cheaper than testing. Code reading detected about 80 percent more faults per hour than testing in a study.</li><li>The longer a defect remains in the system, the more expensive it becomes to remove.</li><li>Testing is a two step process — it requires first noticing an issue and then diagnosing it. This increases defect correction time dramatically compared to other one-step methods.</li><li>A recommended combination for achieving higher-than-average quality:</li><ul><li>Formal inspections of all requirements, all architecture, and designs for critical parts of a system</li><li>Modeling/prototyping</li><li>Code reading or inspections</li><li>Execution testing</li></ul></ul><ul><li>General principles of software quality</li><ul><li>The General Principle of Software Quality is that improving quality reduces development costs.</li><li>The single biggest activity on most projects is debugging and correcting code that doesn’t work properly.</li></ul></ul><div><br/></div></body></html>