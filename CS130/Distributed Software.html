<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:23:20 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:23:37 +0000"/><title>Distributed Software</title></head><body><div/><div><span style="font-weight: bold;">Sommerville: Chapter 18 — Distributed Software Engineering</span></div><hr/><ul><li>Virtually all large computer-based systems are now distributed systems.</li><li>A distributed system is a collection of independent computers that appears to the user as a single coherent system.</li><li>Advantages of using a distributed approach to systems development:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Resource sharing</span>. A distributed system allows the sharing of hardware and software resources that are associated with computers on a network.</li><li><span style="font-style: italic; text-decoration: underline;">Openness</span>. Distributed systems are normally open systems, which means that they are designed around standard protocols that allow equipment and software from different vendors to be combined.</li><li><span style="font-style: italic; text-decoration: underline;">Concurrency.</span> Several processes may operate at the same time on separate computers on the network.</li><li><span style="font-style: italic; text-decoration: underline;">Scalability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Fault tolerance</span>. The availability of several computers and the potential for replicating information means that distributed systems can be tolerant of some hardware and software failures.</li></ul><li>Distributed systems are inherently more complex than centralized systems. </li><li>Distributed systems exhibit emergent properties that are hard to predict.</li></ul><div><br/></div><div><span style="font-weight: bold;">Distributed Systems Issues</span></div><ul><li>Design issues that have to be considered in distributed systems engineering are:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Transparency</span>. To what extent should the distributed system appear to the user as a single system?</li><li><span style="font-style: italic; text-decoration: underline;">Openness</span>. Should a system be designed using standard protocols that support interoperability?</li><li><span style="font-style: italic; text-decoration: underline;">Scalability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Security</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Quality of service</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Failure management</span>.</li></ul><li>Central control of a distributed system is impossible, so individual computers in a system may behave differently at different times.</li><li>Network delays are unavoidable.</li><li>The three dimensions of scalability:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Size</span>. It should be possible to add more resources to a system to cope with increasing numbers of users</li><li><span style="font-style: italic; text-decoration: underline;">Distribution</span>. It should be possible to geographically disperse the components of a system without degrading its performance.</li><li><span style="font-style: italic; text-decoration: underline;">Manageability</span>. It should be possible to manage a system as it increases in size, even if parts of the system are located in independent organizations.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Scaling-up</span>: Replacing existing resources with more powerful alternatives</li><li><span style="font-style: italic; text-decoration: underline;">Scaling-out</span>: means adding additional resources to the system</li><li>Types of attacks that a distributed system must defend against:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interception</span>, where communications between parts of the system are intercepted by an attacker which implies loss of confidentiality</li><li><span style="font-style: italic; text-decoration: underline;">Interruption</span>, where system services are attacked and cannot be delivered as expected.</li><li><span style="font-style: italic; text-decoration: underline;">Modification</span>, where data or services in the system are changed by an attacker</li><li><span style="font-style: italic; text-decoration: underline;">Fabrication</span>, where an attacker generates information that is not suppose to exist.</li></ul><li>Different organizations that own different parts of the system may implement incompatible security policies.</li><li><span style="font-style: italic; text-decoration: underline;">Models of interaction</span></li><ul><li>two fundamental types of interaction that may take place between the computers in a distribute computing system:</li><ul><li>procedural interaction (implemented through <span style="font-style: italic; text-decoration: underline;">remote procedure calls (RPCs)</span></li><ul><li>requires both the caller and callee to be alive</li></ul><li>message-based interaction </li><ul><li>involves one component creating a message that details the services required from another component</li><li>the receiving component receives this message through middleware software</li><li>middleware transits the receiver’s response</li><li>unavailability can be tolerated as the message simply stays in the queue until receiver becomes available</li></ul></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Middleware</span>. Sits in the middle between distributed components of a system.</li><ul><li>General purpose software, usually bought off-shelf</li><li>Middleware provides two distinct types of support in a distributed system</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interaction support</span>, where the middleware coordinates interaction between different components in the system.</li><li><span style="font-style: italic; text-decoration: underline;">The provision of common services</span>, where the middleware provides reusable implementations of services that may be required by several components in the distributed system. By using these common services, components can easily interoperate and provide user services in a consistent way.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Client-server computing</span></div><ul><li>Usual organization of distributed systems.</li><li>Application is modeled as set of services provided by a server.</li><li>Load-balancing software distributes requests for service from clients to different servers so that each server does the same amount of work</li><li>Architectural patterns for distributed systems</li><ul><li>Five architectural styles:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Master-slave architecture</span>. Used in real-time systems in which guaranteed interaction response times are required.</li><li><span style="font-style: italic; text-decoration: underline;">Two-tier client-server architecture</span>. Used in simple client-server systems, and when centralizing the system is important for security.</li><li><span style="font-style: italic; text-decoration: underline;">Multitier client-server architecture</span>. Used to reduce the processing volume of the central server.</li><li><span style="font-style: italic; text-decoration: underline;">Distributed component architecture</span>. Used when resources from different systems and databases need to be combined.</li><li><span style="font-style: italic; text-decoration: underline;">Peer-to-peer architecture</span>. Used when clients exchange locally stored information and the role of the server is to introduce clients to each other.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Software as a services (SaaS)</span></div><ul><li>Problems of server overload can be significantly reduced by using a modern browser as the client software. You can even have the server send Javascript code to execute on the client.</li><li>Key elements of SaaS are the following:</li><ul><li>Software is deployed on a server and is accessed through a web browser.</li><li>Software is owned and managed by a software provider, rather than the organizations using the software</li><li>Users may pay for the software according to the amount of use they make of it or through an annual or monthly subscription.</li></ul><li>Data transfer is done at network speeds</li><li>Lack of control over software evolution</li><li>Differences between SaaS and SOA (Service Oriented Architectures)</li><ul><li>SaaS is a way of providing functionality on a remote server with client access through web browser. The server maintains the user’s data and state during an interaction session. Transactions usually last longer.</li><li>SOA is an approach to structuring a software system as a set of separate, stateless services. These may be provided by multiple providers and may be distributed. Transactions are typically short: service is called, it does something, and then returns a result.</li><li>SaaS is a way of delivering application functionality to the users, whereas SOA is an implementation technology for application systems.</li></ul><li>Agile development optimal for SaaS because initial approach is usually defined based on perceived need rather than specific customer feedback, so some adaptations will probably be necessary.</li><li>Three important factors concerning SaaS:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Configurability</span>. How do you configure the software for the specific requirements of each organization?</li><li><span style="font-style: italic; text-decoration: underline;">Multi-tenancy</span>. How do you present each user of the software with the impression that they are working with they own copy of the system while, at the same time, making efficient use of system resources?</li><li><span style="font-style: italic; text-decoration: underline;">Scalability</span>. How do you design the system so that it can be scaled to accommodate an unpredictably large number of users?</li></ul><li>Configuration facilities may allow for the following:</li><ul><li>Branding</li><li>Business rules and workflows</li><li>Database extensions</li><li>Access control</li></ul><li>Guidelines for developing scalable software:</li><ul><li>Develop applications where each component is implemented as a simple stateless device that can be run on any server.</li><li>Design the system using asynchronous interaction so that the application does not have to wait for the result of an interaction.</li><li>Manage resources as a pool so that no single server is likely to runout of them.</li><li>Design your database to allow fine-grain locking of data.</li></ul></ul><div><br/></div></body></html>