<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:28:40 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:29:07 +0000"/><title>Software Components</title></head><body><div><br/></div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 17 — Component-Based Software Engineering</span></div><hr/><ul><li>An approach to software reuse based on the composition of reusable, standardized components.</li><li><span style="font-style: italic; text-decoration: underline;">Component Based Software Engineering (CBSE)</span>.</li><ul><li>arrises after realization that single object classes are way to specific to be useful for reuse.</li></ul><li>Components are higher-level abstractions than objects and are defined by their interfaces.</li><li>Essentials of component-based software engineering:</li><ul><li>Independent components completely specified by their interfaces</li><li>Component standards that facilitate the integration of components.</li><ul><li>How should the component interfaces be specified?</li><li>Note that components written in different languages can be integrated into the same system.</li></ul><li>Middleware that provides software support for component integration.</li><ul><li>handles low-level issues efficiently and allows the developer to focus on application-related problems</li><li>May include component support for resource allocation, transaction management, security, and concurrency</li></ul><li>A development process geared to component-based software engineering.</li></ul><li>Design principles that support construction of understandable and maintainable software</li><ul><li>Components are independent and do not interfere with each other’s operation.</li><li>Components communicate through well-defined interfaces.</li><li>Component infrastructures offer a range of standard services that can be used in application systems.</li></ul><li>CBSE was motivated by:</li><ul><li>The need for more reuse</li><li>The need for distributed application systems</li></ul><li>Standardization of component development: COM, .NET, CCM, EJB, …</li><li>Standardization doesn’t work, so look at <span style="font-style: italic; text-decoration: underline;">component as a service</span> model.</li><li><span style="font-style: italic; text-decoration: underline;">Service oriented CBSE</span> becoming the dominant approach for the development of business systems</li></ul><div><br/></div><div><span style="font-weight: bold;">Components and Component Models</span></div><ul><li>Components must be</li><ul><li><span style="font-style: italic; text-decoration: underline;">Standardized</span></li><li><span style="font-style: italic; text-decoration: underline;">Independent</span></li><li><span style="font-style: italic; text-decoration: underline;">Composable</span></li><li><span style="font-style: italic; text-decoration: underline;">Deployable</span></li><li><span style="font-style: italic; text-decoration: underline;">Documented</span></li></ul><li>Looking at components as a service provider gives emphasis to two critical characteristics of a reusable component</li><ul><li>The component is an independent executable entity that is defined by its interfaces.</li><li>The services offered by a component made available through an interface and all interactions are through the interface.</li></ul><li>Two interfaces necessary for each component:</li><ul><li>The <span style="font-style: italic; text-decoration: underline;">provides interface</span> defines the services provided by the component.</li><li>The <span style="font-style: italic; text-decoration: underline;">requires interface</span> specifies what services must be provided by other components in the system if a component is to operate correctly.</li></ul></ul><ul><li><span style="font-style: italic; text-decoration: underline;">Component models</span>.</li><ul><li>a definition of standards for component implementation, documentation, and deployment</li><li>Necessary parts of component models:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interfaces</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Usage</span>. </li><ul><li>A globally unique name or handle associated with the component</li><li>How can the component be configure for a specific use case? </li><li>What are the rules of configuration of the component?</li></ul><li><span style="font-style: italic; text-decoration: underline;">Deployment</span>. </li><ul><li>Since components myst be independent, executable entities, they must be deployed with all necessary parts required for it to run aside from the ones defined by the <span style="font-style: italic; text-decoration: underline;">requires interface</span>.</li><li>Deployment information includes information about the contents of a package and its binary organization</li></ul></ul><li>Services provided by a component model implementation are in two categories:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Platform services</span>. Enable components to communicate and interpolate in a distributed environment</li><li><span style="font-style: italic; text-decoration: underline;">Support services</span>. Common services that are likely to be required by many different components. E.g. authentication.</li><ul><li>It makes sense to provide a standard set of middleware services for use by all components.</li></ul></ul><li>The middleware implements the component services and provides interfaces to these services.</li><li>It is as if components are deployed in a <span style="font-style: italic; text-decoration: underline;">container</span>.</li><ul><li>Containers are implementations of support services plus a definition of the interfaces that a component must provide to integrate with the container.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">CBSE Processes</span></div><ul><li>CBSE Processes are software processes that support component-based software engineering.</li><li>Two types of CBSE processes:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Development for reuse</span>. Concerned with developing components or services that will be reusable to other applications.</li><li><span style="font-style: italic; text-decoration: underline;">Development with reuse</span>. Recognizing and adapting already existing components for reuse in new systems.</li></ul><li>Related processes concerned with component acquisition, component management, and component certification:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Component acquisition</span>. Process of acquiring components for reuse or development into a reusable component (both externally and internally to the company)</li><li><span style="font-style: italic; text-decoration: underline;">Component management</span>. Concerned with managing a company’s reusable components, ensuring they are properly cataloged, stored, and made available for reuse.</li><li><span style="font-style: italic; text-decoration: underline;">Component certification</span>. </li></ul></ul><div><br/></div><div><span style="font-weight: bold;">CBSE for reuse</span></div><ul><li>The initial vision was that CBSE will be used in such a way that there will be dedicated companies that only built software components and then other companies with perhaps less developer power would buy component parts and relatively easily piece them together</li><li>Consequently, CBSE for ruse is most likely used within an organization.</li><li>However, components are usually not reusable without change</li><li>Since generalization of software components for reuse has an associated cost, it should be determined early if the component is to be made for reuse</li><li><span style="font-style: italic; text-decoration: underline;">Stable domain abstractions</span> are fundamental elements of the application domain that change slowly.</li><ul><li>For example, for a banking system, domain abstractions might include accounts, account holders, and statements.</li></ul><li>Key question: What stable domain abstractions are implemented by a given component?</li><li>Possible component changes required to make it more reusable:</li><ul><li>removing application-specific methods</li><li>changing names to make them more general</li><li>adding methods to provide more complete functional coverage</li><li>making exception handling consistent for all methods</li><li>adding a configuration interface to allow the component to be adapted to different situations of use</li><li>integrating required components to increase independence</li></ul><li>Exception handling is particularly hard.</li><li>Components should not handle exceptions themselves, to make for more general reuse.</li><li>Issues with not handling exceptions within the components:</li><ul><li>Publishing all exceptions creates bloated interfaces that are harder to understand. This may discourage use.</li><li>The operation of the component may depend on local exception handling, and changing this may have serious implications for the functionality of the component.</li></ul><li>Benefits of reusing rather than redeveloping a component are not simply productivity gains, but also quality gains.</li><li>Tradeoff between reusability and usability of component: More general components tend to be more complex.</li><li><span style="font-style: italic; text-decoration: underline;">Component certification</span> implies someone apart from the component developer checking the quality of the component.</li><li>The essential differences between CBSE with reuse and software processes for original software development are</li><ul><li>The user requirements are initially developed in outline rather than in detail, and stakeholders are encouraged to be as flexible as possible in defining their requirements. Requirements that are too specific limit the number of components that could meet these requirements.</li><li>Requirements are refined and modified early in the process depending on the components available.</li><li>Development is mainly concerned with piecing together existing components.</li></ul><li>Initially, search for components that are available locally or from trusted suppliers.</li><li>Key issue: Components are implemented with an original application environment in mind which carries a basically uncheckable number of implicit assumptions that might not be true for another application.</li></ul><div><br/></div><div><span style="font-weight: bold;">Component Composition</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Sequential composition</span>. You create a new component from 2 existing components by calling the existing components in sequence.</li><li><span style="font-style: italic; text-decoration: underline;">Hierarchical composition</span>. Occurs when one component calls directly on services provided by another component.</li><ul><li>The provides interface of the called component must be compatible with the requires interface of the calling component. If there is mismatch here, middleware code must be required to reformat the data.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Additive composition</span>. Occurs when two or more components are put together to create a new component, which combines their functionality. </li><ul><li>The provides interface and the requires interface of the new component is a combination of the corresponding interfaces in components A and B.</li><li>The components are called separately through the external interface of the composed component.</li><li>The underlying components are not dependent and do not call each other.</li></ul><li>Types of interface incompatibilities:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Parameter incompatibility</span>. Parameter types or names are different even though the functions have the same names and functionalities.</li><li><span style="font-style: italic; text-decoration: underline;">Operation incompatibility</span>. The names of the operations in the provides and requires interfaces are different.</li><li><span style="font-style: italic; text-decoration: underline;">Operation incompleteness</span>. The providers’ interface of a component is a subset of the requires interface of another component or vis versa.</li></ul><li><span style="font-style: italic; text-decoration: underline;">An adapter component</span> converts one interface to another.</li></ul><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 7 — Design and Implementation</span></div><hr/><ul><li>Design and implementation are closely linked and you should normally take implementation issues into account when developing a design.</li><li>Two aims of this chapter:</li><ul><li>Show how system modeling and architectural design are put into practice in developing and object-oriented software design</li><li>To introduce issues of software reuse, configuration management, and open source development</li></ul><li>Steps to developing a proper design</li><ul><li>Understand and define the context and external interactions with the system</li><li>Design the system architecture</li><li>Identify the principal objects in the system</li><li>Develop design models</li><li>Specify interfaces</li></ul><li>System context and interactions</li><ul><li>Understanding of the context lets you establish the boundaries of the system</li><li>A system context model is a structural model that demonstrates the other systems in the environment of the system being developed</li><li>An interaction model is a dynamic model that shows how the system interacts with its environment as it is used</li></ul><li>Design models</li><ul><li><span style="font-style: italic; text-decoration: underline;">Structural models</span>, which describe the static structure of the system using object classes and their relationships.</li><li><span style="font-style: italic; text-decoration: underline;">Dynamic models</span>, which describe the dynamic structure of the system and show the interactions between the system objects</li><li>There models particularly useful for early stages of design process</li><ul><li><span style="font-style: italic; text-decoration: underline;">Subsystem models</span>, that show logical groupings of objects into coherent subsystems.</li><li><span style="font-style: italic; text-decoration: underline;">Sequence models</span>, which show the sequence of object interactions. These are dynamic models</li><li><span style="font-style: italic; text-decoration: underline;">State machine model</span>, which show how individual objects change their state in response to events.</li></ul></ul><li>You should not make detailed decisions about the implementation that really should be left to the system programmers.</li><li><span style="font-style: italic; text-decoration: underline;">Interface specification</span>.</li><ul><li>You need to specify interfaces so that objects and subsystems can be designed in parallel.</li></ul><li>Four essential elements of design patterns:</li><ul><li>A name that is a meaningful reference to the pattern</li><li>A description of the problem area that explains when the pattern may be applied</li><li>A solution description of the parts of the design solution, their relationships, and their responsibilities.</li><li>A statement of the consequences of applying the pattern. This helps designers understand trade-offs between different patterns.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Implementation Issues</span></div><ul><li>Some aspects of implementation that are particularly important to software engineering often not covered in programming texts:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Reuse</span>. </li><ul><li>Software reuse is possible on a number of different levels:</li><ul><li><span style="font-style: italic; text-decoration: underline;">The abstraction level</span>. Reuse knowledge of successful abstractions in the design of your software (involves no reuse of actual code)</li><li><span style="font-style: italic; text-decoration: underline;">The object level</span>. At this level, you directly reuse objects from a library rather than writing the code yourself.</li><li><span style="font-style: italic; text-decoration: underline;">The component level</span>. </li><li><span style="font-style: italic; text-decoration: underline;">The system level</span>. At this level, you reuse entire application system.</li></ul><li>Costs associated with reuse:</li><ul><li>The costs of the time spent in looking for software to reuse and assessing whether or not it meets your needs.</li><li>Where applicable, the costs of being the reusable software.</li><li>The cost of adapting and configuring the reusable software components or systems to reflect the requirements of the system that you are developing</li><li>The costs of integrating reusable software elements with each other and with the new code that you have development.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Configuration management</span>. Many different versions of each software component are created.</li><ul><li>Three fundamental configuration management activities:</li><ul><li><span style="text-decoration: underline;">Version management</span>, where support is provided to keep track of the different versions of software components.</li><li><span style="text-decoration: underline;">System integration</span>, where support is provided to help developers define what versions of components are used to create each version of a system. This description is then used to build a system automatically by compiling and linking the required components.</li><li><span style="text-decoration: underline;">Problem tracking</span>, where support is provided to allow users to report bugs and other problems, and to allow users to report bugs and other problems.</li><li>Best known integration tool: UNIX make</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Host-target development</span>. Production software does not usually execute on the same computer as the software development environment.</li><ul><li>Simulators are often used when developing embedded systems.</li></ul></ul><li><span style="font-weight: bold;">Open source development</span></li><ul><li>Mature open source systems are usually very reliable</li><li>For a company involved in software development, there are two open source issues that have to be considered:</li><ul><li>Should the product that is being developed make use of open source components?</li><li>Should an open source approach be use for the software’s development?</li></ul><li>The three general models of open source licenses:</li><ul><li><span style="font-style: italic; text-decoration: underline;">The GNU General Public Lincense (GPL)</span>. If you use open source software that is licensed under the GPL license, then you must make that software open source</li><li><span style="font-style: italic; text-decoration: underline;">The GNU Lesser General Public License (</span><span style="font-style: italic;">LGPL). </span>This is a variant of the GPL license where you can write components that link to open source code without having to publish the source of these components.</li><li><span style="font-style: italic; text-decoration: underline;">The Berkley Standard Distribution (BSD) License</span>. Here, you are not obliged to republish any changes or modifications made to open source code. You can include the code in proprietary systems that are sold. If you use open source components, you must acknowledge the original creator of the code.</li></ul><li>Companies managing projects that se open source should:</li><ul><li>Establish a system for maintaining information about open source components that are downloaded and used.</li><li>Be aware of licensing and version control it</li><li>Be aware of evolution pathways for components. Understand what the goal of the open source project you want to use is.</li><li>Have auditing systems in place so that your organization does not breach licensing agreements.</li><li>Participate in the open source community.</li></ul></ul></ul><div><br/></div></body></html>