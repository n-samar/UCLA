<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:30:22 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:30:40 +0000"/><title>Embedded Software</title></head><body><div/><div><span style="font-weight: bold;">Somerville: Chapter 20 — Embedded Software</span></div><hr/><ul><li>Introducing features of real-time software engineering</li><li>Embedded software is very important economically because almost every electrical device now includes software.</li><li>Aside for time constraints inherent to real-time systems, there are other important differences between embedded systems and other types of software systems:</li><ul><li>Embedded systems generally run continuously and do not terminate.</li><li>Interactions with the systems environment are uncontrollable and unpredictable</li><li>There may be physical limitations that affect the design of a system</li><li>Direct hardware interaction may be necessary</li><li>Issues of safety and reliability may dominate system design</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Embedded systems design</span></div><ul><li>Which system capabilities should be implemented in hardware and which in software?</li><li>Low-level architectural decisions must be considered early in the process</li><li>Usually employe the <span style="font-style: italic; text-decoration: underline;">stimulus-response model</span>, because embedded systems are inherently reactive.</li><li>You can define the behavior of a real-time system by listing the stimuli received by the system, the associated responses, and the time at which the response must be produced.</li><li>Stimuli fall into two classes:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Periodic stimuli</span>. These occur at predictable time intervals. Need not use interrupts, just periodically query state of the I/O device responsible for the stimuli.</li><li><span style="font-style: italic; text-decoration: underline;">Aperiodic stimuli</span>. These occur irregularly and unpredictably. Usually require interrupts to be handled correctly.</li></ul><li>Real-time systems usually implemented through concurrent, cooperating processes</li><li>Activities involved in a real-time software design process:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Platform selection</span>. Choose an execution platform for the system</li><li><span style="font-style: italic; text-decoration: underline;">Stimuli/response identification</span>. This involves identifying the stimuli that the system must process and the associated response or responses for each stimulus.</li><li><span style="font-style: italic; text-decoration: underline;">Timing analysis</span>.For each stimulus and associated response, you identify the timing constraints that apply to both stimulus and response processing. These are used to establish the deadlines for the processes in the system.</li><li><span style="font-style: italic; text-decoration: underline;">Process design</span>. Aggregate the stimulus and response processing into a number of concurrent processes. Then optimize the process architecture to reflect the requirements.</li><li><span style="font-style: italic; text-decoration: underline;">Algorithm design</span>. For each stimulus and response. Need to be developed relatively early in the design process.</li><li><span style="font-style: italic; text-decoration: underline;">Data design</span>. Specify the information that is exchanged by processes and the events that coordinate information exchange, and design data structures to manage this information exchange.</li><li><span style="font-style: italic; text-decoration: underline;">Process scheduling</span>. Design a scheduling system that will ensure that processes are started in time to meet their deadlines.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Real-Time Architectural Patterns</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Observe and React</span>. Used when a set of sensors are routinely monitored and displayed. When the sensors show that some event has occurred, the system reacts by initiating a process to handle the event.</li><li><span style="font-style: italic; text-decoration: underline;">Environmental Control</span>. Includes sensors and actuators that can change the environment. In response to environmental changes detected by the sensor, control signals are sent to the system actuators.</li><li><span style="font-style: italic; text-decoration: underline;">Process Pipeline</span>. Used when data has to be transformed from one representation to another before it can be processed. The transformation is implemented as a sequence of processing steps, which may be carried out concurrently.</li></ul><div><br/></div><div><span style="font-weight: bold;">Timing Analysis</span></div><ul><li>Three factors to consider:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Deadlines</span>. </li><ul><li>In hard real-time systems, not meeting a deadline means system failure</li><li>In soft real-time systems not meeting a deadline means degraded system performance</li></ul><li><span style="font-style: italic; text-decoration: underline;">Frequency</span>.</li><ul><li>The number of times per second that a process must execute so that you are confident that it can always meet its deadline</li></ul><li><span style="font-style: italic; text-decoration: underline;">Execution time</span>. </li><ul><li>Time required to process a stimulus and produce a response.</li><li>Have to take into account average execution time as well as worst-case execution time.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Real-Time Operating Systems (RTOS)</span></div><ul><li>RTOS in comparison with standard operating systems offers:</li><ul><li>fine-grain control over process scheduling</li><li>very low space and execution time overhead</li></ul><li>Most commonly, embedded system applications are built on to of RTOS</li><li><span style="font-style: italic; text-decoration: underline;">Bare-metal</span> approaches are also popular — include no operating system, the application takes care of everything</li><li>RTOS components include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Real-time clock</span></li><li><span style="font-style: italic; text-decoration: underline;">Interrupt-handler</span></li><li><span style="font-style: italic; text-decoration: underline;">Scheduler</span></li><li><span style="font-style: italic; text-decoration: underline;">Resource manager</span></li><li><span style="font-style: italic; text-decoration: underline;">Dispatcher</span></li></ul><li>Processes are handled on two levels:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interrupt level</span>. For high priority, aperiodic tasks</li><li><span style="font-style: italic; text-decoration: underline;">Clock level</span>. For predictable, periodic tasks.</li></ul><li>Two most common scheduling strategies:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Non-pre-emptive scheduling</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Pre-emptive scheduling</span>.</li></ul></ul><div><br/></div></body></html>