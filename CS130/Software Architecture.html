<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:19:00 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:19:38 +0000"/><title>Software Architecture</title></head><body><div/><div><hr/></div><div><span style="font-weight: bold;">Lecture Notes: February 5 — Architecture continued</span></div><hr/><ul><li>E.g. </li><ul><li><span style="font-style: italic; text-decoration: underline;">multitier client-server (so, proxy servers)</span></li><ul><li>Wikipedia does this. First it goes to the Web cache server, that only contains lately access pages in the geographical region. Then that cache server is a client to the web server. Finally, the web server is a client to the database server.</li><li>Problem: Keeping information up to date</li><li>Benefits: Performance + modularity</li></ul><li><span style="font-style: italic; text-decoration: underline;">Distributed components</span></li><ul><li>Take idea of component based software engineering and run that idea in a distributed environment</li><li>CORBA (Common Object Request Brocher Architecture), EJB, .NET</li><li>Idea of gluing components into systems through a well-maintained component library</li><li>Major downside: Once you buy into one of these systems, everything you do in your application must live inside that system. So, difficult to make it scale to entire project</li></ul><li><span style="font-style: italic; text-decoration: underline;">Peer-to-peer approach (all hosts have “equal” power)</span></li><ul><li>Peers exchange information without a central catalog server</li><li>Trying to avoid the client-server bottleneck of central server</li><li>Downsides</li><ul><li>no performance guarantees</li><li>trust and security between peers</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Software as a Service (SaaS)</span></li><ul><li>thin client browsers, with most of the application running on a server usually maintained in a cloud computing environment</li><li>Downsides</li><ul><li>Network connection</li><li>hidden dependencies (hidden to the user). i.e. the server side depends on another server maybe, and all of them have to work</li></ul></ul></ul><li>Distributed Architectures</li><ul><li>Advantages</li><ul><li>high availability if done right (<span style="font-style: italic; text-decoration: underline;">fault tolerance</span>)</li><li>scalability (via concurrency)</li><li>openness (via protocols)</li><li>resource sharing between nodes</li></ul><li>Disadvantages</li><ul><li>complexity</li><li>have to worry about failure management</li><li>have to worry about quality of service issues </li><ul><li>how should we specify quality of service and how good should it be</li></ul><li>security</li><li>transparency</li><ul><li>Do the users know that the distributed architecture is distributed or are we going to pretend that it is node and hide this fact?</li></ul><li>have to specify how to scale</li><ul><li>adding more nodes</li><li>geography — where to physically place your nodes and components?</li><li>how to manage nodes</li></ul><li>how open are our protocols really? (protocol openness enforcement)</li></ul></ul><li>Service Oriented Architecture</li><ul><li>Distributed system in which each component is stand-alone (requestor and provider component with centralized registry that facilitates communication between components)</li><li>Examples: FTP (or HTTP) + DNS (DNS is registry, HTTP does the bind between requestor and the provider) — many server oriented architectures work through HTTP + DNS idea.</li><li>SOA process:</li><ul><li>“planned”</li><li>outline workflow and find out what the application needs to do</li><li>find candidate services that implement the application</li><li>select services</li><li>refine workflow and iterate because selected services do not usually match requirements perfectly</li><li>write code (mostly glue between services)</li><li>test (possibly a big deal due to heterogeneity of system)</li></ul><li>Two major approaches to SOA:</li><ul><li><span style="font-style: italic; text-decoration: underline;">SOA standards</span>.</li><ul><li>SOAP (Simple Object Access Protocol) — the Assembly of SOA</li><ul><li>Idea: Let’s use HTTP to talk between objects (XML + RPC (Remote Procedure Call) + HTTP(S))</li><li>XML to envelope, encode data, and perform the Remote Procedure Call</li></ul><li>WSDL (Web Services Definition Language) — the C of SOA</li><ul><li>XML notation for describing services</li><li>allows provider to publish to the registry the set of services it provides</li><li>message includes ports, interfaces, operations, messages…</li></ul><li>WS-BPEL (Business Process Execution Language)</li><ul><li>XML</li><li>idea is to specify an orchestration language — a language for combining together all the different distributed components</li><li>not really used, too high level</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">RESTful approach</span>. (Representational State Transfer)</li><ul><li>“agile”</li><li>most popular in smaller companies</li><li>idea is SOA standards are too much design and overhead of thought</li><li>client-server approach</li><li><span style="font-weight: bold;">no client state is stored on the server</span> (so, fat client because client needs to keep track of its state)</li><ul><li>Messages describe themselves and do not appeal to context</li></ul><li>responses from server must specify wether they are cacheable</li><li>server may be layered atop other servers, in that case, the client shouldn’t care (i.e., abstract away the issue, not transparent)</li><li>(optional) clients can run code supplied by the server usually written in Javascript.</li></ul></ul></ul></ul><div><br/></div><div><br/></div><div>Interlude: (McConnell Chapter 4)</div><ul><li>Language Conventions </li><ul><li>You can’t give up all conventions to those implemented by the Compiler, let the programmers establish conventions that are useful to them</li></ul><li>Tools</li><ul><li>version control, framework</li><li>often primitive in early-stage tech</li><li>i.e. if you have great development tools, there’s a big chance that you are in an oversaturated field</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Component Design</span></div><ul><li>A <span style="font-style: italic;">wicked problem</span><span style="text-decoration: underline;">: definable only be solving it</span></li><li>designs evolve; early designs are sloppy and that’s ok</li><li>design is a heuristic process; no single solution and involves trial and error</li><li>design must deal with competing priorities </li><li><span style="font-style: italic;">Key challenge</span>: <span style="font-weight: bold;">Managing complexity (i.e. keep things as simple as possible, and figure out how to manage inherent, unavoidable complexity)</span></li><li>History of software design</li><ul><li>1950s — writing modular programs is a big deal</li><li>1960s — top-down design; structured programming</li><li>early 1970s — data flow design; data structure design</li><li>late 1970s — Object-Oriented design: data is associated with methods</li><li>1990s — Design Patterns; software architecture</li><li>2000s — Aspect-oriented design (different aspects should be designed as independently as possible); Model Driven Development; Test Driven Development; </li><li>2010s — SOA; serverless architectures</li></ul><li>We will continue to see new design methods and notice overall patterns that they use</li><li>If many modules share a concern, you want to redo your development process so that this concern can be centrally addressed by a single module</li><ul><li>e.g., garbage collector — a single module that worries about freeing memory so that nobody else has to</li><li>e.g., message translation (internationalization)</li></ul><li>More generally, this follows the idea of <span style="font-weight: bold;">separation of concerns</span></li><li>Important design concepts</li><ul><li>Aspects</li><li>Modularity</li><li>Separation of concerns</li><li>Information hiding</li><li>Functional independence — with modularity you are focusing on development, but with functional independence you worry about runtime behavior</li><ul><li>High cohesion, low coupling</li></ul><li>Abstraction vs. refinement/elaboration</li><ul><li>Need to be able to take an abstract design and make it more concrete the next level down</li></ul><li>Design Patterns</li><li>Refactoring</li><ul><li>Occurs when you mess-up your design (which is to be expected)</li></ul></ul><li>Design Patterns</li><ul><li>Single most important design revolution in last 20 years</li><li>Influential in Object-Oriented design world</li><li>Popularized by the Gang of Four book in 1995 — idea is collect together design strategies of object-oriented approach into patterns</li><li>Design Pattern is a high-level relationship among</li><ul><li>context</li><li>problem</li><li>solution</li><li>+ <span style="text-decoration: underline;">design forces</span> (i.e. why use this pattern as opposed to others)</li></ul><li>Example: Factory code</li><ul><li><span style="font-style: italic; text-decoration: underline;">Context</span>: you have lots of related classes that need to create objects, but the objects that they create are not necessarily of type of the classes that create them</li><li><span style="font-style: italic; text-decoration: underline;">Problem</span>: we want a standard framework that lets subclasses figure out their own implementation</li><li><span style="font-style: italic; text-decoration: underline;">Solution</span>: static method of type C (the parent class) that returns C (but the actual object that it returns can of course be a subtype of C)</li><li><span style="font-style: italic; text-decoration: underline;">Design forces</span>: </li><ul><li>relatively simple idea; </li><li>often evolves to other patterns, like Prototype, AbstractFactory, Builder, …;</li><li>if you want the same instance multiple times;</li><li>uses creation via inheritance; so, not a good choice for creation by delegation (prototype patter would be a better approach)</li></ul></ul><li>Categories of design patterns:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Creational</span>.</li><ul><li>Patterns that facilitate object creation (i.e. what alternatives do we have to using the keyword <span style="font-style: italic;">new</span>)</li></ul><li><span style="font-style: italic; text-decoration: underline;">Structural</span>. </li><ul><li>These patterns focus on integrating collections of existing objects (pipes and filters, for example)</li></ul><li><span style="font-style: italic; text-decoration: underline;">Behavioral</span>.</li><ul><li>Focuses on communication and responsibility (for example, visitor, event listener, interpreter)</li></ul></ul><li>Skeptical take on design patterns: They might not work well on non object-oriented approaches.</li></ul></ul><div><br/></div></body></html>