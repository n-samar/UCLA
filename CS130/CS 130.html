<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-01-19 00:58:15 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:32:18 +0000"/><title>CS 130</title></head><body><div><hr/><div><span style="font-weight: bold;">Lecture Notes: February 7 — Quality Assurance &amp; Configuration Management</span></div><hr/><div><span style="font-weight: bold;">Class Design</span></div><div><ul><li>Class is a collection of data and code</li><li>Want it to be cohesive</li><li>Can be looked at in isolation</li><li>Can be implemented in any language. Approaches:</li><ul><li><span style="font-style: italic; text-decoration: underline;">(int) handles</span>. As in int fd = open(…); which is an object-oriented view of files; open here is a constructor</li><li><span style="font-style: italic; text-decoration: underline;">an opaque type</span>. FILE *f = fopen(“…”, …); which is a pointer to an object-oriented object, with an obfuscated underlying structure that cannot be accessed (type of f here would be struct __FILE FILE).</li><li><span style="font-style: italic; text-decoration: underline;">implicit instances</span>. As in setlocale(LC_ALL, “en_US.UTF-8”); the locale here is somewhere in the system, but we cannot directly access it; it is fully maintained by the system; this is usually not a good idea, due to global effects.</li></ul><li>Question: Should I create a new class to do a thing; should i incorporate it into another class; should I split these classes into two; So, when to create a class?</li><ul><li><span style="font-style: italic; text-decoration: underline;">Complexity reduction</span>. If adding a class makes the program less complicated, add it.</li><li><span style="font-style: italic; text-decoration: underline;">Real-world object modeling</span>. Classes might not work that well for abstract objects vs. physical.</li><li><span style="font-style: italic; text-decoration: underline;">To package related operations</span>. Package a class about trigonometric operations.</li><li><span style="font-style: italic; text-decoration: underline;">To avoid excessive parameter passing</span>. If making a class reduces parameter passing, that’s great!</li></ul><li>When not to create a class?</li><ul><li><span style="font-style: italic; text-decoration: underline;">If your class name is a verb</span>. Class should focus on objects, not on actions.</li><li><span style="font-style: italic; text-decoration: underline;">If your class has no methods</span>.</li><li><span style="font-style: italic; text-decoration: underline;">If your class does everything</span>.</li></ul><li>Design principles for class-level design:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Leskov Substitution Principle</span>: If you have a class and you are using an instance of it, you should not care if the object is of the actual class type or of a derived class type.</li><li><span style="font-style: italic; text-decoration: underline;">Interface Segregation Principle</span>. You shouldn’t have a lot of direct children. Instead of a base class having 10 children, increase the number of abstraction levels (that is the depth of the tree) and decrease the number of children per parent.</li><li><span style="font-style: italic; text-decoration: underline;">Dependency Inversion Principle</span>. </li><ul><li>Only depend on class interfaces, not on implementation.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Open-Closed Principle</span>. </li><ul><li>Prefer subclassing to modifying the base class.</li><li>“Classes should be open to extension and closed to modification”</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Package Design Principles</span></div><div><ul><li>Packages serve a different purpose than classes</li><li>Packaging is about how software is <span style="font-style: italic; text-decoration: underline;">maintained and delivered</span>, classes are about how the program behaves at run-time.</li><li><span style="font-style: italic; text-decoration: underline;">Common Reuse Principle (CRP)</span>. Package together classes only if they are commonly used together.</li><li><span style="font-style: italic; text-decoration: underline;">Release Reuse Equivalency Principle</span>. Release packages, not classes. Maintainers and operations staff know the language of packages, and not of classes.</li><li><span style="font-style: italic; text-decoration: underline;">Common Closure Principle</span>. If changing one class typically involves changing the other, they should be packaged together.</li><li><span style="font-style: italic; text-decoration: underline;">Law of Demeter</span>. Avoid indirect connections from one class to another. Have on class depend on another class without that being a salient thing is bad. The idea is that this induces implicit dependencies.</li><ul><li>Object A can call its own methods</li><li>If Object A creates another object B, it can call B’s methods</li><li>However, Object A should avoid calling methods on objects provided by B.</li></ul></ul><div><br/></div></div></div><div>TODO: insert table of defect-detection rates here</div><div><br/></div><div><span style="font-weight: bold;">Quality Management</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Change Management</span></li><li><span style="font-style: italic; text-decoration: underline;">Configuration Management</span></li><li><span style="font-style: italic; text-decoration: underline;">Software Quality:</span></li><ul><li>What is it?</li><li>How can you improve?</li><li>How effective are the methods for improving it?</li><li>When should you improve on quality? </li><li>How much does the improvement cost?</li></ul><li><span style="font-style: italic; text-decoration: underline;">The Meyer’s Dilemma</span></li><ul><li>Ship fast, terrible quality, users hate it, you lose</li><li>Ship late, high quality, users already using something else, you lose</li><li>You want to be goldilocks</li></ul><li>What is quality?</li><ul><li>Etymology: from latin work qua which means what… So we don’t know what quality is</li><li>Basic idea is we are looking for attributes of quality</li><li>These attributes should be <span style="text-decoration: underline;">desirable</span><span style="font-style: italic;"> </span>and <span style="text-decoration: underline;">measurable</span></li></ul><li><span style="text-decoration: underline; font-style: italic;">Quality Control (QC)</span>. </li><ul><li>Measure that the product corresponds to the required quality attributes</li><li>If the quality of the product is too high with regards to the spec (i.e. it is higher that the required quality), figure out how to reduce quality and increase other attributes such as mean delivery time</li></ul><li><span style="text-decoration: underline; font-style: italic;">Correctness</span>. Means: does the product match the spec?</li><li><span style="text-decoration: underline; font-style: italic;">Reliability</span>. Means: What is our mean-time-to-failure?</li><li><span style="text-decoration: underline; font-style: italic;">Robustness</span>. Means: How does the system respond to odd conditions?</li><li><span style="text-decoration: underline; font-style: italic;">Integrity</span>. Means: How does the system resist tampering and screw ups?</li><li><span style="text-decoration: underline; font-style: italic;">Functionality</span>. Means: Does it provide the functions the users desire?</li><li><span style="text-decoration: underline; font-style: italic;">Efficiency</span>. Means: Low resource use</li><li><span style="text-decoration: underline; font-style: italic;">Usability</span>. Means: Is the software easy to learn and use?</li><li><span style="text-decoration: underline; font-style: italic;">Flexibility</span>. Means: Is it easy to modify?</li><li><span style="text-decoration: underline; font-style: italic;">Adaptability</span>. Means: Is this system useful in other domains?</li><li><span style="text-decoration: underline; font-style: italic;">Reusability</span>. </li><li><span style="text-decoration: underline; font-style: italic;">Testability</span>. </li><li><span style="text-decoration: underline; font-style: italic;">Maintainability</span>. Means: Easy to fix?</li><li><span style="text-decoration: underline; font-style: italic;">Portability</span>. Means: Is it easy to move the software to another platform?</li><li><span style="text-decoration: underline; font-style: italic;">Readability</span>. Small scale</li><li><span style="text-decoration: underline; font-style: italic;">Understandability</span>. Large scale, more abstract to readability. Can you see the large structure of the program?</li><li><span style="text-decoration: underline; font-style: italic;">User-visible attributes</span>. (External characteristics)</li><li><span style="text-decoration: underline; font-style: italic;">User-invisible attributes</span>. (Internal characteristics)</li><li>More attributes:</li><ul><li>Safety (software will not do anything dangerous), security, resilience (this system will keep working even if parts break down)</li></ul><li>Plan-driven QA:</li><ul><li>it’s somebody’s job, reports directly to upper management</li><li>If there is nobody that has a job to assure quality, there will be no quality</li><li>this person </li><ul><li>plans, </li><li>reviews software process, </li><li>review deviations from the software process as they occur,</li><li>audits software work products</li><li>documenting deviations</li></ul></ul><li>Agile:</li><ul><li>Quality is everybody’s responsibility (e.g. pair programming)</li><li>Keep code public (within the development team and project) — open source is a good idea because it facilitates this idea</li><li>Use good code as an example</li></ul></ul></div><hr/><div><span style="font-weight: bold;">Lecture Notes: February 5 — Architecture continued</span></div><hr/><ul><li>E.g. </li><ul><li><span style="font-style: italic; text-decoration: underline;">multitier client-server (so, proxy servers)</span></li><ul><li>Wikipedia does this. First it goes to the Web cache server, that only contains lately access pages in the geographical region. Then that cache server is a client to the web server. Finally, the web server is a client to the database server.</li><li>Problem: Keeping information up to date</li><li>Benefits: Performance + modularity</li></ul><li><span style="font-style: italic; text-decoration: underline;">Distributed components</span></li><ul><li>Take idea of component based software engineering and run that idea in a distributed environment</li><li>CORBA (Common Object Request Brocher Architecture), EJB, .NET</li><li>Idea of gluing components into systems through a well-maintained component library</li><li>Major downside: Once you buy into one of these systems, everything you do in your application must live inside that system. So, difficult to make it scale to entire project</li></ul><li><span style="font-style: italic; text-decoration: underline;">Peer-to-peer approach (all hosts have “equal” power)</span></li><ul><li>Peers exchange information without a central catalog server</li><li>Trying to avoid the client-server bottleneck of central server</li><li>Downsides</li><ul><li>no performance guarantees</li><li>trust and security between peers</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Software as a Service (SaaS)</span></li><ul><li>thin client browsers, with most of the application running on a server usually maintained in a cloud computing environment</li><li>Downsides</li><ul><li>Network connection</li><li>hidden dependencies (hidden to the user). i.e. the server side depends on another server maybe, and all of them have to work</li></ul></ul></ul><li>Distributed Architectures</li><ul><li>Advantages</li><ul><li>high availability if done right (<span style="font-style: italic; text-decoration: underline;">fault tolerance</span>)</li><li>scalability (via concurrency)</li><li>openness (via protocols)</li><li>resource sharing between nodes</li></ul><li>Disadvantages</li><ul><li>complexity</li><li>have to worry about failure management</li><li>have to worry about quality of service issues </li><ul><li>how should we specify quality of service and how good should it be</li></ul><li>security</li><li>transparency</li><ul><li>Do the users know that the distributed architecture is distributed or are we going to pretend that it is node and hide this fact?</li></ul><li>have to specify how to scale</li><ul><li>adding more nodes</li><li>geography — where to physically place your nodes and components?</li><li>how to manage nodes</li></ul><li>how open are our protocols really? (protocol openness enforcement)</li></ul></ul><li>Service Oriented Architecture</li><ul><li>Distributed system in which each component is stand-alone (requestor and provider component with centralized registry that facilitates communication between components)</li><li>Examples: FTP (or HTTP) + DNS (DNS is registry, HTTP does the bind between requestor and the provider) — many server oriented architectures work through HTTP + DNS idea.</li><li>SOA process:</li><ul><li>“planned”</li><li>outline workflow and find out what the application needs to do</li><li>find candidate services that implement the application</li><li>select services</li><li>refine workflow and iterate because selected services do not usually match requirements perfectly</li><li>write code (mostly glue between services)</li><li>test (possibly a big deal due to heterogeneity of system)</li></ul><li>Two major approaches to SOA:</li><ul><li><span style="font-style: italic; text-decoration: underline;">SOA standards</span>.</li><ul><li>SOAP (Simple Object Access Protocol) — the Assembly of SOA</li><ul><li>Idea: Let’s use HTTP to talk between objects (XML + RPC (Remote Procedure Call) + HTTP(S))</li><li>XML to envelope, encode data, and perform the Remote Procedure Call</li></ul><li>WSDL (Web Services Definition Language) — the C of SOA</li><ul><li>XML notation for describing services</li><li>allows provider to publish to the registry the set of services it provides</li><li>message includes ports, interfaces, operations, messages…</li></ul><li>WS-BPEL (Business Process Execution Language)</li><ul><li>XML</li><li>idea is to specify an orchestration language — a language for combining together all the different distributed components</li><li>not really used, too high level</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">RESTful approach</span>. (Representational State Transfer)</li><ul><li>“agile”</li><li>most popular in smaller companies</li><li>idea is SOA standards are too much design and overhead of thought</li><li>client-server approach</li><li><span style="font-weight: bold;">no client state is stored on the server</span> (so, fat client because client needs to keep track of its state)</li><ul><li>Messages describe themselves and do not appeal to context</li></ul><li>responses from server must specify wether they are cacheable</li><li>server may be layered atop other servers, in that case, the client shouldn’t care (i.e., abstract away the issue, not transparent)</li><li>(optional) clients can run code supplied by the server usually written in Javascript.</li></ul></ul></ul></ul><div><br/></div><div><br/></div><div><div>Interlude: (McConnell Chapter 4)</div><ul><li>Language Conventions </li><ul><li>You can’t give up all conventions to those implemented by the Compiler, let the programmers establish conventions that are useful to them</li></ul><li>Tools</li><ul><li>version control, framework</li><li>often primitive in early-stage tech</li><li>i.e. if you have great development tools, there’s a big chance that you are in an oversaturated field</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Component Design</span></div><div><ul><li>A <span style="font-style: italic;">wicked problem</span><span style="text-decoration: underline;">: definable only be solving it</span></li><li>designs evolve; early designs are sloppy and that’s ok</li><li>design is a heuristic process; no single solution and involves trial and error</li><li>design must deal with competing priorities </li><li><span style="font-style: italic;">Key challenge</span>: <span style="font-weight: bold;">Managing complexity (i.e. keep things as simple as possible, and figure out how to manage inherent, unavoidable complexity)</span></li><li>History of software design</li><ul><li>1950s — writing modular programs is a big deal</li><li>1960s — top-down design; structured programming</li><li>early 1970s — data flow design; data structure design</li><li>late 1970s — Object-Oriented design: data is associated with methods</li><li>1990s — Design Patterns; software architecture</li><li>2000s — Aspect-oriented design (different aspects should be designed as independently as possible); Model Driven Development; Test Driven Development; </li><li>2010s — SOA; serverless architectures</li></ul><li>We will continue to see new design methods and notice overall patterns that they use</li><li>If many modules share a concern, you want to redo your development process so that this concern can be centrally addressed by a single module</li><ul><li>e.g., garbage collector — a single module that worries about freeing memory so that nobody else has to</li><li>e.g., message translation (internationalization)</li></ul><li>More generally, this follows the idea of <span style="font-weight: bold;">separation of concerns</span></li><li>Important design concepts</li><ul><li>Aspects</li><li>Modularity</li><li>Separation of concerns</li><li>Information hiding</li><li>Functional independence — with modularity you are focusing on development, but with functional independence you worry about runtime behavior</li><ul><li>High cohesion, low coupling</li></ul><li>Abstraction vs. refinement/elaboration</li><ul><li>Need to be able to take an abstract design and make it more concrete the next level down</li></ul><li>Design Patterns</li><li>Refactoring</li><ul><li>Occurs when you mess-up your design (which is to be expected)</li></ul></ul><li>Design Patterns</li><ul><li>Single most important design revolution in last 20 years</li><li>Influential in Object-Oriented design world</li><li>Popularized by the Gang of Four book in 1995 — idea is collect together design strategies of object-oriented approach into patterns</li><li>Design Pattern is a high-level relationship among</li><ul><li>context</li><li>problem</li><li>solution</li><li>+ <span style="text-decoration: underline;">design forces</span> (i.e. why use this pattern as opposed to others)</li></ul><li>Example: Factory code</li><ul><li><span style="font-style: italic; text-decoration: underline;">Context</span>: you have lots of related classes that need to create objects, but the objects that they create are not necessarily of type of the classes that create them</li><li><span style="font-style: italic; text-decoration: underline;">Problem</span>: we want a standard framework that lets subclasses figure out their own implementation</li><li><span style="font-style: italic; text-decoration: underline;">Solution</span>: static method of type C (the parent class) that returns C (but the actual object that it returns can of course be a subtype of C)</li><li><span style="font-style: italic; text-decoration: underline;">Design forces</span>: </li><ul><li>relatively simple idea; </li><li>often evolves to other patterns, like Prototype, AbstractFactory, Builder, …;</li><li>if you want the same instance multiple times;</li><li>uses creation via inheritance; so, not a good choice for creation by delegation (prototype patter would be a better approach)</li></ul></ul><li>Categories of design patterns:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Creational</span>.</li><ul><li>Patterns that facilitate object creation (i.e. what alternatives do we have to using the keyword <span style="font-style: italic;">new</span>)</li></ul><li><span style="font-style: italic; text-decoration: underline;">Structural</span>. </li><ul><li>These patterns focus on integrating collections of existing objects (pipes and filters, for example)</li></ul><li><span style="font-style: italic; text-decoration: underline;">Behavioral</span>.</li><ul><li>Focuses on communication and responsibility (for example, visitor, event listener, interpreter)</li></ul></ul><li>Skeptical take on design patterns: They might not work well on non object-oriented approaches.</li></ul></ul></div><hr/><div><span style="font-weight: bold;">Lecture Notes: January 31 — Modeling the Problem</span></div><hr/><div><ul><li>use cases</li><li>The reason for writing use cases is to understand the possible problems that might arise given a use case:</li><ul><li><span style="text-decoration: underline;">performance problems</span>: what to do if performance is low?</li><li><span style="text-decoration: underline;">input validation</span>: how much input validation do we need?</li><li><span style="text-decoration: underline;">bad actor</span>: what is customer doesn’t act as intended?</li><ul><li>due to lack of understanding</li><li>due to trying to subvert the system</li></ul></ul><li><span style="text-decoration: underline;">primary scenario</span>: normal case</li><li><span style="text-decoration: underline;">secondary scenario</span> (the real reason we write use cases): </li><ul><li>errors</li><li>alternatives</li></ul><li>How to analyze use cases and problems?</li><ul><li>many modeling techniques (UML supported):</li><ul><li><span style="font-style: italic; text-decoration: underline;">sequence diagram</span> (behavioral model)</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Model-driven architecture (MDA)</span></li><li><span style="font-style: italic; text-decoration: underline;">Model-driven engineering (MDE)</span></li><li><span style="font-style: italic; text-decoration: underline;">Architecture design</span></li><ul><li>Describes how components connect, not what they actually do</li><li>Why architectural design?</li><ul><li>Help design system</li><li>Document decisions</li><li>large scale reuse</li><li>system analysis</li><li>stakeholder communication</li><li>Provides conceptual integrity</li><li>Partitions work</li></ul><li>What we want of architectural design?</li><ul><li>program organization</li><li>data</li><li>business rules</li><li>resource management</li><li>security</li><li>performance and scalability</li><li>interoperability</li><li>internationalization</li><li>error processing</li><li>Somerville adds persistence, access control, concurrency</li></ul></ul><li>Architectural Patterns:</li><ul><li>Repository architecture</li><li>Pipe and filter</li><li>Call-and-return architecture</li><li>Message-passing architecture</li><li>Layered architecture</li><li>Event-driven architecture</li><li>Master-slave architecture</li><li>Fat client vs. thin client architecture</li></ul></ul><div><hr/></div></div><div><span style="font-weight: bold;">Lecture Notes: January 29 — Software processes</span></div><hr/><div><span style="font-weight: bold;">Extreme Programming (the dynamic perspective)</span></div><div><ul><li>Phase 1 — planning: set of <span style="font-style: italic; text-decoration: underline;">stories</span></li><ul><li>decide to do either the <span style="font-style: italic;">highest value</span> or<span style="font-style: italic;"> highest risk</span> task</li></ul><li>Phase 2 — design: </li><ul><li><span style="font-style: italic; text-decoration: underline;">CRC cards</span> (Class Responsibility Collaborate)</li><ul><li>One card per class</li><li>With listed responsibility and all other classes our card is suppose to talk to in order to fulfill the responsibility</li></ul><li><span style="font-style: italic; text-decoration: underline;">Spike solutions</span>: </li><ul><li>Prototypes that address risk</li></ul></ul><li>Phase 3 — coding:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Code refactoring</span></li><li><span style="font-style: italic; text-decoration: underline;">Tinder boxes</span>: all modules come along with a comprehensive set of test cases (each commit must result in working code)</li><ul><li>test before code</li></ul><li><span style="font-style: italic; text-decoration: underline;">Pair programming</span>: </li><ul><li>one person has the keyboard and is thinking <span style="font-style: italic;">tactically</span></li><li>other person stands around and thinks <span style="font-style: italic;">strategically </span></li><li>code tends to be more reliable</li><li>good way to propagate information around developers (educational benefit due to communication of expertise)</li><li>people encourage each other to work hard</li><li>Downside: two people instead of one to pay</li></ul></ul><li>Phase 4 — testing:</li><ul><li>Does not include all types of testing</li><li>Just <span style="font-style: italic;">acceptance testing </span>with customer</li></ul><li>Repeat (2-3 week structures) + keep track (management):</li><ul><li><span style="font-style: italic; text-decoration: underline;">project velocity</span>: how many stories per week?</li></ul></ul><div><span style="font-weight: bold;">Extreme Programming (the practice perspective)</span></div></div><div><ul><li>XP values:</li><ul><li><span style="font-style: italic; text-decoration: underline;">communication</span>: </li><ul><li>verbal, informal</li></ul><li><span style="font-style: italic; text-decoration: underline;">simplicity</span>:</li><ul><li>Don’t worry about coming up with a general solution, just solve the specific problem</li><li>code for today and don’t over engineer</li></ul><li><span style="font-style: italic; text-decoration: underline;">discipline</span>:</li><ul><li>discipline to keep things simple when customer wants to make things more complicated</li><li>don’t let the scope expand</li></ul><li><span style="font-style: italic; text-decoration: underline;">feedback</span>:</li><ul><li>comes from customer</li></ul><li><span style="font-style: italic; text-decoration: underline;">respect</span>:</li><ul><li>everybody is in charge</li><li>everybody respects each others concerns</li></ul></ul></ul><div><span style="font-weight: bold;">Downsides of XP</span></div><div><ul><li>No formal design </li><ul><li>CRC cards are vague compared to good designs</li><li>implies that XP is not good for big stuff</li></ul><li>No formal requirements</li><ul><li>implies that it is harder to catch requirement bugs</li><li>cannot ask for reviews since there is no requirements document</li></ul><li>Volatile requirements</li><ul><li>requirements can constantly change a lot</li><li>causes a lot of potential wasted work</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Industrial XP (XP at scale)</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">readiness assessment</span> of</li><ul><li>environment people will be working in</li><li>team of developers</li><li>organization</li><li>culture</li><li>used to establish if the situation is right for doing a given project successfully</li></ul><li><span style="font-style: italic; text-decoration: underline;">community</span> </li><ul><li>all stakeholders (legal, sales, …) so that you know who to contact when a change is proposed</li></ul><li><span style="font-style: italic; text-decoration: underline;">project chartering</span></li><ul><li>will we take on this project and if so, what are its bounds?</li><li>maybe the project shouldn’t/cannot be done</li></ul><li><span style="font-style: italic; text-decoration: underline;">test driven management</span></li><ul><li>managers should specify which tests will establish quality of developers’ development process</li><li>measurable destinations</li></ul><li><span style="font-style: italic; text-decoration: underline;">retrospectives</span></li><ul><li>A technical review with a goal of improving next time</li></ul><li><span style="font-style: italic; text-decoration: underline;">continuous learning</span></li></ul><div><br/></div></div><div><span style="font-weight: bold;">Downsides of agile in general</span></div><div><ul><li>It’s too tempting to skip refactoring</li><li>Prioritization is taken for granted</li><li>Some developers are not that good at collaborating</li><li>Some customers aren’t that good at collaborating</li><li>Test driven development cannot test everything (especially for user interfaces)</li></ul><div><br/></div></div><div><span style="font-weight: bold;">System Engineering</span></div><div><ul><li>Software engineering + “everything else”</li><ul><li>hardware</li><li>database/data</li><li>people</li><li>documentation</li><li>procedures</li></ul><li>Systems engineering demands to be thought of at multiple levels of abstraction</li><ul><li>e.g. business process engineering abstraction layers:</li><ul><li>Enterprise strategy (worry of CEO)</li><li>Business area design</li><li>Business system design</li><li>Construction and integration</li></ul></ul><li>Stages in system engineering:</li><ul><li>Phase 1— <span style="font-style: italic; text-decoration: underline;">Conceptual design</span> —&gt; System vision document</li><li>Phase 2 — <span style="font-style: italic; text-decoration: underline;">Procurement</span> (buying all the stuff required for the system)</li><ul><li>regulations</li><li>competition</li><li>budget</li><li>buy vs. build</li></ul><li>Phase 3 — <span style="font-style: italic; text-decoration: underline;">Development</span>:</li><ul><li>waterfall model is popular in system engineering</li></ul><li>Phase 4 — <span style="font-style: italic; text-decoration: underline;">Operation</span>:</li><ul><li>being prepared for things going wrong</li><li>flexibility, adaptability</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Hayley-Pirbhai modeling</span> </li><ul><li>simple, scalable system models</li><li>user interface</li><li>input interface</li><li>output interface</li><li>processing interface</li><li>maintenence interface</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">System modeling</span></div><div><ul><li>Analysis products must be <span style="font-style: italic;">maintainable</span></li><ul><li>If you come up with a nice diagram, it should be in a form in which it can be changed.</li></ul><li>Specs must be decomposable</li><ul><li>You can take your system model and break it into peaces so that you can focus on subsystems without a need to think about the entire system</li><li>Graphics are preferred</li></ul><li>Focus and what is to be done, and not how it is to be done</li><li>System models should elaborate on:</li><ul><li><span style="font-style: italic; text-decoration: underline;">assumptions</span> (what are my assumptions?)</li><li><span style="font-style: italic; text-decoration: underline;">simplifications</span> (cannot precisely describe entire system, so need simplification)</li><li><span style="font-style: italic; text-decoration: underline;">limitations</span> (what are the intentional limits of the system?)</li><li><span style="font-style: italic; text-decoration: underline;">constraints</span> (constraints imposed on developers by customer, e.g., must run on Windows 7)</li><li><span style="font-style: italic; text-decoration: underline;">preferences</span> (prefer Oracle, but not necessary)</li><li>For any of these, simulations can help</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Data modeling</span></div><div><ul><li>concepts</li><ul><li><span style="font-style: italic; text-decoration: underline;">data object</span>: e.g., a row in a table</li><li><span style="font-style: italic; text-decoration: underline;">attribute</span>: property of data object (column in a table)</li><li><span style="font-style: italic; text-decoration: underline;">relation</span>: e.g., a table</li><li><span style="font-style: italic; text-decoration: underline;">cardinality</span>: says whether a relation is 1-1, 1-many, …</li><li><span style="font-style: italic; text-decoration: underline;">modality</span>: says whether a relation is required for an object (e.g., every child must have a parent)</li></ul><li><span style="font-style: italic; text-decoration: underline;">schema</span> for a database:</li><ul><li>a design that specifies all of the above</li></ul><li><span style="font-style: italic; text-decoration: underline;">data flow modeling</span></li><ul><li>model the computation of the system as a flow of data from sources to sinks</li><li>To analyze your program:</li><ul><li>design what each of the bubble in the flow chart do</li><li>expand bubble to a level N+1 diagram for more detail</li><li>repeat or say I’m so low level that I can write code now</li></ul></ul></ul><div><span style="font-weight: bold;">Use case modeling</span></div><div><ul><li>Intended for early stages of design as well as later stages</li><li>derived from theater (like a scenario in a play)</li><li><span style="font-style: italic; text-decoration: underline;">actors</span>: people or devices playing a role</li><li><span style="font-style: italic; text-decoration: underline;">scenarios</span>: use cases or scripts</li><ul><li><span style="font-style: italic;">motivation</span>: why are the actors doing what they are doing</li><li><span style="font-style: italic;">setting (aka preconditions)</span>: things that are true right before use case starts</li><li><span style="font-style: italic;">triggers</span>: the change that made the use case happen</li><li><span style="font-style: italic;">tasks</span>: what does each actor do? (variations and exceptions to usual path)</li><li><span style="font-style: italic;">information flow</span>: how does information flow between actors?</li><li><br/></li></ul></ul></div></div><div><span style="font-weight: bold;">Software modeling</span></div><div><ul><li><br/></li></ul></div></div><hr/><div><span style="font-size: 13px; font-weight: bold;">Lecture Notes: January 24 — Software processes</span></div><hr/><ul><li>How do people interact to write programs?</li><li>Software construction issues</li><li>Construction vs. Engineering</li><ul><li>Construction workers vs. Architects/Civil engineers</li><li><span style="font-style: italic;">Issue of scale</span>: For small stuff you don’t need engineering, but for big projects you must have detailed planning (engineering)</li><ul><li>Number of lines of code</li><li>Number of people developing</li><li>Expected lifetime of the program</li><li>Number and type of regulations</li></ul><li>Coding and debugging is central to software development in the same way that hammering and cutting are to the construction of a building</li><li><span style="font-style: italic;">Issue of type of project</span></li></ul><li>Metaphors for software engineering</li><ul><li>Fred Brooks: <span style="font-style: italic;">Plan to throw your software away because you will anyhow.</span> </li><ul><li>Most software projects fail</li></ul><li><span style="font-style: italic;">Think of software as encyclopedia development.</span></li></ul><li>Plan-driven processes</li><ul><li>Prescriptive</li><li>Emphasize order (everybody knows what’s happening)</li><li>Emphasize consistency</li><li>Minimize communication with other developers</li></ul><li><span style="font-style: italic;">Waterfall model. </span>Finish one task to start the other:</li><ul><li>Requirements and modeling of problem and solution</li><li>Architecture and design</li><li>Low-level component design</li><li>Coding</li><li>Now you have to</li></ul></ul><hr/><div><span style="font-size: 13px; font-weight: bold;">Lecture Notes: January 22 — Requirements Engineering</span></div><hr/><div><div><span style="font-weight: bold;">Big Picture</span></div><ul><li>Software processes (what technologies, methods, procedures do we use to develop software)</li><ul><li>A framework for defining activities. Activities are programs that run in developers’ head</li><li><span style="font-style: italic;">Dynamic perspective (framework) activities</span></li><ul><li>Fits into a timeline</li><li>Includes:</li><ul><li><span style="font-style: italic;">Communication</span> (requirements gathering)</li><li><span style="font-style: italic;">Planning</span></li><li><span style="font-style: italic;">Modeling</span></li><li><span style="font-style: italic;">Construction</span></li><li><span style="font-style: italic;">Deployment</span></li></ul></ul><li><span style="font-style: italic;">Practice perspective (umbrella) activities</span></li><ul><li>Always running, has to be done all the time</li><li>Includes: </li><ul><li><span style="font-style: italic;">risk management</span> (trying to keep track of what can go wrong and what to do if it does)</li><li><span style="font-style: italic;">QA (Quality Assurance)</span> — has to be a constant part of development</li><li><span style="font-style: italic;">CM (Configuration Management)</span></li><li><span style="font-style: italic;">Reusability</span></li></ul></ul></ul><li>In sufficiently large projects, you will need to do a cross of all the possible dynamic and practice perspectives (<span style="font-style: italic;">i.e.</span> should I do <span style="font-style: italic;">QA for my deployment, CM for my communication, Reusability for my planning, …?</span>)</li><li>Along with doing the cross of practice and dynamic perspective, we also need to focus on how each cross should be processed (<span style="font-style: italic;">agile vs. devops …)</span></li><li><span style="text-decoration: underline;">Requirements Engineering</span> is an important subset of software processes</li><li><span style="text-decoration: underline;">Software Construction</span> is another important subset of software processes</li><li>Often, the practice perspective activities are easier to pass under the radar and people tend to not do them until their code catches on fire</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Requirements</span></div><div><ul><li>You are trying to build a bridge between building a design for your system and the wishes of the stakeholders. </li><ul><li>BUT ALSO, it is the bridge between the design and the <span style="text-decoration: underline;">system model</span> </li></ul><li><span style="text-decoration: underline;">System model</span> — model of the problem that the stakeholders have</li><li><span style="text-decoration: underline;">Design</span> — model of the solution</li><li>Properties of good requirements:</li><ul><li>Requirements are testable once implemented</li><li>Requirements are feasible in the intended environment</li><li>Requirements don’t conflict with each other </li><li>Requirements are attributed to a specific person (who set this requirement?)</li><li>Requirements are bounded (to prevent <span style="font-style: italic;">scope creep</span>, define the bounds of your requirements!)</li><li>Requirements are unambiguous</li><li>Requirements are essential </li><ul><li><span style="font-style: italic; text-decoration: underline;">accident vs. essence</span>: accidents don’t matter, essence are the important aspects. Don’t waste time on accidents</li></ul><li>Requirements are specified at the user’s level (it must speak in the language of the stakeholder)</li><ul><li>User glossaries to get this right; be careful about terminology</li></ul><li>Requirements match the system’s <span style="text-decoration: underline;">vision</span> (what the stakeholder saw in the beginning regarding what the system will look like)</li><li>Requirements are prioritized</li><li>Requirements are <span style="text-decoration: underline;">validated</span> (requirements have to be checked to fulfill adequately all properties of good requirements — including this one!)</li></ul><li>Types of requirements</li><ul><li><span style="font-style: italic;">User requirements</span></li><ul><li>audience: users, managers</li></ul><li><span style="font-style: italic;">System requirements</span></li><ul><li>audience: developers, operations, managers</li></ul><li><span style="font-style: italic;">Functional requirements</span></li><ul><li>what does the system do?</li></ul><li><span style="font-style: italic;">Non-functional requirements</span></li><ul><li>performance, portability, security, … </li></ul></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Requirements from the dynamic perspective</span></div><div><ul><li><span style="font-style: italic;">Requirements inception</span></li><ul><li>Identify the stakeholders and their viewpoints</li><li>Find agreements (and disagreements)</li><li>Break the ice by asking <span style="font-style: italic;">dumb questions</span> about the context of the discussion</li><ul><li>Goals &amp; benefits questions (what’s in it for you, the stakeholder?)</li><li>Problem questions</li><li>Communications questions (how often should we meet to talk about requirements? …)</li></ul></ul><li><span style="font-style: italic;">Requirements discovery</span></li><ul><li>for big projects use a well-defined procedure</li><ul><li>meetings, agendas, preparation, facilitator</li><li>define problems, propose solutions, in user language</li><li>write everything down</li><li>iterate</li></ul><li>Produce: <span style="text-decoration: underline;">Requirements document</span> that contains</li><ul><li>Scope</li><li>Feasibility</li><li>Need</li><li>Stakeholder list</li><li>Use cases/stories</li><li>Prototypes</li><li>Constraints</li></ul></ul><li><span style="font-style: italic;">Requirements negotiation</span></li><ul><li>Lots of things that clients want, but not enough resources to implement them all</li><li>Which requirements should we keep?</li><li>Want a win-win situation that caters to all stakeholders</li><li>… so, priority discovery is key</li><li>Negotiation is the key role of written requirements</li></ul><li><span style="font-style: italic;">Requirements validation</span></li><ul><li>Check for consistency, validity, feasibility, …</li><li>Need to manage the validation process so that it is effectively respondent to changing requirements</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Requirements from the practice perspective</span></div><ul><li><span style="font-style: italic;">Requirements management </span></li><ul><li>Identify the requirements</li><li>Implement a change management policy (want needs to happen for a requirement to be changed?)</li><li>Trace to requirements (which requirements does this part of the code satisfy?)</li><li>Trace from requirements to stakeholders</li><li>Automated support often used</li></ul></ul><div><br/></div><ul><li>Cost to fix defects</li></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 112px;"/><col style="width: 103px;"/><col style="width: 105px;"/></colgroup><tbody><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div>time introduced vs. time detected</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 112px; padding: 8px;"><div><span style="font-weight: bold;">Requirements </span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 103px; padding: 8px;"><div><span style="font-weight: bold;">Architecture</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 105px; padding: 8px;"><div><span style="font-weight: bold;">Construction</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-weight: bold;">Requirements</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 112px; padding: 8px;"><div>1</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 103px; padding: 8px;"><div>N/A</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 105px; padding: 8px;"><div>N/A</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-weight: bold;">Architecture</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 112px; padding: 8px;"><div>3</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 103px; padding: 8px;"><div>1</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 105px; padding: 8px;"><div>N/A</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-weight: bold;">Construction</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 112px; padding: 8px;"><div>5-10</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 103px; padding: 8px;"><div>10</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 105px; padding: 8px;"><div>1</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-weight: bold;">System test</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 112px; padding: 8px;"><div>10</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 103px; padding: 8px;"><div>15</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 105px; padding: 8px;"><div>10</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-weight: bold;">Post-release</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 112px; padding: 8px;"><div>10-100</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 103px; padding: 8px;"><div>25-100</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 105px; padding: 8px;"><div>10-25</div></td></tr></tbody></table><div><br/></div></div></div><div><hr/></div><div><span style="font-size: 13px;"><span style="font-size: 13px; font-weight: bold;">Lecture Notes: January 17 — Software Engineering Principles</span></span></div></div><div><hr/><ul><li><span style="font-style: italic;">Hooker’s software engineering principles</span>:</li><ul><li>Provide value to users</li><li>Keep it simple, stupid</li><li>Architectural vision (being able to see what needs to be done before you start working)</li><li>Plan to get hit by a bus (make your project so that it can survive you)</li><li>Be ready for change</li><li>Plan for reuse</li><li>Think before doing</li><li>Dependability</li><li>Performance</li></ul><li>Software engineering fallacies (how not to do software engineering):</li><ul><li>Add people to a project if it’s late</li><li>Outsourcing: let somebody else do the work</li><li>Vague objectives and continually changing requirements</li><li>Getting the program out the door no matter what</li><li>Code is all there is (documentation is for wimps)</li><li>Voluminous policies &amp; procedures manuals</li></ul><li>Ethical issues in software engineering:</li><ul><li>who are you responsible to?</li><ul><li>public</li><li>client</li><li>employer</li><li>colleagues</li><li>profession</li><li>self</li></ul><li>What are you responsible for?</li><li>More issues: confidentiality, copyright, computer misuse</li></ul></ul><hr/></div><div><span style="font-size: 13px; font-weight: bold;">Somerville: Chapter 1 — Introduction</span></div><div><hr/><ul><li><span style="font-size: 13px;">Overarching reasons for software failure:</span></li><ul><li><span style="font-style: italic;">Increasing system complexity.</span></li><li><span style="font-style: italic;">Failure to use software engineering methods.</span></li></ul><li>Roughly 60% of software costs are development costs, 40% are testing costs.</li><li>Two kinds of software products:</li><ul><li><span style="font-style: italic;">Generic products.</span> Stand-alone systems that are produced by a development organization and sold on the open market to any customer who is able to buy them. Here, the developing company owns and defines the specification.</li><li><span style="font-style: italic;">Customized software. </span>Systems that are commissioned by and developed for a particular customer. Here, the developing company does not own the specification.</li></ul><li>Software product characteristics include:</li><ul><li><span style="font-style: italic;">Acceptability.</span> software must be acceptable to the type of users for which it is designed.</li><li><span style="font-style: italic;">Dependability and security</span>. Software dependability includes a range of characteristics including reliability, security and safety.</li><li><span style="font-style: italic;">Efficiency</span>. </li><li><span style="font-style: italic;">Maintainability. </span>Software should be written in such a way so that it can evolve to meet the changing needs of customers.</li></ul><li>Two elements of software engineering:</li><ul><li><span style="font-style: italic;">Engineering discipline</span></li><li><span style="font-style: italic;">All aspects of software production</span></li></ul><li>Software engineering is important for two reasons:</li><ul><li>More and more, individuals and society rely on advanced software systems.</li><li>Failure to use software engineering methods leads to higher costs of testing, quality assurance and long-term maintenance.</li></ul><li>Four fundamental activities that are common to all software processes:</li><ul><li>Software specification</li><li>Software development, where the software is designed and programmed.</li><li>Software validation, where the software is checked to ensure that it is what the customer requires.</li><li>Software evolution, where the software is modified to reflect changing requirements.</li></ul><li>Computer science is concerned with the theories and methods that underlie computers and software systems, whereas software engineering is concerned with the practical problem of producing software.</li><li>System engineering is concerned with all aspects of the development and evolution of complex systems where software plays a major role.</li><li>Four issues that effect many types of software:</li><ul><li><span style="font-style: italic;">Heterogeneity. </span>Mainly, this includes issues of software portability on hardware.</li><li><span style="font-style: italic;">Business and social change.</span></li><li><span style="font-style: italic;">Security and trust.</span></li><li><span style="font-style: italic;">Scale.</span></li></ul><li>Overarching software engineering principles:</li><ul><li>Systems should be developed using a managed and understood development process.</li><li>Remember dependability and performance</li><li>Understanding and managing the software specification and requirements.</li><li>Use existing resources as much as possible.</li></ul><li>General ethical principles related to software engineering:</li><ul><li><span style="font-style: italic;">Competence.</span> Do not misrepresent your level of competence.</li><li><span style="font-style: italic;">Confidentiality. </span>Respect the confidentiality of the information around you.</li><li><span style="font-style: italic;">Intellectual property rights. </span>Be aware of local laws governing the use of intellectual property such as patents and copyright.</li><li><span style="font-style: italic;">Computer misuse.</span> You should not use your technical skills to misuse other people’s computers.</li></ul><li>Engineers have an ethical responsibility towards:</li><ul><li><span style="font-style: italic;">Public.</span> </li><li><span style="font-style: italic;">Client and employer.</span></li><li><span style="font-style: italic;">Product. </span>Make sure their products meet the highest professional standards possible.</li><li><span style="font-style: italic;">Judgment</span>. Software engineers shall maintain integrity and independence in their professional judgment.</li><li><span style="font-style: italic;">Management.</span> Managers should subscribe to and promote ethical approaches to the management and maintenance of software.</li><li><span style="font-style: italic;">Profession</span>. Software engineers shall advance the integrity and reputation of the profession.</li><li><span style="font-style: italic;">Colleagues. </span>Software engineers shall be fair to and supportive of their colleagues.</li><li><span style="font-style: italic;">Self.</span> Software engineers shall participate in lifelong learning regarding the practice of their profession.</li></ul><li>Different types of software systems:</li><ul><li><span style="font-style: italic;">Embedded systems. </span>The software controls a hardware device and is embedded in it.</li><li><span style="font-style: italic;">Information systems. </span>Systems whose primary purpose is to manage and provide access to a database of information.</li><li><span style="font-style: italic;">Sensor-based data collection system.</span> Systems whose primary purpose is to collect data from a set of sensors and process that data in some way.</li><li><span style="font-style: italic;">A support environment.</span> An integrated collection of software tools that are used to support some kind of activity.</li></ul></ul><div><hr/><div><span style="font-weight: bold;">Somerville: Chapter 2 — Software processes</span></div></div><div><hr/><ul><li>A software process is a set of related activities that leads to the production of a software product</li><li>The four fundamental steps to software engineering</li><ul><li><span style="font-style: italic;">Software specification</span></li><li><span style="font-style: italic;">Software design and implementation</span></li><li><span style="font-style: italic;">Software validation</span></li><li><span style="font-style: italic;">Software evolution</span></li></ul><li>All four are part of software processes</li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Software processes can be improved by process standardization where the diver- sity in software processes across an organization is reduced. This leads to improved communication and a reduction in training time, and makes automated process sup- port more economical.</span></li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Process models (abstracted representations of software processes):</span></li><ul><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial; font-style: italic;">The waterfall model</span><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">. Represents the fundamental process activities as separate process phases.</span></li></ul></ul><div><img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%201.09.25%20PM.png" height="300" width="534"/><br/></div></div><div><ul><ul><li><span style="font-style: italic;">Incremental development. </span>This approach interleaves the activities of specification, development, and validation. The system is developed in a series of versions.</li><li><span style="font-style: italic;">Reuse-oriented software engineering.</span> Based on the existence of a significant number of reusable components. The system development process focuses on integrating these components into a system rather than developing them from scratch.</li></ul><li>Parts of the system which are difficult to specify in advance, such as the user interface, should always be developed using an incremental approach</li></ul><div><br/></div></div><div><span style="font-weight: bold;">The Waterfall Model</span></div><div><ul><li>A plan-driven process — you must, in principle, plan and schedule all of the process activities before starting work on them.</li><li>The principle stages of the waterfall model directly reflect the fundamental development activities:</li><ul><li><span style="font-style: italic;">Requirements analysis and definition. </span></li><li><span style="font-style: italic;">System and software design. </span>Allocates the requirements to either hardware or software systems by establishing an overall system architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.</li><li><span style="font-style: italic;">Implementation and unit testing. </span></li><li><span style="font-style: italic;">Integration and system testing.</span></li><li><span style="font-style: italic;">Operation and maintenance.</span></li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Incremental Development</span></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%202.11.26%20PM.png" height="266" width="490"/><br/></div><div><ul><li>Better than the waterfall model for most business, e-commerce, and personal systems.</li><li>Benefits compared to waterfall model:</li><ul><li>The cost of accommodating changing customer requirements is reduced.</li><li>It is easier to get customer feedback on the development work that has been done.</li><li>More rapid delivery and deployment of useful software to the customer is possible.</li></ul><li>Incremental development can be</li><ul><li><span style="font-style: italic;">Plan-driven</span>: the system increments are identified in advance</li><li><span style="font-style: italic;">Agile</span>: the early increments are identified but the development of later increments depends on progress and customer priorities.</li></ul><li>From a management perspective the incremental approach has two problems</li><ul><li>The process is not visible. Managers need regular deliverables to measure progress.</li><li>System structure tends to degrade as new increments are added. Unless time and money is spent on refactoring to improve the software, regular change tends to corrupt its structure. Incorporating further software changes becomes increasingly difficult and costly.</li></ul><li>These issues are particularly pronounced for large, complex, long-lifetime systems, where different teams develop different parts of the system. Large systems need a stable framework or architecture and the responsibilities of the different teams working on parts of the system need to be clearly defined with respect to that architecture.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Reuse-oriented software engineering</span></div><div><ul><li>Reuse-oriented approaches rely on a large base of reusable software components and an integrating framework for the composition of these components.</li><li>Stages of reuse-oriented software engineering are:</li><ul><li><span style="font-style: italic;">Component analysis. </span>Given the requirements specification, a search is made for components to implement that specification</li><li><span style="font-style: italic;">Requirements modification. </span>The requirements are modified based on information about the components that have been discovered.</li><li><span style="font-style: italic;">System design with reuse</span></li><li><span style="font-style: italic;">Development and integration</span></li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Requirements Engineering</span></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%204.57.32%20PM.png" height="275" width="533"/><br/></div><div><br/></div><div><span style="font-weight: bold;">Software design and implementation</span></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%204.58.54%20PM.png" height="367" width="474"/><br/></div><div><ul><li>Four activities that may be part of the design process for information systems:</li><ul><li><span style="font-style: italic;">Architectural design. </span>Identify the overall structure of the system.</li><li><span style="font-style: italic;">Interface design. </span>Identify the interfaces between system components.</li><li><span style="font-style: italic;">Component design.</span> Design how each system component will operate, including specific functional requirements for each component.</li><li><span style="font-style: italic;">Database design.</span> Design the system data structures and how these are to be represented in a database</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Software validation</span></div><div><ul><li>Software verification and validation is intended to show that a system both conforms to its specification and that it meets the expectations of the system customer</li><li>The stages in the testing process are</li><ul><li><span style="font-style: italic;">Development testing. </span>The components making up the system are tested by the people developing the system.</li><li><span style="font-style: italic;">System testing. </span>This process is concerned with finding errors that result from unanticipated interactions between components and component interface problems.</li><li><span style="font-style: italic;">Acceptance testing.</span> The system is tested with data supplied by the system customer rather than with simulated test data.</li></ul><li><span style="font-style: italic;">Beta testing </span>is another option. Here, the beta customer are given a product to play with and test, while reporting errors and bugs.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Coping with change</span></div><div><ul><li>It is essential that whatever software process model is used it can accommodate changes to the software being developed.</li><li>There are two related approaches that may be used to reduce the costs of rework</li><ul><li><span style="font-style: italic;">Change avoidance</span>, where the software process includes activities that can anticipate possible changes before significant rework is required. Prototyping can be a good tool for anticipating changing requirements since it can be used by stakeholders prior to serious development.</li><li><span style="font-style: italic;">Change tolerance</span>, where the process is designed so that changes can be accommodated at relatively low cost. Usually involves some type of incremental development.</li></ul><li><span style="font-style: italic;">Refactoring</span>, improving the structure and organization of a program, is also an important mechanism that supports change tolerance.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Prototyping</span></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%205.24.37%20PM.png" height="165" width="545"/><br/></div><div><ul><li>During requirements engineering, a prototype can help with the elicitation and validation of system requirements.</li><li>In the system design process, a prototype can be used to explore particular software solutions and to support user interface design.</li><li>Rapid prototyping with end-user involvement is the only sensible way to develop graphical user interfaces for software systems.</li><li>To reduce costs, prototyping can be done with relaxed non-functional requirements, reduced functionality, and no or little error-handling</li><li>Issues that might arise with prototyping:</li><ul><li>It may be impossible to tune the prototype to meet non-functional requirements</li><li>Rapid change during development means that the prototype is probably undocumented, which is not good enough for long-term maintenance.</li><li>The system structure may get compromised in order to conform to prototype</li><li>Organizational quality standards are normally relaxed for prototype development.</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Incremental delivery</span></div><div><ul><li>Each increment provides a part of the system’s functionality and is fully deployed to the user by the end of its cycle. Usually, the highest priority functionalities are delivered first.</li><li>Advantages of incremental delivery include:</li><ul><li>Customers can use the early increments as prototypes and gain experience that informs their requirements for later system increments.</li><li>Customers do not have to wait for entire system to derive value from using it</li><li>The process is developed with the mindset of adding new functionality being easy</li><li>Since the highest priority tasks are delivered first, the most importance services get the most user testing</li></ul><li>Issues with incremental delivery:</li><ul><li>It can be hard to identify common facilities that are needed by all increments.</li><li>Iterative development does not generally give useful feedback if it is done on systems that are developed to replace older systems.</li><li>In the incremental approach, there is no complete system specification until the final increment is specified. This might be hard for large contractors, like the government, to accommodate.</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Bohm’s spiral model</span></div><div><ul><li>A risk-driven software process framework.</li><li>Each loop in the spiral is split into four sectors:</li><ul><li><span style="font-style: italic;">Objective setting. </span>Objectives for current phase of project are defined. Project risks are identified. Alternative strategies, based on these risks, may be planned.</li><li><span style="font-style: italic;">Risk assessment and reduction. </span>For each of the identified risks, a detailed analysis is carried out. Steps are taken to reduce the risk.</li><li><span style="font-style: italic;">Development and validation.</span> After risk evaluation, a development model for the system is chosen.</li><li><span style="font-style: italic;">Planning. </span>The project is reviewed and a decision made whether to continue with a further loop of the spiral.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">The Rational Unified Process (RUP)</span></div><div><ul><li>Described from 3 perspectives:</li><ul><li><span style="font-style: italic;">A dynamic perspective</span>, which shows the phases of the model over time</li><li><span style="font-style: italic;">A static perspective</span>, which shows the process activities that are enacted</li><li><span style="font-style: italic;">A practice perspective</span>, which suggests general good practices to be used during the process</li></ul><li>Four phases of RUP:</li><ul><li><span style="font-style: italic;">Inception</span></li><ul><li>Establish a business case for the system </li><li>Define stakeholders and define how they interact with the system</li><li>Assess what contribution the system makes to the business</li></ul><li><span style="font-style: italic;">Elaboration</span></li><ul><li>Develop an understanding of the problem domain</li><li>Establish architectural framework for the system</li><li>Identify key project risk</li><li>Develop project plan</li><li>On completion, you should have a requirements model for the system, an architectural description, and a development plan</li></ul><li><span style="font-style: italic;">Construction</span></li><ul><li>The construction phase involves system design, programming, and testing. On completion, you should have a working software system and associated documentation that is ready for delivery to users.</li></ul><li><span style="font-style: italic;">Transition. </span>Moving the system from the development community to the user community and making it work in a real environment. Sometimes expensive and problematic. On completion, you should have a documented software system that is working correctly in its operational environment.</li></ul><li>Six fundamental software engineering best practices:</li><ul><li><span style="font-style: italic;">Develop software interatively. </span>Plan increments based on customer priorities.</li><li><span style="font-style: italic;">Manage requirements. </span>Explicitly document the customer’s requirements and keep track of changes to these requirements. Analyze the impact of changes on the system before accepting them.</li><li><span style="font-style: italic;">Use component-based architectures. </span>Structure the system architecture into independent components.</li><li><span style="font-style: italic;">Visually model software. </span>Use graphical models to present static and dynamic views of the software.</li><li><span style="font-style: italic;">Verify software quality. </span>Ensure that the software meets the organization quality standards.</li><li><span style="font-style: italic;">Control changes to software. </span>Manage changes to the software using a change management system and configuration management procedures and tools.</li></ul><li>Embedded software development is not ideal for using RUP.</li><li>RUP separates phases of development and workflows</li><ul><li>Phases are dynamic and have goals</li><li>Workflows are static and are technical activities that are not associated with a single phase but may be used throughout the development to achieve the goals of each phase.</li></ul></ul></div><div><div><hr/><div><span style="font-weight: bold;">Somerville: Chapter 16 — Software reuse</span></div><hr/></div><ul><li>Reuse-based software engineering is an approach to development that tries to maximize the reuse of existing software.</li><li>Key factors that need to be considered when planning reuse are:</li><ul><li><span style="font-style: italic; text-decoration: underline;">The development schedule for the software</span>. If the software has to be developed quickly, you should try to reuse off-the-shelf systems rather than individual components. </li><li><span style="font-style: italic; text-decoration: underline;">The expected software lifetime</span>. If you are developing a long-lifetime system, you should focus on the maintainability of the system. Don’t just think of the immediate benefits of using ready-made components but also of the long-term implications.</li><li><span style="font-style: italic; text-decoration: underline;">The background, skills, and experience of the development team</span>. </li><li><span style="font-style: italic; text-decoration: underline;">The criticality of the software and its non-functional requirements</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The application domain</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The platform on which the system will run</span><span style="font-style: italic;">. </span></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Application frameworks</span></div><div><ul><li>Experience shows that object-oriented approach produces objects are too small of a unit for successful reuse on the class level.</li><li>Frameworks are an integrated set of software artifacts that collaborate to provide a reusable architecture for a family of related applications. Frameworks provide support for generic features that are likely to be used in all applications of a similar type.</li><li>Three classes of frameworks:</li><ul><li><span style="font-style: italic; text-decoration: underline;">System infrastructure frameworks</span>. These frameworks support the development of system infrastructure such as communications, user interfaces, and compilers.</li><li><span style="font-style: italic; text-decoration: underline;">Middleware integration frameworks</span>. These consist of a set of standards and associated object classes that support component communication and information exchange.</li><li><span style="font-style: italic; text-decoration: underline;">Enterprise application frameworks</span>. These are concerned with specific application domains such as telecommunications or finance systems. These embed application domain knowledge and support the development of end-user applications.</li></ul><li>Features of web application frameworks:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Security</span>. Web Application Frameworks may include classes to help implement user authentication (login) and access control to ensure that users can only access permitted functionality in the system</li><li><span style="font-style: italic; text-decoration: underline;">Dynamic web pages</span>. Classes are provided to help you define web page templates and to populate these dynamically with specific data from the system database.</li><li><span style="font-style: italic; text-decoration: underline;">Database support</span>. The framework may provide classes that provide an abstract interface to different databases.</li><li><span style="font-style: italic; text-decoration: underline;">Session management</span>. Classes to create and manage sessions</li><li><span style="font-style: italic; text-decoration: underline;">User interaction</span>. AJAX support, which allows more interactive web pages to be created.</li></ul><li>To extend a framework you do not change the framework code. Rather, you add concrete classes that inherit operations from abstract classes in the framework. In addition, you may have to define callbacks. Callbacks are methods that are called in response to events recognized by the framework.</li><li>Frameworks are an effective approach to reuse, but are expensive to introduce into software development processes. </li><ul><li>They are inherently complex and it can take several months to learn to use them. </li><li>It may be hard to evaluate the quality of a framework</li><li>Debugging framework-based applications is difficult because the back-end method interactions may be hidden.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Software product lines</span></div><div><ul><li>A software product line is a set of applications with a common architecture and shared components, with each application specialized to reflect different requirements.</li><li>Application frameworks vs. Software product lines</li><ul><li>Application frameworks rely on object-oriented features such as inheritance and polymorphism to implement extensions to the framework. Software product lines are not necessarily created using an object-oriented approach.</li><li>Application frameworks are primarily focused on providing technical rather than domain-specific support. A software product line usually embeds detailed domain and platform information.</li><li>Software product lines are often control applications for equipment. For example, there may be a software product line for a family of printers. Application frameworks are usually software-oriented and they rarely provide support for hardware interfacing.</li><li>Software product lines are made up of a family of related applications, owned by the same organization.</li></ul><li>Types of software product line specialization:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Platform specialization</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Environment specialization</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Functional specialization</span>. Versions of application are created for specific customers who have different requirements.</li><li><span style="font-style: italic; text-decoration: underline;">Process specialization</span>. System is adapted to cope with specific business processes.</li></ul><li>System configuration may occur at different stages in the development process:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Design-time configuration</span>. The organization developing the software modifies a common product line core by developing, selecting, or adapting components to create a new system for a customer</li><li><span style="font-style: italic; text-decoration: underline;">Deployment-time configuration</span>. A generic system is designed for configuration by a customer or consultants working with the customer.</li></ul><li>Several levels of deployment-time configuration that may be provided in the system:</li><ul><li>Component selection, where you are free to select the modules in a system that provide the required functionality. </li><li>Workflow and rule definition, where you define workflows and validation rules that should apply to information entered by users or generated by the system.</li><li>Parameter definition, where you specify the values of specific system parameters that reflect the instance of the application you are creating.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">COTS Product Reuse</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Commercial-off-the-shelf (COTS)</span> product is a software system that can be adapted to the needs of different customers without changing the source code of the system.</li><li>Very widely adopted by large companies, as it offers significant benefits over customized software development:</li><ul><li>more rapid deployment of a reliable system may be possible (as with other types of reuse)</li><li>It is possible to see what functionality is provided by the applications and so it is easier to judge whether or not they re likely to be suitable.</li><li>Some development risks are avoided by using existing software.</li><li>Business can focus more on their core activity without having to devote a lot of resource to IT systems development</li><li>As operating platforms evolve, technology updates may be simplified as these are the responsibility of COTS product vendor rather than the customer.</li></ul><li>Downsides of COTS:</li><ul><li>Requirements often have to be adapted to reflect the functionality and mode of operation of the COTS product.</li><li>The COTS product may be based on assumptions that are practically impossible to change.</li><li>Choosing the right COTS system for an enterprise can be a difficult process.</li><li>There may be a lack of local expertise to support systems development.</li><li>The COTS product vendor controls system support and evolution.</li></ul><li>Key features of architecture:</li><ul><li>A number of modules to support different business functions. These are large-grain modules that may support entire departments or division of the business.</li><li>A defined set of business processes, associated with each module, which relate to activities in that module.</li><li>A common database that maintains information about all related business functions.</li><li>A set of business rules that apply to all data in the database. For example, there may be a business rule that all expense claims have to be approved by someone more senior than the person making the claim.</li></ul><li><span style="font-style: italic; text-decoration: underline;">COTS-integrated systems</span> are applications that include two or more COTS products or, sometimes, legacy application systems.</li><li>Design choices that need to be made in order to develop systems using numerous COTS products:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Which COTS products offer the most appropriate functionality?</span></li><li><span style="font-style: italic; text-decoration: underline;">How will data be exchanged between different COTS products?</span></li><li><span style="font-style: italic; text-decoration: underline;">Which features of each product will actually be used?</span></li></ul><li>Downsides of COTS-integrated systems:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Lack of control over functionality and performance</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Problems with COTS system interoperability</span>. Each COTS product may  embed its own assumptions about how it will be used, and these need not be consistent with each other.</li><li><span style="font-style: italic; text-decoration: underline;">No control over system evolution</span><span style="font-style: italic;">.</span></li><li><span style="font-style: italic; text-decoration: underline;">Support from COTS vendors.</span></li></ul></ul><div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 18 — Distributed Software Engineering</span></div><hr/></div></div></div></div><ul><li>Virtually all large computer-based systems are now distributed systems.</li><li>A distributed system is a collection of independent computers that appears to the user as a single coherent system.</li><li>Advantages of using a distributed approach to systems development:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Resource sharing</span>. A distributed system allows the sharing of hardware and software resources that are associated with computers on a network.</li><li><span style="font-style: italic; text-decoration: underline;">Openness</span>. Distributed systems are normally open systems, which means that they are designed around standard protocols that allow equipment and software from different vendors to be combined.</li><li><span style="font-style: italic; text-decoration: underline;">Concurrency.</span> Several processes may operate at the same time on separate computers on the network.</li><li><span style="font-style: italic; text-decoration: underline;">Scalability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Fault tolerance</span>. The availability of several computers and the potential for replicating information means that distributed systems can be tolerant of some hardware and software failures.</li></ul><li>Distributed systems are inherently more complex than centralized systems. </li><li>Distributed systems exhibit emergent properties that are hard to predict.</li></ul><div><br/></div><div><span style="font-weight: bold;">Distributed Systems Issues</span></div><div><ul><li>Design issues that have to be considered in distributed systems engineering are:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Transparency</span>. To what extent should the distributed system appear to the user as a single system?</li><li><span style="font-style: italic; text-decoration: underline;">Openness</span>. Should a system be designed using standard protocols that support interoperability?</li><li><span style="font-style: italic; text-decoration: underline;">Scalability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Security</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Quality of service</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Failure management</span>.</li></ul><li>Central control of a distributed system is impossible, so individual computers in a system may behave differently at different times.</li><li>Network delays are unavoidable.</li><li>The three dimensions of scalability:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Size</span>. It should be possible to add more resources to a system to cope with increasing numbers of users</li><li><span style="font-style: italic; text-decoration: underline;">Distribution</span>. It should be possible to geographically disperse the components of a system without degrading its performance.</li><li><span style="font-style: italic; text-decoration: underline;">Manageability</span>. It should be possible to manage a system as it increases in size, even if parts of the system are located in independent organizations.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Scaling-up</span>: Replacing existing resources with more powerful alternatives</li><li><span style="font-style: italic; text-decoration: underline;">Scaling-out</span>: means adding additional resources to the system</li><li>Types of attacks that a distributed system must defend against:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interception</span>, where communications between parts of the system are intercepted by an attacker which implies loss of confidentiality</li><li><span style="font-style: italic; text-decoration: underline;">Interruption</span>, where system services are attacked and cannot be delivered as expected.</li><li><span style="font-style: italic; text-decoration: underline;">Modification</span>, where data or services in the system are changed by an attacker</li><li><span style="font-style: italic; text-decoration: underline;">Fabrication</span>, where an attacker generates information that is not suppose to exist.</li></ul><li>Different organizations that own different parts of the system may implement incompatible security policies.</li><li><span style="font-style: italic; text-decoration: underline;">Models of interaction</span></li><ul><li>two fundamental types of interaction that may take place between the computers in a distribute computing system:</li><ul><li>procedural interaction (implemented through <span style="font-style: italic; text-decoration: underline;">remote procedure calls (RPCs)</span></li><ul><li>requires both the caller and callee to be alive</li></ul><li>message-based interaction </li><ul><li>involves one component creating a message that details the services required from another component</li><li>the receiving component receives this message through middleware software</li><li>middleware transits the receiver’s response</li><li>unavailability can be tolerated as the message simply stays in the queue until receiver becomes available</li></ul></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Middleware</span>. Sits in the middle between distributed components of a system.</li><ul><li>General purpose software, usually bought off-shelf</li><li>Middleware provides two distinct types of support in a distributed system</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interaction support</span>, where the middleware coordinates interaction between different components in the system.</li><li><span style="font-style: italic; text-decoration: underline;">The provision of common services</span>, where the middleware provides reusable implementations of services that may be required by several components in the distributed system. By using these common services, components can easily interoperate and provide user services in a consistent way.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Client-server computing</span></div><div><ul><li>Usual organization of distributed systems.</li><li>Application is modeled as set of services provided by a server.</li><li>Load-balancing software distributes requests for service from clients to different servers so that each server does the same amount of work</li><li>Architectural patterns for distributed systems</li><ul><li>Five architectural styles:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Master-slave architecture</span>. Used in real-time systems in which guaranteed interaction response times are required.</li><li><span style="font-style: italic; text-decoration: underline;">Two-tier client-server architecture</span>. Used in simple client-server systems, and when centralizing the system is important for security.</li><li><span style="font-style: italic; text-decoration: underline;">Multitier client-server architecture</span>. Used to reduce the processing volume of the central server.</li><li><span style="font-style: italic; text-decoration: underline;">Distributed component architecture</span>. Used when resources from different systems and databases need to be combined.</li><li><span style="font-style: italic; text-decoration: underline;">Peer-to-peer architecture</span>. Used when clients exchange locally stored information and the role of the server is to introduce clients to each other.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Software as a services (SaaS)</span></div><div><ul><li>Problems of server overload can be significantly reduced by using a modern browser as the client software. You can even have the server send Javascript code to execute on the client.</li><li>Key elements of SaaS are the following:</li><ul><li>Software is deployed on a server and is accessed through a web browser.</li><li>Software is owned and managed by a software provider, rather than the organizations using the software</li><li>Users may pay for the software according to the amount of use they make of it or through an annual or monthly subscription.</li></ul><li>Data transfer is done at network speeds</li><li>Lack of control over software evolution</li><li>Differences between SaaS and SOA (Service Oriented Architectures)</li><ul><li>SaaS is a way of providing functionality on a remote server with client access through web browser. The server maintains the user’s data and state during an interaction session. Transactions usually last longer.</li><li>SOA is an approach to structuring a software system as a set of separate, stateless services. These may be provided by multiple providers and may be distributed. Transactions are typically short: service is called, it does something, and then returns a result.</li><li>SaaS is a way of delivering application functionality to the users, whereas SOA is an implementation technology for application systems.</li></ul><li>Agile development optimal for SaaS because initial approach is usually defined based on perceived need rather than specific customer feedback, so some adaptations will probably be necessary.</li><li>Three important factors concerning SaaS:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Configurability</span>. How do you configure the software for the specific requirements of each organization?</li><li><span style="font-style: italic; text-decoration: underline;">Multi-tenancy</span>. How do you present each user of the software with the impression that they are working with they own copy of the system while, at the same time, making efficient use of system resources?</li><li><span style="font-style: italic; text-decoration: underline;">Scalability</span>. How do you design the system so that it can be scaled to accommodate an unpredictably large number of users?</li></ul><li>Configuration facilities may allow for the following:</li><ul><li>Branding</li><li>Business rules and workflows</li><li>Database extensions</li><li>Access control</li></ul><li>Guidelines for developing scalable software:</li><ul><li>Develop applications where each component is implemented as a simple stateless device that can be run on any server.</li><li>Design the system using asynchronous interaction so that the application does not have to wait for the result of an interaction.</li><li>Manage resources as a pool so that no single server is likely to runout of them.</li><li>Design your database to allow fine-grain locking of data.</li></ul></ul><div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 24 — Quality Management</span></div><hr/></div></div></div></div><ul><li>Three principal concerns of software quality management for software systems:</li><ul><li>At the organizational level, quality management is concerned with establishing a framework of organizational processes and standards that will lead to high-quality software.</li><li>At the project level, quality management involves the application of specific quality processes, checking that these planned processes have been followed, and ensuring that the project outputs are conferment with the standards that are applicable to that project.</li><li>Quality management at the project level is also concerned with establishing a quality plan for a project. This plan should set out the quality goals for the project and define what processes and standards are to be used.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Quality Assurance (QA)</span> is the definition of processes and standards that should lead to high-quality products and the introduction of quality processes into the manufacturing process.</li><li><span style="font-style: italic; text-decoration: underline;">Quality Control</span> is the application of these quality processes to weed out products that are not of the required level of quality</li><li>Quality management team should not be associated with any particular development group, but should rather have organization-wide responsibility for quality management.</li><li>The suggested outline structure for a quality plan:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Product introduction</span>. A description of the product, tis intended market, and the quality expectations</li><li><span style="font-style: italic; text-decoration: underline;">Product plans</span>. The critical release dates and responsibilities for the product, along with plans for distribution and product servicing.</li><li><span style="font-style: italic; text-decoration: underline;">Process descriptions</span>. The development and service processes and standards that should be used for product development and management.</li><li><span style="font-style: italic; text-decoration: underline;">Quality goals</span>. Including identification of justification of critical product quality attributes.</li><li><span style="font-style: italic; text-decoration: underline;">Risks and risk management</span>. The key risks that might affect product quality and the actions to be taken to address these risks. </li></ul><li>Quality managers should aim to develop a quality culture where everyone responsible for software development is committed to achieving a high level of product quality.</li></ul><div><br/></div><div><span style="font-weight: bold;">Software Quality</span></div><div><ul><li>QA team is required to review the tests that check a programs fitness for purpose.</li><li>It is difficult to assess software quality attributes, such as maintainability, without using the software for a long time.</li></ul><div><br/></div><div><span style="font-weight: bold;">Software Standards </span></div><div><ul><li>An important part of quality assurance is the definition or selection of standards that should apply to the software development process or product.</li><li>Why are software standards important?</li><ul><li>Standards capture wisdom that is of value to the organization. They are based on knowledge about the best or most appropriate practice for the company. They thus prevent remaking the same quality mistakes.</li><li>Standards provides  framework for defining what quality means in a particular setting.</li><li>Standards assist continuity when work carried out bu one person is taken up and continued by another. Standards ensure that all engineers within an organization adopt the same practices.</li></ul><li>Two related types of software engineering standards that may be used in software quality management:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Product standards</span>. Apply to the software product being developed. Include document standards, documentation standards, coding standards.</li><li><span style="font-style: italic; text-decoration: underline;">Process standards</span>.Define the processes that should be followed during software development. May define specification, design, and validation processes, process support tools, and a description of documents that should be written using these processes.</li></ul><li>The purpose of standards is to deliver value, in the form of increased product quality. They need to be designed so that they can be applied and checked in a cost-effective way.</li><li>Quality management teams that are developing standards for a company should normally base these company standards on national and international standards.</li><li>To minimize dissatisfaction and to encourage buy-in to standards, quality managers who set the standards should therefore take the following steps:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Involve software engineers in the selection of product standards</span>. Your standards document should include explanations why the development team agreed to follow the standards listed.</li><li><span style="font-style: italic; text-decoration: underline;">Review and modify standards regularly to reflect changing technologies</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Provide software tools to support standards</span>.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">The ISO 9001 standards framework</span></div><div><ul><li>An international set of standards that can be used in the development of quality management systems in all industries called ISO 9000.</li><li>ISO 9001 is the most general of the standards in the ISO 9000 family and pertains to organizations that design, develop, and maintain products, including software. </li><li>Nine core processes of ISO 9001:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Product delivery processes</span>:</li><ul><li>Business Acquisition</li><li>Design and Development</li><li>Test</li><li>Production and Delivery</li><li>Service and Support</li></ul><li><span style="font-style: italic; text-decoration: underline;">Supporting processes</span>:</li><ul><li>Business Management</li><li>Supplier Management</li><li>Inventory Management</li><li>Configuration Management</li></ul></ul><li>To be ISO 9001 compliant, a company must only define the specific quality processes listed above, with no restrictions on the definition.</li></ul><div><br/></div><div><span style="font-weight: bold;">Reviews and Inspections</span></div><div><ul><li>Reviews and inspections are QA activities that check the quality of project deliverables.</li><li>The review should check the consistency and completeness of the documents or code under review and make sure that quality standards have been followed.</li><li>The purpose of reviews and inspections is to improve software quality, not to asses the performance of people in the development team.</li><li><span style="font-style: italic; text-decoration: underline;">The Review process</span>. Three phases:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Pre-review activities</span>. Concerned with review planning and review preparation. The team may meet to get an overview of the software to be reviewed.</li><li><span style="font-style: italic; text-decoration: underline;">The review meeting</span>. An author of the document or program being reviewed should walk through the document with the review team during the review meeting. One team member should chair the review and another should formally record all review decisions and actions to be taken.</li><li><span style="font-style: italic; text-decoration: underline;">Post-review activities</span>. After the meeting is finished, the issues and problems raised during the review must be addressed.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Program inspections</span>.</li><ul><li>Peer reviews where team members collaborate to find bugs in the program that is being developed</li><li>During inspection, a checklist of common programming errors is often used to focus the search for bugs. This checklist is often programming language specific.</li><li>These checklists should be regularly updated.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Software measurement and metrics</span></div><div><ul><li>The long-term goal of software measurement is to use measurement in place of reviews to make judgments about software quality.</li><li>Examples of control or process metrics are the average effort and the time required to repair reported defects.</li><li>Predictor metrics are associated with the software itself.</li><li>Two ways in which measurements of a software system can be used</li><ul><li><span style="font-style: italic; text-decoration: underline;">To assign a value to system quality attributes</span>. </li><li><span style="font-style: italic; text-decoration: underline;">To identify the system components whose quality is substandard</span>.</li></ul><li>If the measure of the internal attribute is to be a useful predictor of the external software characteristic, three conditions must hold</li><ul><li>The internal attribute must be measured accurately.</li><li>A relationship must exist between the attribute that can be measured and the external quality attribute that is of interest.</li><li>This relationship between the internal and external attributes must be understood, validated, and expressed in terms of a formula or model.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Product metrics</span></li><ul><li>E.g., system size, measured in lines of code, or the number of methods associated with each object class.</li><li>Two categories of product metrics:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Dynamic metrics</span>. Collected by measurements made of a program in execution.</li><li><span style="font-style: italic; text-decoration: underline;">Static metrics</span>. Collected by measurements made of representations of the system.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Measurement ambiguity</span></li><ul><li>It is easy to misinterpret data and to make inferences that are incorrect.</li></ul></ul><div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 25 — Configuration Management</span></div><hr/></div></div></div></div></div></div><ul><li>Configuration management is concerned with the policies, processes, and tools for mangling changing software systems.</li><li>Involves four closely related activities:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Change management</span>. Involves keeping track of requests for changes to the software from customers and developers</li><li><span style="font-style: italic; text-decoration: underline;">Version management</span>. </li><li><span style="font-style: italic; text-decoration: underline;">System building</span>. Process of assembling program components, data, and libraries, and then compiling and linking these to create an executable system.</li><li><span style="font-style: italic; text-decoration: underline;">Release management</span>. Involves preparing software for external release.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Change management</span>.</li><ul><li>Ensures that the changes are applied to the system in a controlled way.</li><li>Ensures priority is given to the most urgent and cost-effective changes.</li><li>Concerned with analyzing the costs and benefits of proposed changes.</li><li>Concerned with tracking changed components and histories </li><li>After a change request has been submitted, it has to be checked to ensure that it addresses a valid concern and that it is not caused by misunderstanding.</li><li>Significant factors that should be taken into account in deciding whether or not a change should be approved are</li><ul><li><span style="font-style: italic; text-decoration: underline;">The consequences of not making the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The benefits of the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The number of users affected by the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The cost of making the change</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The product release cycle</span>.</li></ul><li>A record must be maintained of each component as changes are introduced.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Version management</span>.</li><ul><li>Baselines may be specified using a configuration language, which allow you to define what components are included in a version of a particular system.</li><li>Features provided by version management systems:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Version and release identification</span>. Managed versions are assigned identifiers when they are submitted to the system.</li><li><span style="font-style: italic; text-decoration: underline;">Storage management</span>. To reduce the storage space required by multiple versions of components that differs only slightly, version management systems usually provide storage management facilities.</li><li><span style="font-style: italic; text-decoration: underline;">Change history recording</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Independent development</span>. Different developers may be working on the same component at the same time. System makes sure changes do not collide.</li><li><span style="font-style: italic; text-decoration: underline;">Project support</span>. </li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">System building</span></div><div><ul><li>System building is the process of creating a complete, executable system by compiling and linking the system components, external libraries, configuration files, … </li><li>Building is complex, because there may be three different system platforms involved:</li><ul><li><span style="font-style: italic; text-decoration: underline;">The development system</span>, which includes development tools such as compilers, source code editors, … This involves using local build tools that use checked-out versions of components in the private workspace.</li><li><span style="font-style: italic; text-decoration: underline;">The build server</span>, which is used to build definitive, executable versions of the system. This interacts closely with the version management system. This interacts closely with the version management system. The system build may rely on external libraries that are not included in the version management system.</li><li><span style="font-style: italic; text-decoration: underline;">The target environment</span>, which is the platform on which the system executes. It is often not possible to build and test the system on the development computer or on the build server.</li></ul><li>Features a build system may provide include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Build script generation</span>. Defines dependent components and lists all dependencies in a defined script language.</li><li><span style="font-style: italic; text-decoration: underline;">Version management system integration</span>.The build system should check out the required versions of components from the version management system.</li><li><span style="font-style: italic; text-decoration: underline;">Minimal recompilation</span>. The build system should work out what source code needs to be recompiled and set up compilations if required.</li><li><span style="font-style: italic; text-decoration: underline;">Executable system creation</span>. The build system should link the compiled object code files with each other and with other required files, such as libraries and configuration files, to create an executable system.</li><li><span style="font-style: italic; text-decoration: underline;">Test automation</span>. Check that the build has not been broken by changes.</li><li><span style="font-style: italic; text-decoration: underline;">Reporting</span>. The build system should provide reports about the success or failure of the build.</li><li><span style="font-style: italic; text-decoration: underline;">Documentation generation</span>. </li></ul><li>Signatures used to eliminate redundant recompilation:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Modification timestamps</span>. The signature on the source code file is the time and date when that file was modified. Recompile if compiled version is older than the last modified time of the source code.</li><li><span style="font-style: italic; text-decoration: underline;">Source code checksums</span>. The signature on the source code file is a checksum calculated from data in the full. If there is no object code with appropriate checksum signature, compile.</li></ul><li>Agile methods recommend that very frequent system builds should be carried out with automated testing to discover software problems.</li><li><span style="font-style: italic; text-decoration: underline;">Continuos integration</span> — idea of making changes to the end-system frequently. Steps in continuous integration:</li><ul><li>Check out the mainline system from the version management system into the developer’s private workspace</li><li>Build the system and run automated tests to ensure that the built system passes all tests. If not, the build is broken and you should inform whoever did the last commit.</li><li>Make the changes to the system components</li><li>Build the system in the private workspace and rerun system tests. If the tests fail, continue editing.</li><li>Once the system has passed its tests, check it into the build system but do not commit it as a new system baseline.</li><li>Build the system on the build server and run the tests. You need to do this in case others have modified other components since you checked out the system.</li><li>Once the system passes its tests on the build system, commit the changes you have made as a new baseline in the system mainline.</li></ul><li>Possible issues with continuous integration:</li><ul><li>If the system is very large, it may take a long time to build and test making continuous integration impractical.</li><li>If the development platform is different from the target platform, it may not be possible to run system tests in the developer’s private workspace.</li></ul><li>If continuous integration is not practical, a daily build system may be used:</li><ul><li>The development organization sets a delivery time for system components. If developers have new versions of the components that they are writing, they must deliver them by that time. Components may be incomplete but should provide some basic testable functionality.</li><li>A new version of the system is built from these components by compiling and linking them to form a complete system.</li><li>This system is then delivered to the testing team, which carries out a set of predefined system tests.</li><li>Faults that are discovered during system testing are documented and returned to the system developers. They repair these faults in a subsequent version of the component.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Release management</span></div><div><ul><li>A system release is a version of a software system that is distributed to customers.</li><li>The company must be able to reproduce the exact piece of software delivered to some customer at some point in time.</li><li>Make sure to record the versions of the operating system, libraries, compilers, and other tools used to build the software.</li><li>Careful thought must be given to release timing.</li><li>If releases are too frequent or require hardware upgrades, customers may not move to the new releases</li><li>If system releases are too infrequent, market share may be lost as customers move to alternative systems</li><li>A system release is not just the executable code of the system. It may also include:</li><ul><li>configuration files defining how the release should be configure for particular installations</li><li>data files needed for successful system operation</li><li>an installation program that is used to help install the system on target hardware</li><li>electronic and paper documentation designing the system</li><li>packaging and associated publicity that have been designed for that release.</li></ul><li>New releases of the system cannot rely on the installation of previous releases, because there is no guarantee these were performed by the customer.</li></ul></div></div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 3 — Agile Software Development</span></div><div><hr/><div><ul><li>Due to today’s business environment, a rapid development and delivery schedule is often the most critical requirement for software systems.</li><li>Faster development is increasingly more important than software quality</li><li>Characteristics of agile development approaches</li><ul><li>The processes of specification, design, and implementation are interleaved</li><li>The system is developed in a series of versions. End-users and other system stakeholders are involved in specifying and evaluating each version</li><li>System user interfaces are often developed using an interactive development system.</li></ul><li>Typically, new releases of the system are created and made available to customers every two or three weeks.</li><li>The overhead of detailed planning, designing, and documentation is justified in</li><ul><li>critical systems</li><li>development environments with multiple teams that require coordination</li><li>case many people will be involved in maintaining the software over its lifetime</li></ul><li>Core principles of agile development</li><ul><li><span style="font-style: italic;">Customer involvement.</span></li><li><span style="font-style: italic;">Incremental delivery.</span></li><li><span style="font-style: italic;">People not process.</span>People should be left to develop their own ways of working without prescriptive processes.</li><li><span style="font-style: italic;">Embrace change</span></li><li><span style="font-style: italic;">Maintain simplicity. </span>Applies both to the software being developed and the development process.</li></ul><li>Possible issues with agile approaches</li><ul><li>Customer may not be willing to constantly interact</li><li>Individual team members may not be suitable personalities for the intense involvement required in agile teams</li><li>Prioritizing changes can be very difficult, especially if there are many stakeholders</li><li>Maintaining simplicity requires extra work.</li><li>It may be hard for teams to adapt to a new development model.</li><li>Difficult to use for outsourcing, since agile does not require (and discourages) writing detailed specifications prior to development.</li></ul><li>What to consider when deciding on agile for software maintenance projects:</li><ul><li>Are systems that are developed using an agile approach maintainable, given the emphasis in the development process of minimizing formal documentation?</li><li>Can agile methods be used effectively for evolving a system in response to customer change requests?</li></ul><li>Formal documentation is supposed to describe the system and so make it easier for people changing the system to understand. In practice, formal documentation is often not kept up to date and so does not accurately reflect the program code. Agile, on the other hand, focuses on writing well-structured and maintainable code. Nevertheless, the System Requirement Specification is still one of the most useful documentations in software, and is often necessary for efficient maintenance of software and is often up to date in practice in comparison to other types of documentation.</li><li>Another agile maintainability issue is that team members might leave the team, yet agile depends on the fact that implicitly each team member understands fully some portion of the code because they built it. Lack of documentation make bringing in new people hard.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Plan-driven and agile development</span></div><div><br/></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%208.16.28%20PM.png" height="349" width="460"/><br/></div></div></div></div><div><ul><li>A plan-driven software process can support incremental development and delivery.</li><li>An agile team may be willing to dedicate a full iteration cycle to just writing up-to-date specification of the software developed so far</li><li>In deciding between plan-based and agile approaches, keep the following questions in mind:</li><ul><li>Is it important to have a detailed specification and design before moving to implementation?</li><li>Is an incremental delivery strategy realistic?</li><li>How large is the system being developed? Agile is most effective when the system can be developed with a small co-located team who can communicate informally.</li><li>What type of system is being developed?</li><li>What is the expected system lifetime? Long-lifetime systems may require more design documentation.</li><li>What technologies are available to support system development?</li><li>How is the development team organized?</li><li>Are there cultural issues that may affect the system development?</li><li>How good are the designers and programmers in the development team? Sometimes it is argued that agile methods require higher skill levels than plan-based approaches.</li><li>Is the system subject to external regulation?</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Extreme Programming</span></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%208.24.13%20PM.png" height="197" width="485"/><br/></div><div><ul><li>In extreme programming:</li><ul><li>Requirements are expressed as scenarios (called user stories) which are implemented directly as a series of tasks.</li><li>Programmers work in pairs and develop tests for each task before writing the code. All tests must be successfully executed when new code is integrated into the system</li><li>Short time gap between releases</li><li>Constant refactoring for maintainability</li></ul><li><span style="font-style: italic;">Spikes — </span>Iterations where no software construction is done. Instead, the team focuses on prototyping, writing documentation, talking to stakeholders…</li><li>Focus on maintainability by making programmers refactor any code they think might look better, even if it is not main priority.</li><li>Key features of testing in XP include:</li><ul><li>Test-first development</li><li>Incremental test development from scenarios</li><li>User involvement in the test development and validation</li><li>the use of automated testing frameworks</li></ul><li>An automated test framework is a system that makes it easy to write executable tests and submit a set of tests for execution.</li><li>Test-driven development may not yield a thorough set of tests:</li><ul><li>Programmers prefer programming to testing and sometimes may write incomplete tests in order to start writing ‘the real code’.</li><li>Some tests may be hard to write incrementally.</li><li>It is difficult to judge the completeness of a set of tests</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Pair programming</span></div></div><div><ul><li>Crucial aspect of XP. A pair of programmers sit at the same workstation and develop the software.</li><li>Pairs created dynamically so that all team members work with each other during the development process.</li><li>Advantages of pair programming:</li><ul><li>Supports the idea of <span style="font-style: italic;">collective ownership and responsibility for the system.</span> Egoless programming — individuals are not held accountable for problems in code, instead team has collective responsibility.</li><li>Acts as informal review process because each line is looked at by two people.</li><li>It helps support refactoring. Where pair programming and collective ownership are used, others benefit immediately from the refactoring so they are likely to support the process.</li><li>Pair programming reduces risks associated with a team member leaving the project early because knowledge of the code base is shared among pairs.</li></ul><li>There have been studies that state that pair programming is just as effective in code produced as two programmers working independently.</li></ul><div><br/></div><div><span style="font-weight: bold;">Agile project management</span></div><div><ul><li>Principal responsibility of project managers is to ensure the project is delivered on time and within budget<img src="CS%20130.resources/Screen%20Shot%202018-01-23%20at%208.54.23%20PM.png" height="173" width="497"/><br/></li><li><span style="font-style: italic;">Scrum — </span>an approach to project management for agile teams. Key characteristics:</li><ul><li>Sprints are fixed length (2-4 weeks usually)</li><li>The starting point for planning is the<span style="font-style: italic;"> product backlog</span> (list of work to be done on the project). During assessment, this backlog is reviewed and priorities and risks are assigned, features are selected for development, and the software is implemented.</li><li>Short daily meetings involving all team members are held to review progress and reprioritize work if necessary.</li><li>At end of sprint, work done is reviewed and presented to stakeholders.</li></ul><li>Noted advantages of Scrum</li><ul><li>The product is broken down into manageable and understandable chunks</li><li>Unstable requirements do not hold up progress</li><li>The whole team has visibility of everything and team communication is improved</li><li>Customers gain constant feedback on project state</li><li>Trust between customers and developers is established</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Scaling agile methods</span></div><div><ul><li>Difference between large team and small team development projects include</li><ul><li>Large teams are frequently in different geographical locations or time zones each developing a largely independent part of the larger system.</li><li>Large systems tend to interact with many already existing systems. These other systems may not lend themselves to easily to agile practices.</li><li>In large interacting systems, a lot of the development time is spent on configuring systems so that they work properly with each other. This may not be compatible with incremental development.</li><li>The development processes of large systems are often constrained by external rules.</li><li>People may move out of the team during the development process since this may last for years.</li><li>Diverse set of stakeholders in large systems is a problem for iterative design and tight feedback loops.</li></ul><li>Two perspectives on scaling of agile methods:</li><ul><li><span style="font-style: italic;">Scaling up</span>: how to use agile to build large systems?</li><li><span style="font-style: italic;">Scaling out</span>: how can agile methods be introduced across a large organization with many years of software developer experience?</li></ul><li>Possible ways in which agile could be modified to account for larger systems:</li><ul><li>Do more up-front design and system documentation. Critical aspects of the system must be documented.</li><li>Cross-team communication mechanisms have to be designed and used for specific cases.</li><li>Continuous integration is practically impossible in large systems due to impracticality of frequent deployment. There is a need for new configuration management tools that would support multi-team software development.</li></ul><li>Difficulties in introducing agile to large companies include</li><ul><li>Project managers do not have experience with agile and may be unwilling to accept it.</li><li>Large organizations have quality procedures and standards that all projects are expected to follow and are usually pretty bureaucratic.</li><li>Agile works best when team members are relatively qualified programmers.</li><li>Cultural resistence</li></ul></ul></div></div></div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 4 — Requirements Engineering</span></div></div><div><hr/><ul><li><span style="font-style: italic;">User requirements</span> are statements expressed in a natural language and diagrams of what services the system is expected to provide to system users and the constraints under which it must operate.</li><li><span style="font-style: italic;">System requirements </span>are more detailed descriptions of the software system’s functions, services, and operational constraints.</li><li><span style="font-style: italic;">Functional requirements </span>are statements of service the system should provide, how the system should react to particular inputs, and how the system should behave in particular situations.</li><li><span style="font-style: italic;">Non-functional requirements</span> are constraints on the services or functions offered by the system including timing constraints, constraints on the development process, and constraints imposed by standards. These include:</li><ul><li><span style="font-style: italic;">Product requirements. </span>Specify or constrain the behavior of the software (memory, speed constraints, reliability requirements, security requirements, usability requirements)</li><li><span style="font-style: italic;">Organizational requirements.</span> Broad system requirements derived from policies and procedures in the customer’s and developer’s organization. Include operational process requirements (how the system must be used), development process requirements (which language should be used?), environmental requirements specifying the operating environment of the system.</li><li><span style="font-style: italic;">External requirements.</span> All requirements that are derived from factors external to the system and its development process. These include regulatory requirements, legislative requirements, ethical requirements.</li><li>Write non-functional requirements quantitatively so that they can be objectively tested.</li><li>How to measure non-functional requirements:</li></ul></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 347px;"/></colgroup><tbody><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-weight: bold;">Property</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 347px; padding: 8px;"><div><span style="font-weight: bold;">Measure</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div>Speed</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 347px; padding: 8px;"><div><ul><li>Processed transactions</li><li>User/event response time</li><li>Screen refresh rate</li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div>Size</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 347px; padding: 8px;"><div><ul><li>Mbytes</li><li>Number of ROM chips</li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div>Ease of use</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 347px; padding: 8px;"><div><ul><li>Training time</li><li>Number of help frames</li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div>Reliability</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 347px; padding: 8px;"><div><ul><li>Mean time to failure</li><li>Probability of unavailability</li><li>Rate of failure occurrence</li><li>Availability</li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div>Robustness</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 347px; padding: 8px;"><div><ul><li>Time to restart after failure</li><li>Percentage of events causing failure</li><li>Probability of data corruption on failure</li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div>Portability</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 347px; padding: 8px;"><ul><li>Percentage of target dependent statements</li><li>Number of target systems</li></ul></td></tr></tbody></table><div><ul><li>In practice, customers for a system often find it difficult to translate this goals into measurable requirements.</li><li>Make sure to explicitly highlight requirements that are clearly related to emergent system properties, such as performance or reliability rather than putting them in the same basket as functional requirements.</li><li>The <span style="font-style: italic;">IEEE Standard on Requirements Specifications:</span></li></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 420px;"/></colgroup><tbody><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal; font-weight: bold;">Chapter</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal; font-weight: bold;">Description</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">Preface</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">Describe the expected readership of the document and describe its version history, including a rationale for the creation of a new version and a summary of the changes made in each version.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">Introduction</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">This should describe the need for the system. It should briefly describe the system’s functions and explain how it will work with other systems. It should also describe how the system fits into the overall business or strategic objectives of the organization commissioning the software.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">Glossary</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">This should define the technical terms used in the document. Do not make assumptions about the experience or expertise of the reader.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">User requirements definition</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">Here, you describe the services provided for the user. The non-functional system requirements should also be described in this section. This description may use natural language, diagrams, or other notations that are understandable to customers. Product and process standards that must be followed should be specified.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">System Architecture</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">High-level overview of the anticipated system architecture, showing the distribution of functions across system modules. Architectural components that are reused should be highlighted.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">System requirements specification</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">This should describe the functional and non-functional requirements in more detail. If necessary, further detail may also be added to the non-functional requirements. Interfaces to other systems may be defined.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">System models</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">Might include graphical system models showing the relationships between the system components, the system and its environment. E.g., object models, data-flow models, semantic data models.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">System evolution</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">Describe the fundamental assumptions on which the system is based, and any anticipated changes due to hardware evolution, changing user needs, etc. This section is useful for system designers as it may help them avoid design decisions that would constrain likely future changes to the system.</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-style: normal;">Appendicies</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 420px; padding: 8px;"><div><span style="font-style: normal;">Provide detailed, specific info that is related to the application being developed, e.g., hardware and database descriptions. Hardware requirements. Database requirements. </span></div></td></tr></tbody></table><div><span style="font-weight: bold;">Requirements Specification</span></div></div></div><div><ul><li>To minimize misunderstandings when writing natural language requirements follow some simple guidelines:</li><ul><li>Invent a standard format and ensure that all requirements adhere to it.</li><li>Use consistent language to distinguish between mandatory and desirable requirements.</li><li>Use text highlighting to pick out key parts of the requirement.</li><li>Do not assume readers understand technical language.</li><li>Include rationales for every requirement.</li></ul><li>To make an SRS you need to go through:</li><ul><li>Requirements discovery</li><li>Requirements classification and organization</li><li>Requirements prioritization and negotiation</li><li>Requirements specification</li></ul><li>Interviews with stakeholders may be of two types:</li><ul><li><span style="font-style: italic;">Closed,</span> where the developer comes in with a list of questions</li><li><span style="font-style: italic;">Open, </span>in which there is no pre-defined agenda.</li></ul><li>Completely open interviews rarely work well.</li><li>Difficulties with eliciting domain knowledge from stakeholders:</li><ul><li>The terminology and jargon used by the stakeholder may be domain specific. This specificity may imply that they will used subtle distinctions between terms that the requirements engineer cannot differentiate.</li><li>Some domain knowledge will be considered common sense by the stakeholder even though it is not.</li></ul><li>Interviewing is not enough, and should be used in conjunction with other requirements elicitation techniques.</li><li>Use <span style="font-style: italic;">scenarios</span> to better communicate requirements with stakeholders.</li><li>A scenario may include:</li><ul><li>A description of what the system and users expect when the scenario starts</li><li>A description of normal flow of events in the scenario</li><li>A description of what can go wrong and how this is handled</li><li>Information about other activities that might be going on at the same time</li><li>A description of the system state when the scenarios finishes.</li></ul><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Use cases identify the individual interactions between the system and its users or other systems.</span></li></ul><div><img src="CS%20130.resources/Screen%20Shot%202018-01-19%20at%201.55.14%20PM.png" height="337" width="557"/><br/></div></div><div><ul><li>One reason many software systems are delivered but never used is that their requirements do not take proper account of how the social organizational context affects the practical operation of the system. Satisfying social and organizational requirements is often critical for the success of the system.</li><li>Immerse yourself into the environment in which the software will be used. The day-to-day work is observed and notes made of the actual taste in which participants are involved. This helps discover implicit system requirements that reflect the actual ways the people work, rather than the formal processes defined by the organization.</li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Requirements validation is the process of checking that requirements actually define the system that the customer really wants. </span></li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">You need tool support for requirements management. You will need tools for:</span></li><ul><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Requirement storage</span></li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Change management</span></li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Traceability management. Registering related/conflicting requirements.</span></li></ul><li><span style="color: rgb(35, 31, 32); font-family: Arial;">The three principal stages to a change management process:</span></li><ul><li><span style="color: rgb(35, 31, 32); font-family: Arial;">Problem analysis and change specification. The process starts with an identified requirements problem or, sometimes, with a specific change proposal. Here, the problem or change proposal is analyzed to check that it is valid.</span></li><li><span style="color: rgb(35, 31, 32); font-family: Arial;">Change analysis and costing. The effect of the proposed change is assessed using traceability information and general knowledge of the system requirements. The total costs of making the change are established.</span></li><li><span style="color: rgb(35, 31, 32); font-family: Arial;">Change implementation.</span></li></ul></ul><div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 5 — System Modeling</span></div><hr/><ul><li>System modeling is the process of developing abstract models of a system, with each model presenting a different view or perspective of that system. </li><li>Usually done in the <span style="font-style: italic; text-decoration: underline;">Unified Modeling Language (UML)</span></li><li>Created during requirements engineering</li><li>Important to leave out detail in models.</li><li>Possible perspectives a model can be drawn for:</li><ul><li><span style="font-style: italic; text-decoration: underline;">External perspective</span>, where the context or environment of the system is modeled.</li><li><span style="font-style: italic; text-decoration: underline;">Interaction perspective</span>, where you model the interactions between a system and its environment or between the components of the system</li><li><span style="font-style: italic; text-decoration: underline;">Behavioral perspective</span>, where you model the dynamic behavior of the system and how it responds to events</li></ul><li>Essentials of UML are represented by following five diagram types:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Activity diagrams</span>, which show the activities involved in a process or in data processing.</li><li><span style="font-style: italic; text-decoration: underline;">Use case diagrams</span>, which show the interactions between a system and its environment</li><li><span style="font-style: italic; text-decoration: underline;">Sequence diagrams</span>, which show interaction between actors and the system and between system components.</li><li><span style="font-style: italic; text-decoration: underline;">Class diagrams</span>, which show the object classes in the system and the associations between these classes</li><li><span style="font-style: italic; text-decoration: underline;">State diagrams</span>, which show how the system reacts to internal and external events.</li></ul><li>How are models used?</li><ul><li>As a means of facilitating discussion about an existing or proposed system</li><li>As a way of documenting an existing system</li><li>As a detailed system description that can be used to generate a system implementation</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Context models</span></div><div><ul><li>Decide on system boundaries on early stages of system</li><li>Note that the system boundary may be determined by non-technical factors</li><li>Mental health system context model:</li></ul><div><img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%209.26.19%20PM.png" height="385" width="667"/><br/></div><div><br/></div><div><span style="font-weight: bold;">Interaction models</span></div><div><ul><li>Interaction models highlight communication issues that may arise</li><li>Two related approaches to interaction modeling:</li><ul><li>Use case modeling (usually used to model interaction between a system and external actors)</li><ul><li>Good support for requirements elicitation</li></ul><li>Sequence diagrams, used to model interactions between system components.</li></ul></ul><div><img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%209.32.53%20PM.png" height="388" width="701"/><br/></div><div><br/></div><div><span style="font-weight: bold;">Structural models</span></div><div><ul><li>Display the organization of a system in terms of the components that make up the system and their relationships</li></ul><div><br/></div><div><span style="font-weight: bold;">Class diagrams</span></div><div><ul><li>Used when developing an object-oriented system model to show the classes in a system and the associations between these classes.</li></ul><div><br/></div><div><span style="font-weight: bold;">Generalization diagrams</span></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%209.37.48%20PM.png" height="308" width="463"/><br/></div></div></div></div></div><div><span style="font-weight: bold;">Behavioral models</span></div></div><div><ul><li>Models of dynamic behavior of system as it is executing.</li><li>Possible stimuli include:</li><ul><li><span style="font-style: italic;">Data </span>(<span style="font-style: italic; text-decoration: underline;">Data-driven modeling</span>)</li><li><span style="font-style: italic;">Events </span>(<span style="font-style: italic; text-decoration: underline;">Event-driven modeling</span>)</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Model-driven engineering (MDE)</span></div><div><ul><li>Models, rather than programs are the principal output of the development process</li><li>Programs are then generated from the models automatically</li><li>Arguments for MDE:</li><ul><li>Allows engineers to think about systems at a high level of abstraction</li><li>Reduces likelihood of errors</li><li>Speeds up design and implementation</li><li>Reusable, platform-independent application models</li><li>Same model, different platform</li></ul><li>Arguments against MDE:</li><ul><li>arguments for MDE are only valid for long-lifetime systems where the platforms become obsolete during a system’s lifetime. However, for this class of systems, implementation is not the major problem — requirements engineering, security and dependability, integration to legacy systems, and testing are all more significant.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Model-driven architecture (MDA)</span></div><div><ul><li>Uses a sub-set of UML models to describe a system<img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%2010.15.40%20PM.png" height="236" width="547"/><br/></li><li>MDA method recommends three types of abstract system models be produced:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Computation Independent Model (CIM)</span> that models the important domain abstractions used in the system. Often called domain models.</li><li><span style="font-style: italic; text-decoration: underline;">Platform independent model (PIM)</span> that models the operation of the system without reference to its implementation.</li><li><span style="font-style: italic; text-decoration: underline;">Platform specific models</span> which are transformations of the platform-independent model with a separate PSM for each application platform</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Executable UML</span></div><div><ul><li>Ideal of automated transformation of models to code</li></ul></div></div></div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 6 — Architectural Design</span></div><hr/></div></div></div></div><div><ul><li>Even in agile processes, it is generally considered beneficial to include a comprehensive architecture stage at the beginning.</li><li>Software can be designed at two levels of abstraction:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Architecture in the small</span>. Concerned with the architecture of individual programs and how it is decomposed into components.</li><li><span style="font-style: italic; text-decoration: underline;">Architecture in the large</span>. Concerned with the architecture of complex enterprise systems that include other systems, programs, and components.</li></ul><li>Individual components implement the functional system requirements.</li><li>Non-functional requirements are largely affected by the interaction of these components (emergent property of the system)</li><li>Advantage of explicitly designing and documenting software architecture:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Stakeholder communication</span>. </li><li><span style="font-style: italic; text-decoration: underline;">System analysis</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Large-scale reuse</span>. Helps people understand the system and adapt it for reuse.</li></ul><li>Serves two purposes:</li><ul><li>design plan for the negotiation of system requirements</li><li>means of structuring discussions with clients, developers, and managers</li><li>Complexity management.</li></ul><li>Fundamental questions concerning any system:</li><ul><li>Is there a generic application architecture that can act as a template for the system that is being designed?</li><li>How will the system be distributed across a number of cores or processes?</li><li>What architectural patterns or styles might be used?</li><li>What will be the fundamental approach used to structure the system?</li><li>How will the structural components in the system be decomposed into subcomponents?</li><li>What strategy will be used to control the operation of the components in the system?</li><li>What is the impact of non-functional requirements on architectural decisions?</li><li>How will the architectural design be evaluated?</li><li>How will the architecture of the system be documented?</li></ul><li><span style="font-style: italic; text-decoration: underline;">Architectural patterns</span> are descriptions of a system organization (e.g. client-server organization, layered architecture)</li></ul><div><br/></div><div><span style="font-weight: bold;">Architectural Views</span></div><div><ul><li>What perspectives are useful when designing and documenting a system’s architecture?</li><li>What notations should be used for describing architectural models?</li><li><span style="font-style: italic; text-decoration: underline;">4+1 view model of software architecture</span> includes the following views:</li><ul><li><span style="text-decoration: underline;">A logical view.</span> Shows the key abstractions in the system as objects or object classes.</li><li><span style="text-decoration: underline;">A Process view</span>. How at run-time the system is composed of interacting processes. For non-functional requirements. </li><li><span style="text-decoration: underline;">A development view</span>.  Shows how the software is decomposed for development. For managers and programmers.</li><li><span style="text-decoration: underline;">A physical view</span><span style="font-style: italic;">. </span>Shows the system hardware and how software components are distributed across the processors in the system. Useful for systems engineers and system deployment.</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Architectural Patterns</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Architectural Pattern</span>. A stylized, abstract description of good practice, tried and tested on different systems and environments.</li><li><span style="font-style: italic; text-decoration: underline;">Layered architecture</span>.</li><ul><li>Separation and independence for localizing possible future changes</li><li>Advantages include:</li><ul><li>Ability to replace entire layers so long as the interface is maintained.</li><li>Redundant facilities can be provided in each layer to increase dependability of entire system</li></ul><li>Disadvantages include:</li><ul><li>Hard to make a clean separation between layers</li><li>Performance impact due to inability to communicate between all layers</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Repository architecture</span>.</li><ul><li>Leverages a centralized database/repository for easy sharing of information between components.</li><li>No need for explicit data transfer (just put into repository and who needs it will pick it up)</li><li>Advantages include:</li><ul><li>Components can be largely independent</li><li>Changes made by one component can be propagated to all components</li><li>All data can be managed consistently when centralized</li></ul><li>Disadvantages include:</li><ul><li>Repository is single point of failure</li><li>Organizing all communication through the repository may be inefficient</li><li>Distributing the repository to a network of computers may be difficult</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Client-server architecture</span>.</li><ul><li>Common runtime organization for distributed systems</li><li>Functionality organized into services, with each service delivered from a separate server. Clients make use of these services through servers.</li><li>Advantages include:</li><ul><li>servers can be distributed across a network</li><li>functionality could be available to all clients and does not need to be implemented by all services.</li></ul><li>Disadvantages include:</li><ul><li>Each service is a single point of failure so susceptible to DoS attacks of server failure.</li><li>Performance may be unpredictable</li></ul><li>Defined by:</li><ul><li>A set of servers that offer services to other components.</li><li>A set of clients that call on the services offered by servers.</li><li>A network that allows the clients to access these services.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Pipe and filter architecture</span>.</li><ul><li>Each processing component (<span style="font-style: italic; text-decoration: underline;">filter</span>) is discrete and carries out one type of data transformation.</li><li>The data flows from one component to another for processing.</li><li>Advantages include:</li><ul><li>Easy to understand and supports transformation reuse</li><li>Workflow matches structure of many business processes</li><li>Evolution can be easily done by just adding filters to the pipe</li><li>Can be implemented either sequentially or concurrently</li></ul><li>Disadvantages include:</li><ul><li>The format for data transfer has to be agreed upon between communicating transformations</li><li>Each transformation must parse its input and then unbars its output to the agreed format, which increases system overhead.</li></ul></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Application Architectures</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Enterprise Resource Planning (ERP)</span>. Increasing trend in companies such as SAP and Oracle</li><li><span style="font-style: italic; text-decoration: underline;">Vertical software packages (COTS)</span>. </li><li>In these systems, a generic system is configured and adapted to create a specific business application.</li><li>How to use application architecture as a software designer</li><ul><li><span style="font-style: italic; text-decoration: underline;">As a starting point for the architectural design process</span>. Good to base your initial design on a generic application architecture if you are unfamiliar with the problem domain.</li><li><span style="font-style: italic; text-decoration: underline;">As a design checklist</span>. Use to check that your design is consistent with the generic architecture.</li><li><span style="font-style: italic; text-decoration: underline;">As a way of organizing the work of the development team</span>. Use to separate components out and assign tasks to teams since components can usually be developed in parallel.</li><li><span style="font-style: italic; text-decoration: underline;">As a means of assessing components for reuse</span>. Does the model suggest any components that you already have and that can be reused?</li><li><span style="font-style: italic; text-decoration: underline;">As a vocabulary for talking about types of applications</span>. </li></ul><li>Two types of applications will be discussed:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Transaction processing applications</span>. Database-centered applications that process user requests for information and update the information in a database. Include banking systems, e-commerce systems, information systems, booking systems.</li><li><span style="font-style: italic; text-decoration: underline;">Language processing systems</span>. E.g. compilers, command languages for databases, markup languages such as XML</li></ul><li><span style="font-style: italic; text-decoration: underline;">Transaction processing systems</span>.</li></ul><div><br/></div><div><img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%2010.03.43%20AM.png" height="248" width="529"/><br/></div></div><ul><li><span style="font-style: italic; text-decoration: underline;">Language Processing Systems</span>.</li></ul><div><img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%2010.07.48%20AM.png" height="292" width="439"/><br/></div><div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 17 — Component-Based Software Engineering</span></div></div><hr/><ul><li>An approach to software reuse based on the composition of reusable, standardized components.</li><li><span style="font-style: italic; text-decoration: underline;">Component Based Software Engineering (CBSE)</span>.</li><ul><li>arrises after realization that single object classes are way to specific to be useful for reuse.</li></ul><li>Components are higher-level abstractions than objects and are defined by their interfaces.</li><li>Essentials of component-based software engineering:</li><ul><li>Independent components completely specified by their interfaces</li><li>Component standards that facilitate the integration of components.</li><ul><li>How should the component interfaces be specified?</li><li>Note that components written in different languages can be integrated into the same system.</li></ul><li>Middleware that provides software support for component integration.</li><ul><li>handles low-level issues efficiently and allows the developer to focus on application-related problems</li><li>May include component support for resource allocation, transaction management, security, and concurrency</li></ul><li>A development process geared to component-based software engineering.</li></ul><li>Design principles that support construction of understandable and maintainable software</li><ul><li>Components are independent and do not interfere with each other’s operation.</li><li>Components communicate through well-defined interfaces.</li><li>Component infrastructures offer a range of standard services that can be used in application systems.</li></ul><li>CBSE was motivated by:</li><ul><li>The need for more reuse</li><li>The need for distributed application systems</li></ul><li>Standardization of component development: COM, .NET, CCM, EJB, …</li><li>Standardization doesn’t work, so look at <span style="font-style: italic; text-decoration: underline;">component as a service</span> model.</li><li><span style="font-style: italic; text-decoration: underline;">Service oriented CBSE</span> becoming the dominant approach for the development of business systems</li></ul><div><br/></div><div><span style="font-weight: bold;">Components and Component Models</span></div><div><ul><li>Components must be</li><ul><li><span style="font-style: italic; text-decoration: underline;">Standardized</span></li><li><span style="font-style: italic; text-decoration: underline;">Independent</span></li><li><span style="font-style: italic; text-decoration: underline;">Composable</span></li><li><span style="font-style: italic; text-decoration: underline;">Deployable</span></li><li><span style="font-style: italic; text-decoration: underline;">Documented</span></li></ul><li>Looking at components as a service provider gives emphasis to two critical characteristics of a reusable component</li><ul><li>The component is an independent executable entity that is defined by its interfaces.</li><li>The services offered by a component made available through an interface and all interactions are through the interface.</li></ul><li>Two interfaces necessary for each component:</li><ul><li>The <span style="font-style: italic; text-decoration: underline;">provides interface</span> defines the services provided by the component.</li><li>The <span style="font-style: italic; text-decoration: underline;">requires interface</span> specifies what services must be provided by other components in the system if a component is to operate correctly.</li></ul></ul><div><ul><li><span style="font-style: italic; text-decoration: underline;">Component models</span>.</li><ul><li>a definition of standards for component implementation, documentation, and deployment</li><li>Necessary parts of component models:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interfaces</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Usage</span>. </li><ul><li>A globally unique name or handle associated with the component</li><li>How can the component be configure for a specific use case? </li><li>What are the rules of configuration of the component?</li></ul><li><span style="font-style: italic; text-decoration: underline;">Deployment</span>. </li><ul><li>Since components myst be independent, executable entities, they must be deployed with all necessary parts required for it to run aside from the ones defined by the <span style="font-style: italic; text-decoration: underline;">requires interface</span>.</li><li>Deployment information includes information about the contents of a package and its binary organization</li></ul></ul><li>Services provided by a component model implementation are in two categories:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Platform services</span>. Enable components to communicate and interpolate in a distributed environment</li><li><span style="font-style: italic; text-decoration: underline;">Support services</span>. Common services that are likely to be required by many different components. E.g. authentication.</li><ul><li>It makes sense to provide a standard set of middleware services for use by all components.</li></ul></ul><li>The middleware implements the component services and provides interfaces to these services.</li><li>It is as if components are deployed in a <span style="font-style: italic; text-decoration: underline;">container</span>.</li><ul><li>Containers are implementations of support services plus a definition of the interfaces that a component must provide to integrate with the container.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">CBSE Processes</span></div><div><ul><li>CBSE Processes are software processes that support component-based software engineering.</li><li>Two types of CBSE processes:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Development for reuse</span>. Concerned with developing components or services that will be reusable to other applications.</li><li><span style="font-style: italic; text-decoration: underline;">Development with reuse</span>. Recognizing and adapting already existing components for reuse in new systems.</li></ul><li>Related processes concerned with component acquisition, component management, and component certification:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Component acquisition</span>. Process of acquiring components for reuse or development into a reusable component (both externally and internally to the company)</li><li><span style="font-style: italic; text-decoration: underline;">Component management</span>. Concerned with managing a company’s reusable components, ensuring they are properly cataloged, stored, and made available for reuse.</li><li><span style="font-style: italic; text-decoration: underline;">Component certification</span>. </li></ul></ul><div><br/></div><div><span style="font-weight: bold;">CBSE for reuse</span></div><div><ul><li>The initial vision was that CBSE will be used in such a way that there will be dedicated companies that only built software components and then other companies with perhaps less developer power would buy component parts and relatively easily piece them together</li><li>Consequently, CBSE for ruse is most likely used within an organization.</li><li>However, components are usually not reusable without change</li><li>Since generalization of software components for reuse has an associated cost, it should be determined early if the component is to be made for reuse</li><li><span style="font-style: italic; text-decoration: underline;">Stable domain abstractions</span> are fundamental elements of the application domain that change slowly.</li><ul><li>For example, for a banking system, domain abstractions might include accounts, account holders, and statements.</li></ul><li>Key question: What stable domain abstractions are implemented by a given component?</li><li>Possible component changes required to make it more reusable:</li><ul><li>removing application-specific methods</li><li>changing names to make them more general</li><li>adding methods to provide more complete functional coverage</li><li>making exception handling consistent for all methods</li><li>adding a configuration interface to allow the component to be adapted to different situations of use</li><li>integrating required components to increase independence</li></ul><li>Exception handling is particularly hard.</li><li>Components should not handle exceptions themselves, to make for more general reuse.</li><li>Issues with not handling exceptions within the components:</li><ul><li>Publishing all exceptions creates bloated interfaces that are harder to understand. This may discourage use.</li><li>The operation of the component may depend on local exception handling, and changing this may have serious implications for the functionality of the component.</li></ul><li>Benefits of reusing rather than redeveloping a component are not simply productivity gains, but also quality gains.</li><li>Tradeoff between reusability and usability of component: More general components tend to be more complex.</li><li><span style="font-style: italic; text-decoration: underline;">Component certification</span> implies someone apart from the component developer checking the quality of the component.</li><li>The essential differences between CBSE with reuse and software processes for original software development are</li><ul><li>The user requirements are initially developed in outline rather than in detail, and stakeholders are encouraged to be as flexible as possible in defining their requirements. Requirements that are too specific limit the number of components that could meet these requirements.</li><li>Requirements are refined and modified early in the process depending on the components available.</li><li>Development is mainly concerned with piecing together existing components.</li></ul><li>Initially, search for components that are available locally or from trusted suppliers.</li><li>Key issue: Components are implemented with an original application environment in mind which carries a basically uncheckable number of implicit assumptions that might not be true for another application.</li></ul><div><br/></div><div><span style="font-weight: bold;">Component Composition</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Sequential composition</span>. You create a new component from 2 existing components by calling the existing components in sequence.</li><li><span style="font-style: italic; text-decoration: underline;">Hierarchical composition</span>. Occurs when one component calls directly on services provided by another component.</li><ul><li>The provides interface of the called component must be compatible with the requires interface of the calling component. If there is mismatch here, middleware code must be required to reformat the data.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Additive composition</span>. Occurs when two or more components are put together to create a new component, which combines their functionality. </li><ul><li>The provides interface and the requires interface of the new component is a combination of the corresponding interfaces in components A and B.</li><li>The components are called separately through the external interface of the composed component.</li><li>The underlying components are not dependent and do not call each other.</li></ul><li>Types of interface incompatibilities:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Parameter incompatibility</span>. Parameter types or names are different even though the functions have the same names and functionalities.</li><li><span style="font-style: italic; text-decoration: underline;">Operation incompatibility</span>. The names of the operations in the provides and requires interfaces are different.</li><li><span style="font-style: italic; text-decoration: underline;">Operation incompleteness</span>. The providers’ interface of a component is a subset of the requires interface of another component or vis versa.</li></ul><li><span style="font-style: italic; text-decoration: underline;">An adapter component</span> converts one interface to another.</li></ul><div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 7 — Design and Implementation</span></div><hr/><ul><li>Design and implementation are closely linked and you should normally take implementation issues into account when developing a design.</li><li>Two aims of this chapter:</li><ul><li>Show how system modeling and architectural design are put into practice in developing and object-oriented software design</li><li>To introduce issues of software reuse, configuration management, and open source development</li></ul><li>Steps to developing a proper design</li><ul><li>Understand and define the context and external interactions with the system</li><li>Design the system architecture</li><li>Identify the principal objects in the system</li><li>Develop design models</li><li>Specify interfaces</li></ul><li>System context and interactions</li><ul><li>Understanding of the context lets you establish the boundaries of the system</li><li>A system context model is a structural model that demonstrates the other systems in the environment of the system being developed</li><li>An interaction model is a dynamic model that shows how the system interacts with its environment as it is used</li></ul><li>Design models</li><ul><li><span style="font-style: italic; text-decoration: underline;">Structural models</span>, which describe the static structure of the system using object classes and their relationships.</li><li><span style="font-style: italic; text-decoration: underline;">Dynamic models</span>, which describe the dynamic structure of the system and show the interactions between the system objects</li><li>There models particularly useful for early stages of design process</li><ul><li><span style="font-style: italic; text-decoration: underline;">Subsystem models</span>, that show logical groupings of objects into coherent subsystems.</li><li><span style="font-style: italic; text-decoration: underline;">Sequence models</span>, which show the sequence of object interactions. These are dynamic models</li><li><span style="font-style: italic; text-decoration: underline;">State machine model</span>, which show how individual objects change their state in response to events.</li></ul></ul><li>You should not make detailed decisions about the implementation that really should be left to the system programmers.</li><li><span style="font-style: italic; text-decoration: underline;">Interface specification</span>.</li><ul><li>You need to specify interfaces so that objects and subsystems can be designed in parallel.</li></ul><li>Four essential elements of design patterns:</li><ul><li>A name that is a meaningful reference to the pattern</li><li>A description of the problem area that explains when the pattern may be applied</li><li>A solution description of the parts of the design solution, their relationships, and their responsibilities.</li><li>A statement of the consequences of applying the pattern. This helps designers understand trade-offs between different patterns.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Implementation Issues</span></div><div><ul><li>Some aspects of implementation that are particularly important to software engineering often not covered in programming texts:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Reuse</span>. </li><ul><li>Software reuse is possible on a number of different levels:</li><ul><li><span style="font-style: italic; text-decoration: underline;">The abstraction level</span>. Reuse knowledge of successful abstractions in the design of your software (involves no reuse of actual code)</li><li><span style="font-style: italic; text-decoration: underline;">The object level</span>. At this level, you directly reuse objects from a library rather than writing the code yourself.</li><li><span style="font-style: italic; text-decoration: underline;">The component level</span>. </li><li><span style="font-style: italic; text-decoration: underline;">The system level</span>. At this level, you reuse entire application system.</li></ul><li>Costs associated with reuse:</li><ul><li>The costs of the time spent in looking for software to reuse and assessing whether or not it meets your needs.</li><li>Where applicable, the costs of being the reusable software.</li><li>The cost of adapting and configuring the reusable software components or systems to reflect the requirements of the system that you are developing</li><li>The costs of integrating reusable software elements with each other and with the new code that you have development.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Configuration management</span>. Many different versions of each software component are created.</li><ul><li>Three fundamental configuration management activities:</li><ul><li><span style="text-decoration: underline;">Version management</span>, where support is provided to keep track of the different versions of software components.</li><li><span style="text-decoration: underline;">System integration</span>, where support is provided to help developers define what versions of components are used to create each version of a system. This description is then used to build a system automatically by compiling and linking the required components.</li><li><span style="text-decoration: underline;">Problem tracking</span>, where support is provided to allow users to report bugs and other problems, and to allow users to report bugs and other problems.</li><li>Best known integration tool: UNIX make</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Host-target development</span>. Production software does not usually execute on the same computer as the software development environment.</li><ul><li>Simulators are often used when developing embedded systems.</li></ul></ul><li><span style="font-weight: bold;">Open source development</span></li><ul><li>Mature open source systems are usually very reliable</li><li>For a company involved in software development, there are two open source issues that have to be considered:</li><ul><li>Should the product that is being developed make use of open source components?</li><li>Should an open source approach be use for the software’s development?</li></ul><li>The three general models of open source licenses:</li><ul><li><span style="font-style: italic; text-decoration: underline;">The GNU General Public Lincense (GPL)</span>. If you use open source software that is licensed under the GPL license, then you must make that software open source</li><li><span style="font-style: italic; text-decoration: underline;">The GNU Lesser General Public License (</span><span style="font-style: italic;">LGPL). </span>This is a variant of the GPL license where you can write components that link to open source code without having to publish the source of these components.</li><li><span style="font-style: italic; text-decoration: underline;">The Berkley Standard Distribution (BSD) License</span>. Here, you are not obliged to republish any changes or modifications made to open source code. You can include the code in proprietary systems that are sold. If you use open source components, you must acknowledge the original creator of the code.</li></ul><li>Companies managing projects that se open source should:</li><ul><li>Establish a system for maintaining information about open source components that are downloaded and used.</li><li>Be aware of licensing and version control it</li><li>Be aware of evolution pathways for components. Understand what the goal of the open source project you want to use is.</li><li>Have auditing systems in place so that your organization does not breach licensing agreements.</li><li>Participate in the open source community.</li></ul></ul></ul></div><hr/><div><span style="font-weight: bold;">Sommerville: Chapter 19 — Service-Oriented Architecture</span></div><hr/></div></div></div></div></div></div><ul><li><span style="font-style: italic; text-decoration: underline;">Service-oriented architectures (SOA)</span> are a way of developing distributed systems where the system components are stand-alone services, executing on geographically distributed computers.</li><li>Services are platform and implementation-language independent</li><li>The key standards for web service-oriented architectures are as follows:</li><ul><li><span style="font-style: italic; text-decoration: underline;">SOAP</span>. A message interchange standard that supports the communication between services.</li><li><span style="font-style: italic; text-decoration: underline;">Web Service Definition Language (WSDL)</span>. A standard for service interface definition. defines how the service operations and service bindings should be defined.</li><li><span style="font-style: italic; text-decoration: underline;">WS-BPEL</span>. A standard for a workflow language that is used to define process programs involving several different services.</li></ul><li>Other standards that support SOA:</li><ul><li><span style="font-style: italic; text-decoration: underline;">WS-Reliable Messaging</span>, a standard for message exchange</li><li><span style="font-style: italic; text-decoration: underline;">WS-Security</span>, set of standards supporting web service security including standards that specify the definition of security policies and standards that cover the use of digital signatures</li><li><span style="font-style: italic; text-decoration: underline;">WS-Adressing</span>, which standardizes SOAP message addressing</li><li><span style="font-style: italic; text-decoration: underline;">WS-Transactions</span>, defines how transactions across distributed services should be coordinated.</li></ul><li><span style="font-style: italic; text-decoration: underline;">RESTful services</span>. Simpler approach to service communication</li><li>Service based applications may be constructed by linking services from various providers using either a standard programming language or a specialized workflow language.</li><li>In comparison to CBSE, services do not have a requires interface and are implemented in full completely independently of the rest of the world.</li></ul><div><br/></div><div><span style="font-weight: bold;">Service Engineering</span></div><div><ul><li>The process of developing services for reuse in service-oriented applications</li><li>Three logical stages of the service engineering process:</li><ul><li>Service candidate identification</li><ul><li>Service should support business processes</li></ul><li>Service design</li><li>Service implementation and deployment</li></ul><li>Three types of services:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Utility services</span>. Services that implement some general functionality that may be used by different business processes.</li><li><span style="font-style: italic; text-decoration: underline;">Business services</span>. Services associated with a specific business function</li><li><span style="font-style: italic; text-decoration: underline;">Coordination or process services</span>. Services that involve a more general business process which usually involves different actors and activities. An example is an ordering service that allows orders to be placed with suppliers, goods accepted, and payments made.</li></ul><li>Another dichotomy of services:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Task-Oriented</span>. Those associated with some activity</li><li><span style="font-style: italic; text-decoration: underline;">Entity-Oriented</span>. Associated with a business entity.</li></ul><li>Questions to ask when determining whether a service is general/reusable</li><ul><li>For an entity oriented service, is the service associated with a single logical entity that is used in different business processes? What operations are normally performed no the entity?</li><li>For a task-oriented service, is the task one that is carried out by different people in the organization? Will they be willing to accept the inevitable standardization that occurs when a single support service is provided?</li><li>Is the service independent (i.e. how much does it rely on availability of other services)?</li><li>Does it have to maintain state? If state is required, database must be used which limits service reusability. Better have state passed by the client to the service.</li><li>Could the service be used by clients outside of the organization?</li><li>Could the service be used by clients outside of the organization?</li><li>Are different users likely to have different non-functional requirements?</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Service Interface Design</span></div><div><ul><li>Three stages of service interface design</li><ul><li><span style="font-style: italic; text-decoration: underline;">Logical interface design</span>, where you identify the operations associated with the service, their inputs and outputs and the exceptions associated with these ops.</li><li><span style="font-style: italic; text-decoration: underline;">Message design</span>, where you design the structure of the message that are send and received by the service</li><li><span style="font-style: italic; text-decoration: underline;">WSDL development</span>, where you translate your logical and message design to an abstract interface description written in WSDL.</li></ul><li>Defining responses to exceptions is very important for services. </li><li>Leave all exception handling to the user.</li></ul><div><br/></div><div><span style="font-weight: bold;">Service Implementation and Deployment</span></div><div><ul><li>Deployment involves making the service available for use on a web server.</li></ul><div><br/></div><div><span style="font-weight: bold;">Legacy System Services</span></div><div><ul><li>Legacy systems are old software systems that rely on obsolete technology, but are still essential to the business.</li><li>Implementing wrappers for legacy systems that provide access to a system’s functions and data is popular.</li></ul><div><br/></div><div><span style="font-weight: bold;">Software Development with Services</span></div><div><ul><li>Based on the idea that you compose and configure services to create new composite services.</li><li>Idea of <span style="font-style: italic; text-decoration: underline;">services market</span> where services are bought from external suppliers.</li><li>Design with reuse inevitably requires requirements compromises</li><li>Key stages in the process of services construction by composition</li><ul><li><span style="font-style: italic; text-decoration: underline;">Formulate outline workflow</span>. Create ideal service design given requirements from user.</li><li><span style="font-style: italic; text-decoration: underline;">Discover services</span>. Search service registries or catalogs to discover what services exist</li><li><span style="font-style: italic; text-decoration: underline;">Select possible services.</span></li><li><span style="font-style: italic; text-decoration: underline;">Refine workflow.</span></li><li><span style="font-style: italic; text-decoration: underline;">Create workflow program.</span></li><li><span style="font-style: italic; text-decoration: underline;">Test completed service or app.</span></li></ul></ul><div><img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%2011.25.47%20PM.png" height="153" width="688"/><br/></div></div></div></div></div></div><div><div><br/></div><div><span style="font-weight: bold;">Workflow design and implementation</span></div><div><br/></div><div><b><img src="CS%20130.resources/Screen%20Shot%202018-01-31%20at%2011.28.46%20PM.png" height="319" width="607"/><br/></b></div><ul><li>Workflow design involves analyzing existing or planned business processes to understand the different activities that go on and how these exchange information.</li><li>Workflows are business process models</li></ul><div><hr/><div><span style="font-weight: bold;">Somerville: Chapter 20 — Embedded Software</span></div><hr/></div><ul><li>Introducing features of real-time software engineering</li><li>Embedded software is very important economically because almost every electrical device now includes software.</li><li>Aside for time constraints inherent to real-time systems, there are other important differences between embedded systems and other types of software systems:</li><ul><li>Embedded systems generally run continuously and do not terminate.</li><li>Interactions with the systems environment are uncontrollable and unpredictable</li><li>There may be physical limitations that affect the design of a system</li><li>Direct hardware interaction may be necessary</li><li>Issues of safety and reliability may dominate system design</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Embedded systems design</span></div><div><ul><li>Which system capabilities should be implemented in hardware and which in software?</li><li>Low-level architectural decisions must be considered early in the process</li><li>Usually employe the <span style="font-style: italic; text-decoration: underline;">stimulus-response model</span>, because embedded systems are inherently reactive.</li><li>You can define the behavior of a real-time system by listing the stimuli received by the system, the associated responses, and the time at which the response must be produced.</li><li>Stimuli fall into two classes:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Periodic stimuli</span>. These occur at predictable time intervals. Need not use interrupts, just periodically query state of the I/O device responsible for the stimuli.</li><li><span style="font-style: italic; text-decoration: underline;">Aperiodic stimuli</span>. These occur irregularly and unpredictably. Usually require interrupts to be handled correctly.</li></ul><li>Real-time systems usually implemented through concurrent, cooperating processes</li><li>Activities involved in a real-time software design process:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Platform selection</span>. Choose an execution platform for the system</li><li><span style="font-style: italic; text-decoration: underline;">Stimuli/response identification</span>. This involves identifying the stimuli that the system must process and the associated response or responses for each stimulus.</li><li><span style="font-style: italic; text-decoration: underline;">Timing analysis</span>.For each stimulus and associated response, you identify the timing constraints that apply to both stimulus and response processing. These are used to establish the deadlines for the processes in the system.</li><li><span style="font-style: italic; text-decoration: underline;">Process design</span>. Aggregate the stimulus and response processing into a number of concurrent processes. Then optimize the process architecture to reflect the requirements.</li><li><span style="font-style: italic; text-decoration: underline;">Algorithm design</span>. For each stimulus and response. Need to be developed relatively early in the design process.</li><li><span style="font-style: italic; text-decoration: underline;">Data design</span>. Specify the information that is exchanged by processes and the events that coordinate information exchange, and design data structures to manage this information exchange.</li><li><span style="font-style: italic; text-decoration: underline;">Process scheduling</span>. Design a scheduling system that will ensure that processes are started in time to meet their deadlines.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Real-Time Architectural Patterns</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Observe and React</span>. Used when a set of sensors are routinely monitored and displayed. When the sensors show that some event has occurred, the system reacts by initiating a process to handle the event.</li><li><span style="font-style: italic; text-decoration: underline;">Environmental Control</span>. Includes sensors and actuators that can change the environment. In response to environmental changes detected by the sensor, control signals are sent to the system actuators.</li><li><span style="font-style: italic; text-decoration: underline;">Process Pipeline</span>. Used when data has to be transformed from one representation to another before it can be processed. The transformation is implemented as a sequence of processing steps, which may be carried out concurrently.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Timing Analysis</span></div><div><ul><li>Three factors to consider:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Deadlines</span>. </li><ul><li>In hard real-time systems, not meeting a deadline means system failure</li><li>In soft real-time systems not meeting a deadline means degraded system performance</li></ul><li><span style="font-style: italic; text-decoration: underline;">Frequency</span>.</li><ul><li>The number of times per second that a process must execute so that you are confident that it can always meet its deadline</li></ul><li><span style="font-style: italic; text-decoration: underline;">Execution time</span>. </li><ul><li>Time required to process a stimulus and produce a response.</li><li>Have to take into account average execution time as well as worst-case execution time.</li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Real-Time Operating Systems (RTOS)</span></div><div><ul><li>RTOS in comparison with standard operating systems offers:</li><ul><li>fine-grain control over process scheduling</li><li>very low space and execution time overhead</li></ul><li>Most commonly, embedded system applications are built on to of RTOS</li><li><span style="font-style: italic; text-decoration: underline;">Bare-metal</span> approaches are also popular — include no operating system, the application takes care of everything</li><li>RTOS components include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Real-time clock</span></li><li><span style="font-style: italic; text-decoration: underline;">Interrupt-handler</span></li><li><span style="font-style: italic; text-decoration: underline;">Scheduler</span></li><li><span style="font-style: italic; text-decoration: underline;">Resource manager</span></li><li><span style="font-style: italic; text-decoration: underline;">Dispatcher</span></li></ul><li>Processes are handled on two levels:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Interrupt level</span>. For high priority, aperiodic tasks</li><li><span style="font-style: italic; text-decoration: underline;">Clock level</span>. For predictable, periodic tasks.</li></ul><li>Two most common scheduling strategies:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Non-pre-emptive scheduling</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Pre-emptive scheduling</span>.</li></ul></ul></div></div></div><hr/></div><div><span style="font-weight: bold;">Code Complete: Chapter 1 — Welcome to Software Construction</span></div></div><hr/><ul><li>Software development consists of:</li><ul><li>Problem definition</li><li>Requirements development</li><li>Construction planning</li><li>Software architecture, or high-level design</li><li>Detailed design</li><li>Coding and debugging</li><li>Unit testing</li><li>Integration testing</li><li>Integration</li><li>System testing</li><li>Corrective maintenance</li></ul></ul><hr/><div><span style="font-size: 13px; font-weight: bold;">Code Complete: Chapter 2 — Metaphors for a Richer Understanding of Software Development</span></div><div><hr/></div><div><ul><li>The  most primitive metaphor for software development grows out of the expression <span style="font-style: italic;">writing code</span>. This metaphor suggests that writing a program is like writing a casual letter. This does not describe software development fully.</li><li>Writing often involves creativity and originality, while writing code often involves reuse, and recycling well-known ideas in predictable and maintainable ways.</li></ul></div><hr/></div><div><span style="font-size: 13px; font-weight: bold;">Code Complete: Chapter 3 — Measure Twice, Cut Once: Upstream Prerequisites</span></div><hr/><div><ul><li><span style="font-size: 13px;">The overarching goal of preparation is risk reduction. It clears major risks out of the way</span></li><li><span style="font-size: 13px;">The greatest risks in software development are:</span></li><ul><li><span style="font-size: 13px;">Poor requirements</span></li><li><span style="font-size: 13px;">Poor project planning</span></li></ul><li><span style="font-size: 13px;">Causes of incomplete preparation:</span></li><ul><li><span style="font-size: 13px;">Lack of developer training in project planning, writing business cases, developing comprehensive and accurate requirements.</span></li><li><span style="font-size: 13px;">Eagerness to start coding.</span></li><li><span style="font-size: 13px;">Lack of understanding from upper management of the importance of good preparation.</span></li></ul><li><span style="font-size: 13px;">Let your own experience be your guide: Study and record thoroughly all major mistakes you make while building a project. <span style="font-size: 13px; font-style: italic;">Do post-mortem analysis!</span></span></li><li><span style="font-size: 13px;">Why do prerequisites before construction:</span></li><ul><li><span style="font-size: 13px;">It’s A LOT cheaper to build things right the first time.</span></li><li><span style="font-size: 13px;">Studies from over 25 years of industry data supports adequate preparation.</span></li></ul></ul></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 245px;"/><col style="width: 218px;"/><col style="width: 193px;"/></colgroup><tbody><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><br/></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Business Systems</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Mission-Critical Systems</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Embedded Life-Critical Systems</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px;"><span style="font-size: 13px; font-weight: bold;">Typical applications</span></span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Internet site</span></li><li><span style="font-size: 13px;">Inventory management</span></li><li><span style="font-size: 13px;">Games</span></li><li><span style="font-size: 13px;">Management information systems</span></li><li><span style="font-size: 13px;">Payroll system</span></li></ul></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Embedded software</span></li><li><span style="font-size: 13px;">Games</span></li><li><span style="font-size: 13px;">Internet site</span></li><li><span style="font-size: 13px;">Package software</span></li><li><span style="font-size: 13px;">Software tools</span></li><li><span style="font-size: 13px;">Web services</span></li></ul></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Avionics software</span></li><li><span style="font-size: 13px;">Embedded software</span></li><li><span style="font-size: 13px;">Medical devices</span></li><li><span style="font-size: 13px;">Operating systems</span></li><li><span style="font-size: 13px;">Packaged software</span></li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px;"><span style="font-size: 13px; font-weight: bold;">Life-cycle models</span></span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Agile</span></li><li><span style="font-size: 13px;">Evolutionary prototyping</span></li></ul></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><ul><li><span style="font-size: 13px;">Staged delivery</span></li><li><span style="font-size: 13px;">Evolutionary delivery</span></li><li><span style="font-size: 13px;">Spiral development</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><ul><li><span style="font-size: 13px;">Staged delivery</span></li><li><span style="font-size: 13px;">Spiral development</span></li><li><span style="font-size: 13px;">Evolutionary delivery</span></li></ul></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px;"><span style="font-size: 13px; font-weight: bold;">Planning and management</span></span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><ul><li><span style="font-size: 13px;">Incremental project planning</span></li><li><span style="font-size: 13px;">As-needed test and QA planning</span></li><li><span style="font-size: 13px;">Informal change control</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><ul><li><span style="font-size: 13px;">Basic up-front planning</span></li><li><span style="font-size: 13px;">Basic test planning</span></li><li><span style="font-size: 13px;">As-needed QA planning</span></li><li><span style="font-size: 13px;">Formal change control</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Extensive up-front planning</span></li><li><span style="font-size: 13px;">Extensive test planning</span></li><li><span style="font-size: 13px;">Extensive QA planning</span></li><li><span style="font-size: 13px;">Rigorous change control</span></li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Requirements</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><ul><li><span style="font-size: 13px;">Informal requirements specification</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Semiformal requirements specification</span></li><li><span style="font-size: 13px;">As-needed requirements reviews</span></li></ul></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Formal requirements specification</span></li><li><span style="font-size: 13px;">Formal requirements inspection</span></li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Design</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><ul><li><span style="font-size: 13px;">Design and coding are combined</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><ul><li><span style="font-size: 13px;">Architectural design</span></li><li><span style="font-size: 13px;">Informal detailed design</span></li><li><span style="font-size: 13px;">As-needed design reviews</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><ul><li><span style="font-size: 13px;">Architectural design</span></li><li><span style="font-size: 13px;">Formal architecture inspections</span></li><li><span style="font-size: 13px;">Formal detailed design</span></li><li><span style="font-size: 13px;">Formal detailed design inspections</span></li></ul></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Construction</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><ul><li><span style="font-size: 13px;">Pair programming or individual coding</span></li><li><span style="font-size: 13px;">Informal check-in procedure or no check-in procedure</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><ul><li><span style="font-size: 13px;">Pair programming or individual coding</span></li><li><span style="font-size: 13px;">Informal check-in procedure</span></li><li><span style="font-size: 13px;">As-needed code reviews</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><ul><li><span style="font-size: 13px;">Pair programming or individual coding</span></li><li><span style="font-size: 13px;">Formal check-in procedure</span></li><li><span style="font-size: 13px;">Formal code inspections</span></li></ul></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Testing and QA</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><ul><li><span style="font-size: 13px;">Developers test their own code</span></li><li><span style="font-size: 13px;">Test-first development</span></li><li><span style="font-size: 13px;">Little or no testing by a separate test group</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Developers test their own code</span></li><li><span style="font-size: 13px;">Test-first development</span></li><li><span style="font-size: 13px;">Separate testing group</span></li></ul></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Developers test their own code</span></li><li><span style="font-size: 13px;">Test-first development</span></li><li><span style="font-size: 13px;">Separate testing group</span></li><li><span style="font-size: 13px;">Separate QA group</span></li></ul></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;"><div><span style="font-size: 13px; font-weight: bold;">Deployment</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 245px; padding: 8px;"><ul><li><span style="font-size: 13px;">Informal deployment procedure</span></li></ul></td><td style="border: 1px solid rgb(219, 219, 219); width: 218px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Formal deployment procedure</span></li></ul></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 193px; padding: 8px;"><div><ul><li><span style="font-size: 13px;">Formal deployment procedure</span></li></ul></div></td></tr></tbody></table><div><ul><li><span style="font-size: 13px;">Rule of thumb: Specify ~80% of the requirements up front. Accept only the most valuable additional requirements.</span></li><li><span style="font-size: 13px;">Sequential vs. Iterative</span></li></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 202px;"/><col style="width: 234px;"/></colgroup><tbody><tr><td style="border: 1px solid rgb(219, 219, 219); width: 202px; padding: 8px;"><div><span style="font-weight: bold;">Choose sequential when</span></div></td><td style="border: 1px solid rgb(219, 219, 219); width: 234px; padding: 8px;"><div><span style="font-weight: bold;">Choose iterative when</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 202px; padding: 8px;"><div>Stable requirements</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 234px; padding: 8px;"><div>Requirements are not well understood or are expected to be unstable for other reasons</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 202px; padding: 8px;"><div>The design is straightforward and well understood</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 234px; padding: 8px;"><div>The design is complex, challenging, or both</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 202px; padding: 8px;"><div>The developers are familiar with the application area</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 234px; padding: 8px;"><div>The team is not familiar with the application area</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 202px; padding: 8px;"><div>Little risk in project</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 234px; padding: 8px;"><div>A lot of risk in project</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 202px; padding: 8px;"><div>Long-term predictability is important</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 234px; padding: 8px;"><div>Long-term predictability is not important</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); width: 202px; padding: 8px;"><div>The cost of changing requirements, design, and code downstream is likely to be high</div></td><td style="border: 1px solid rgb(219, 219, 219); width: 234px; padding: 8px;"><div>The cost of changing requirements, design, and code downstream is likely to be low</div></td></tr></tbody></table><div><br/></div></div></div></div><div><ul><li><span style="font-style: italic;">Problem definition</span>: The first prerequisite you need to fulfill before beginning construction is a clear statement of the problem that the system is supposed to solve. This implies a definition of what the problem is without any reference to possible solutions.</li><li>Problem definition -&gt; Requirements -&gt; Architecture -&gt; Construction -&gt; System testing -&gt; Future improvements</li><li>Problem definitions should be stated in plain language.</li><li><span style="font-style: italic;">Requirements</span> describe in detail what a software system is supposed to do, and they are the first step toward a solution.</li><li>Why have requirements?</li><ul><li>Explicit requirements help the developers focus on functionality, rather than purpose</li><li>They help to avoid arguments down the road.</li><li>Minimize changes to system once development starts.</li></ul><li>Understand that on a typical project, the customer can’t reliably describe what is needed before the code is written.</li><li>Studies show about 25% of initial requirements will change to some extent during development.</li><li>Dealing with requirements changes:</li><ul><li>Make all the stakeholders aware of the cost of a proposed requirement change.</li><li>Set up a change control procedure — a system for keeping track and logging requirement changes.</li><li>Use development practices that are robust enough to work with changing requirements.</li><li>Dump the project (if it gets too bad)</li><li>Always refer back to the business case that started the project in the first place</li></ul><li>Conditions for a formal, good requirements specification:</li><ul><li>Functional requirements:</li><ul><li>Are all the inputs to the system specified, including their source, accuracy, range of values, and frequency?</li><li>Are all the outputs from the system specified, including their destination, accuracy, range of values, frequency, and format?</li><li>Are all output formats specified for Web pages, reports, and so on?</li><li>Are all the external hardware and software interfaces specified?</li><li>Are all the external communication interfaces specified, including hand-shaking, error-checking, and communication protocols?</li><li>Are all the tasks the user wants to perform specified?</li><li>Is the data used in each task and the data resulting from each task specified?</li></ul><li>Non-functional (Quality) requirements:</li><ul><li>Is the necessary response time specified for all necessary operations?</li><li>Are other timing considerations specified, such as processing time, data-transfer rate, and system throughput?</li><li>Is the level of security specified?</li><li>Is the reliability specified, including the consequences of software failure, the vital information that needs to be protected from failure, and the strategy for error detection and recovery?</li><li>Are minimum machine memory and free disk space specified?</li><li>Is the maintainability of the system specified, including its ability to adapt to changes in specific functionality, changes in the operating environment, and changes in its interfaces with other software?</li><li>Is the definition of success included? Of failure?</li></ul><li>Requirements quality:</li><ul><li>Are the requirements written in the user’s language? Do the users think so?</li><li>Does each requirement avoid conflicts with other requirements?</li><li>Are acceptable tradeoffs between competing attributes specified — for example, between robustness and correctness?</li><li>Do the requirements avoid specifying the design?</li><li>Are the requirements at a fairly consistent level of detail? Should any requirement be specified in more detail? Should any requirement be specified in less detail?</li><li>Are the requirements clear enough to be turned over to an independent group for construction and still be understood? Do the developers think so?</li><li>Is each item relevant to the problem and its solution? Can each item be traced to its origin in the problem environment?</li><li>Is each requirement testable? Will it be possible for independent testing to determine whether each requirement has been satisfied?</li><li>Are all possible changes to the requirements specified, including the likelihood of each change?</li></ul><li>Requirements completeness:</li><ul><li>Where information isn’t available before development begins, are the areas of incompleteness specified?</li><li>Are the requirements complete in the sense that if the product satisfies every requirement, it will be acceptable?</li><li>Are you comfortable with all the requirements? Have you eliminated requirements that are impossible to implement and included just to appease your customer or boss?</li></ul></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Architecture Prerequisite</span></div><div><ul><li>Architecture usually specified in <span style="font-style: italic; text-decoration: underline;">Architecture specification</span></li><li>Good architecture makes construction easy. Bad architecture makes construction almost impossible.</li><li>Typical architectural components:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Program Organization</span>. </li><ul><li>Describes the system in broad terms.</li><li>In the architecture, you should find evidence that alternatives to the final organization were considered and find the reasons for choosing the final organization over its alternatives.</li><li>Design rationale is as important for maintenance as the design itself.</li><li>Every feature listed in the requirements should be covered by at least one building block.</li><li>What each building block is responsible for should be well defined.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Major Classes</span>.</li><ul><li>Identifies the responsibilities of each of the major classes and how they interact with each other.</li><li>Specify 20 percent of the classes that are responsible for 80 percent of the system’s behavior.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Data design</span>.</li><ul><li>Specify the major files and table designs to be used.</li><li>Describe alternatives and why they were chosen.</li><li>Data should normally be accessed directly by only one subsystem or class (<span style="font-style: italic; text-decoration: underline;">Information Hiding</span>)</li></ul><li><span style="font-style: italic; text-decoration: underline;">Business rules</span>.</li><ul><li>Describe the impact the rules have on the system’s design.</li></ul><li><span style="font-style: italic; text-decoration: underline;">User Interface Design</span>.</li><ul><li>The architecture should be modularized so that a new user interface can be substituted without affecting the business rules and output parts of the program.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Resource management</span>.</li><ul><li>The architecture should estimate the resources used for normal and extreme cases.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Security</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Performance</span>.</li><ul><li>If certain areas are at risk of failing to meet their goals, the architecture should say so.</li><li>If certain areas require the use of specific algorithms or data types to meet their performance goals, the architecture should say so.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Scalability</span>.</li><ul><li>If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Interoperability</span>.</li><ul><li>Describe how data or resources will be shared with other software or hardware.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Internationalization/Localization</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Input/Output</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Error processing</span>.</li><ul><li>Error handling has system-wide implications. </li><li>Questions to consider:</li><ul><li>Is error processing corrective or only detective?</li><li>Is it active or passive? I.e. does the system actively check user input for validity, or simply passively respond once they cannot be avoided?</li><li>How does the program propagate errors?</li><li>What are the conventions for handling error messages?</li><li>How will exceptions be handled? How will errors be documented?</li><li>At what level are errors handled?</li><li>What is the level of responsibility of each class for validating its input data?</li><li>Use built-in exception-handling mechanisms?</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Fault Tolerance</span>. </li><ul><li>A collection of techniques that increase a system’s reliability by detecting errors, recovering from them if possible, and containing their bad effects if not.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Architectural Feasibility</span>.</li><ul><li>Express concerns about system’s ability to meet requirements. This issues should be resolved before full-scale construction begins.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Overengineering</span>.</li><ul><li>The architecture should clearly specify whether programmers should err on the side of over engineering or on the side of doing the simples thing that works.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Buy vs. Build Decisions</span>.</li><ul><li>If we don’t used off-the-shelf components, we must explain the ways in which we expect custom-built components to surpass read-made libraries and components.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Reuse Decisions</span>.</li><ul><li>How will reused components be adapted to conform to the current system?</li></ul><li><span style="font-style: italic; text-decoration: underline;">Change Strategy</span>.</li><ul><li>Clearly describe a strategy for handling changes.</li><li>The architecture should indicate the strategies that are used to delay commitment.</li></ul><li><span style="font-style: italic; text-decoration: underline;">General Architectural Quality</span>.</li><ul><li>Good software architecture is largely machine- and language-independent.</li><li>The architecture should explicitly identify risky areas as well as why. What steps have been taken to mitigate the risk?</li></ul></ul></ul><div><hr/><div><span style="font-weight: bold;">McConnell: Chapter 4 — Key Construction Decisions</span></div><hr/></div></div><div><ul><li>This chapter focuses on preparations that individual programmers and technical leads are responsible for.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Choice of Programming Language</span></div><div><ul><li>The Sapri-Whorf hypothesis says that your ability to think a thought depends on knowing words capable of expressing the thought. If you don’t know the words, you can’t express the thought and you might not even be able to formulate it.</li></ul><div><br/></div><div><span style="font-weight: bold;">Programming Conventions</span></div><div><ul><li>In a complex program, architectural guidelines give the program structural balance and construction guidelines provide low-level harmony, articulating each class as a faithful part of a comprehensive design.</li><li>Without a unifying discipline, your creation will be a jumble of sloppy variations in style.</li><li>Before construction begins, spell out the programming conventions you’ll use.</li><li>How you spend your programming days will depend on where you are on the technology wave:</li><ul><li>If you are in the late part of the wave, you can plan to spend most of your day steadily writing new functionalities</li><li>If you are in the early part of the wave, you will spend a sizable amount of your time trying to figure out your programming language’s undocumented features and debugging errors in library code.</li></ul><li>Programmers who program “into” a language first decide what thoughts they want to express, and then they determine how to express those thoughts using the tools provided by the specific language.</li><li>If your language lacks constructs that you want to use or is prone to other kinds of problems, try to compensate for them. Invent your own coding conventions and standards.</li></ul><div><br/></div><div><span style="font-weight: bold;">Selection of Major Construction Practices</span></div><div><ul><li>Need to choose which good practices you will emphasize for the current project</li><li>Major construction practices</li><ul><li>Coding</li><ul><li>Define how much design will be done up front and how much will be done at the keyboard</li><li>Define coding conventions for names, comments, and layouts</li><li>Define specific coding practices that are implied by the architecture, how will error conditions be handled, how security will be addressed, what conventions will be used for class interfaces, what standards will apply to reused code, how much to consider performance while coding…</li><li>Identify which part of the technology wave you are on</li></ul><li>Teamwork</li><ul><li>Define the integration procedure, i.e. what must be done before checking the code into the master sources</li><li>Define if pair programming should be used</li></ul><li>Quality Assurance</li><ul><li>Define if programmers should write test cases for their code before writing the code</li><li>Define if programmers should write unit test for their code</li><li>Define if programmers should step through their code in the debugger before committing it</li><li>Define if programmers should integration test their code before a commit</li></ul><li>Tools</li><ul><li>Define the revision control tool</li><li>Define the language, version, and compiler to be used</li><li>Define a framework such as J2EE or .NET or explicitly decide not to use any</li><li>Define if use of non-standard language features is allowed</li><li>Define which editors, refactoring tools, debuggers, test frameworks, syntax checkers will be used</li></ul></ul></ul><div><hr/><div><span style="font-weight: bold;">McConnell: Chapter 20 — The Software-Quality Landscape</span></div><div><hr/><ul><li>This chapter surveys software-quality techniques from a construction point of view.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Characteristics of Software Quality</span></div><div><ul><li>Software has both internal and external quality characteristic</li><li>External characteristics are those the software user is aware of. These include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Correctness</span>. The degree to which a system is free from faults in its specification, design, and implementation</li><li><span style="font-style: italic; text-decoration: underline;">Usability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Efficiency</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Reliability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Integrity</span>. The degree to which a system prevents unauthorized or improper access to its programs and data.</li><li><span style="font-style: italic; text-decoration: underline;">Adaptability</span>. The extend to which a system can be used, without modification, in applications or environments other than those for which it was specifically designed.</li><li><span style="font-style: italic; text-decoration: underline;">Accuracy</span>. The degree to which a system is free from error, especially with respect to quantitative outputs. This is different from correctness; it determines how well a system does the job it’s built for rather than whether it was built correctly.</li><li><span style="font-style: italic; text-decoration: underline;">Robustness</span>. The degree tow which a system continues to function in the presence of invalid inputs.</li></ul><li>Internal quality characteristics include:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Maintainability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Flexibility</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Portability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Reusability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Readability</span>. The ease with which you can read and understand the source code of the system.</li><li><span style="font-style: italic; text-decoration: underline;">Testability</span>. The degree to which you can unit test and system test a system</li><li><span style="font-style: italic; text-decoration: underline;">Understandability</span>. The ease at which you can comprehend a system at both the system-organizational and detailed-statement levels.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Techniques for Improving Software Quality</span></div><div><ul><li>Elements of a software quality program</li><ul><li><span style="font-style: italic; text-decoration: underline;">Software quality objectives</span>. Without explicit goals, programmers might work to maximize characteristics different from the ones you expect them to maximize.</li><li><span style="font-style: italic; text-decoration: underline;">Explicit quality assurance activity</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Testing strategy</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Software engineering guidelines</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Informal technical reviews</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Formal technical reviews</span>.</li><li><span style="font-style: italic; text-decoration: underline;">External audits</span>.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Development Process</span></li><ul><li><span style="font-style: italic; text-decoration: underline;">Change control procedures</span>. One big obstacle to achieving software quality is uncontrolled changes.</li><li><span style="font-style: italic; text-decoration: underline;">Measurement of results</span>. Unless results of a quality-assurance plan are measured, you’ll have no way to know whether the plan is working.</li><li><span style="font-style: italic; text-decoration: underline;">Prototyping</span>. </li></ul><li><span style="font-style: italic; text-decoration: underline;">Setting Objectives</span></li><ul><li>Programmers have high achievement motivation: They will work to the objectives specified, but they must be told what the objectives are.</li></ul><li>If project developers are striving for a higher defect-detection rate, they need to use a variation of techniques.</li><li>The most economical defect-detection practices result in the least cost per defect found, all other things being equal.</li><li>Inspections are usually cheaper than testing. Code reading detected about 80 percent more faults per hour than testing in a study.</li><li>The longer a defect remains in the system, the more expensive it becomes to remove.</li><li>Testing is a two step process — it requires first noticing an issue and then diagnosing it. This increases defect correction time dramatically compared to other one-step methods.</li><li>A recommended combination for achieving higher-than-average quality:</li><ul><li>Formal inspections of all requirements, all architecture, and designs for critical parts of a system</li><li>Modeling/prototyping</li><li>Code reading or inspections</li><li>Execution testing</li></ul></ul><div><ul><li>General principles of software quality</li><ul><li>The General Principle of Software Quality is that improving quality reduces development costs.</li><li>The single biggest activity on most projects is debugging and correcting code that doesn’t work properly.</li></ul></ul></div></div></div></div></div><div><hr/><div><span style="font-weight: bold;">McConnell: Chapter 5 — Design in Construction</span></div><hr/></div></div></div><div><ul><li>Design is the activity that links requirements to coding and debugging</li><li>Software engineering in the real is a problem that can only be specified once the whole or part of the solution is implemented.</li><li>Design process is characterized by many dead-allies you encounter on the road to specifying a functional design</li><li>Making mistakes is the point of design; a good solution is often only subtly different from a poor one</li><li>Design is about tradeoffs and priorities</li><li>Design involves specifying restrictions required to effectively solve a problem given the resources available</li><li>Design provides a heuristic</li><li>Design is emergent</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Key design concepts</span></div><div><ul><li>Software’s primary technical imperative is managing complexity. Read “No Silver Bullets: Essence and Accidents of Software Engineering”</li><li>Importance of managing complexity:</li><ul><li>When projects fail for reasons that are primarily technical, the reason is often uncontrolled complexity.</li><li>Managing complexity is the most important technical topic  in software development</li></ul><li>Due to the unmanageable amount of complexity in each program, we as software developers shouldn’t try to cram whole programs in our brains at once; instead we should organize the programs in such a way that we can safely focus on one part of it at a time.</li><li>The goal is to minimize the amount of a program you have to think about at any one time.</li><li>Carefully defined objects separate concerns so that you can focus on one thing at a time.</li></ul><div><br/></div><div><span style="font-weight: bold;">How to Attack Complexity</span></div><div><ul><li>Causes of overly costly, ineffective designs:</li><ul><li>A complex solution to a simple problem</li><li>A simple, incorrect solution to a complex problem</li><li>An inappropriate, complex solution to a complex problem</li></ul><li>Two approaches to managing complexity:</li><ul><li>minimize the amount of essential complexity that anyone’s brain has to deal with at any one time</li><li>Keep accidental complexity from needlessly proliferating</li></ul><li>Once you understand that all other technical goals in software are secondary to managing complexity, many design considerations become straightforward</li></ul><div><br/></div><div><span style="font-weight: bold;">Desirable Characteristics of a Design</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Minimal complexity</span>. The primary goal of design should be to minimize complexity. Simple and easy-to-understand is more important than clever.</li><li><span style="font-style: italic; text-decoration: underline;">Ease of maintenance</span>. Think of the maintenance programmer as your audience.</li><li><span style="font-style: italic; text-decoration: underline;">Loose coupling</span>. Hold connections among different parts of a program to a minimum.</li><li><span style="font-style: italic; text-decoration: underline;">Extensibility</span>. Extensibility means that you can enhance a system without affecting other pieces.</li><li><span style="font-style: italic; text-decoration: underline;">Reusability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">High fan-in</span>. Refers to having a high number of classes that use a given class. High fan-in implies that a system has been designed to make good use of utility classes at the lower levels in the system.</li><li><span style="font-style: italic; text-decoration: underline;">Low-to-medium fan-out</span>. Have any given class use a low-to-medium number of other classes.</li><li><span style="font-style: italic; text-decoration: underline;">Portability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Leanness</span>. Design system so that it has no extra parts.</li><li><span style="font-style: italic; text-decoration: underline;">Stratification</span>. Software layering.</li><li><span style="font-style: italic; text-decoration: underline;">Standard techniques</span>. Use standardized and common approaches to your design so that they can be easily explained to other developers.</li></ul><div><br/></div><div><span style="font-weight: bold;">Levels of Design</span></div><div><ul><li>Levels at which design should be described include:</li><ul><li>Software system level</li><li>Division into subsystems/packages. Be sure to explicitly restrict communication between subsystems. Without any restriction, each subsystem will end up talking to each other subsystem and it would all grow into a big mess. There better be a good reason for initiating communication between two subsystems. Easier to restrict communication early and relax it later. Why restricting communication is important:</li><ul><li>How many different parts of the system does a developer need to understand at least a little bit to change something in the graphics subsystem?</li><li>What happens if you try to use the business rules in another system?</li><li>What happens when you want to put a new UI on the system, perhaps a command-line UI for testing?</li><li>What happens when you want to put data storage on a remote machine?</li><li>The communication graph between subsystems should be an Acyclic Graph</li><li>The simplest communication connection is having one subsystem call routines from another</li><li>A more involved relationship is to have one subsystem contain classes from another</li><li>The most involved relationship is to have classes in one subsystem inherit from classes in another.</li></ul><li>Division into classes within packages</li><li>Division into data and routines within classes</li><li>Internal routine design</li></ul><li>Commonly encountered subsystems:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Business rules</span>. These are the laws, regulations, policies, and procedures that you encode into a computer system.</li><li><span style="font-style: italic; text-decoration: underline;">User interface</span>. Create a subsystem to isolate user-interface components so that the user interface can evolve without damaging the rest of the program.</li><li><span style="font-style: italic; text-decoration: underline;">Database access</span>. You should hide the implementation details of accessing a database so that most of the program doesn’t need to worry about the messy details of manipulating low-level structures and can deal with the data in terms of how it’s used at the business-problem level.</li><li><span style="font-style: italic; text-decoration: underline;">System dependencies</span>. Package operating-system dependencies into a subsystem for the same reason you package hardware dependencies.</li></ul><li>The major design activity at the level of division into classes is to make sure that all the subsystems have been decomposed to a level of detail fine enough that you can implement their parts as individual classes.</li><li>The internal routine design is always done by necessity, though sometimes it’s done unconsciously and poorly rather than consciously and well.</li></ul><div><br/></div></div><div><span style="font-weight: bold;">Design Building Blocks: Heuristics</span></div><div><ul><li>The primary purpose of the following heuristics is to help manage complexity</li><li><span style="font-style: italic; text-decoration: underline;">Find Real-World Objects</span>.</li><ul><li>Identify the objects and their attributes</li><li>Determine what can be done to each object</li><li>Determine what each object is allowed to do to other objects</li><li>Determine the parts of each object that will be visible to other objects</li><li>Define each object’s public interface</li></ul><li>Possible barriers to information hiding:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Excessive distribution of information</span>. Centralized information makes information hiding a lot easier.</li><li><span style="font-style: italic; text-decoration: underline;">Circular dependencies</span>. As when a routine in class A calls a routine in class B, and a routine in class B calls a routine in class A. These also make a system hard to test because you can’t test either A or B until at least part of the other is ready.</li><li><span style="font-style: italic; text-decoration: underline;">Class data mistaken for global data</span>. While the road to programming hell is paved with global variables, class data presents far fewer risks. Two problems of global data:</li><ul><li>Routines operate on global data without knowing that other routines are operating on it</li><li>Routines are aware that other routines are operating on the global data but they don’t know exactly what they’re doing to it.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Perceived performance penalties</span>.The concern is that accessing data items indirectly incurs run-time performance penalties for additional levels of object intentions, routine class, and so on. However, at the point of design, this concern is premature. Until you can measure system performance and pinpoint specific bottlenecks, the best way to prepare for code-level performance work is to create a highly modular design.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Value of Information Hiding</span></div><div><ul><li>Information hiding is one of the few theoretical techniques that has indisputably proven its value in practice.</li><li>Information hiding is part of the foundation of both structured design and object-oriented design.</li><li>Information hiding inspires and promotes design devisions that thinking about objects does not.</li><li>Asking about what needs to be hidden supports good design decisions at all levels</li></ul><div><br/></div><div><span style="font-weight: bold;">Identify Areas Likely to Change</span></div><div><ul><li>Accommodating changes is one of the most challenging aspects of good program design</li><li>The goal is to isolate unstable areas so that the effect of a change will be limited to one routine, class or package.</li><ul><li><span style="font-style: italic; text-decoration: underline;">Identify items that seem likely to change</span>. If the requirements are done well, this step should be straightforward.</li><li><span style="font-style: italic; text-decoration: underline;">Separate items that are likely to change</span>. Compartmentalize each volatile component identified in step 1.</li><li><span style="font-style: italic; text-decoration: underline;">Isolate items that seem likely to change</span>. Design the interclass interfaces to be insensitive to the potential changes.</li><li><span style="font-style: italic; text-decoration: underline;">Business rules</span>. Business rules tend to be the source of frequent software changes.</li><li><span style="font-style: italic; text-decoration: underline;">Hardware dependencies</span>. Important for moving the program to a new environment.</li><li><span style="font-style: italic; text-decoration: underline;">Input and output</span>. Input/output tends to be a volatile area. In general, it is good to examine all external interfaces for possible changes.</li><li><span style="font-style: italic; text-decoration: underline;">Nonstandard language features</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Difficult design and construction areas</span>. It’s a good idea to hide difficult design and construction areas because they might be done poorly and you might need to do them again.</li><li><span style="font-style: italic; text-decoration: underline;">Status variables</span>. Status variables indicate the state of a program and tend to be changed more frequently. Adding flexibility to status variables includes:</li><ul><li>Don’t use a boolean variable as a status variable. Use an enumerated type so that you can add more sophisticated state detection later.</li><li>Use access routines rather than checking the variables directly. This also allows for more sophisticated state detection.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Data size constraints</span>. When you declare an array of size 100, you’re exposing information to the world that the world doesn’t need to see. Use a layer of indirection by declaring a constant like MAX_EMPLOYEES and set it to 100.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Anticipating Different Degrees of Change</span></div><div><ul><li>Only extremely unlikely changes should be allowed to have drastic consequences for more than one class in a system.</li><li>Consider qualitative changes as well: making the program thread-safe, making it localizable, …</li></ul><div><br/></div><div><span style="font-weight: bold;">Keep Coupling Loose</span></div><div><ul><li>Here are several criteria to use in evaluating coupling between modules</li><ul><li><span style="font-style: italic; text-decoration: underline;">Size</span>. Refers to the number of connections between modules.</li><li><span style="font-style: italic; text-decoration: underline;">Visibility</span>. Visibility referes to the prominence of the connection between two modules. If connections must exist they should be salient and obvious.</li><li><span style="font-style: italic; text-decoration: underline;">Flexibility</span>. Refers to how easily you can change the connections between modules. The more easily other modules can call a module, the more loosely coupled it is, and that’s good because it’s more maintainable and flexible.</li></ul><li>Kinds of coupling:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Simple data-parameter coupling</span>. Two modules are coupled in this way if all parameters passed between them are of primitive type and all data is passed by means of parameter lists. This kind of coupling is normal and acceptable.</li><li><span style="font-style: italic; text-decoration: underline;">Simple object coupling</span>.A module is simple-object coupled to an object if it instantiates that object. This kind of coupling is OK.</li><li><span style="font-style: italic; text-decoration: underline;">Object-parameter coupling</span>. Two objects are object-parameter coupled if Object1 requires Object2 to pass it Object3. This is tighter than having Object2 just pass primitive data types because it requires Object2 to know about Object3.</li><li><span style="font-style: italic; text-decoration: underline;">Semantic coupling</span>. One module makes use not of some syntactic element of another module but of some semantic knowledge of the other module’s inner workings.</li><ul><li>Dangerous because changing code in the used module changes behavior of the using module indirectly, which makes debugging very hard.</li></ul></ul><li>Classes and routines are first and foremost intellectual tools for reducing complexity. If they’re not making your life simpler they’re not doing their job.</li></ul><div><br/></div><div><span style="font-weight: bold;">Look for Common Design Patterns</span></div><div><ul><li>The book <span style="font-style: italic; text-decoration: underline;">Design Patterns (1995) is the definitive description of design patterns.</span></li><li>Benefits of pattern designs that fully custom design doesn’t have:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Patterns reduce complexity by providing ready-made abstractions</span>. Programmers will understand better what you mean when you implement your solutions through well known patterns.</li><li><span style="font-style: italic; text-decoration: underline;">Patterns reduce errors by institutionalizing details of common solutions</span>. Patterns embody the wisdom accumulated from years of attempting to solve those problems, and they also embody the corrections to the false attempts that people have made in solving those problems. Using design patterns is this conceptually similar to using library code instead of writing your own.</li><li><span style="font-style: italic; text-decoration: underline;">Patterns provide heuristic value by suggesting design alternatives</span>. A designer who is familiar with common patterns can easily run through a list of patterns and ask “Which of these patterns fits my design problem?”</li><li><span style="font-style: italic; text-decoration: underline;">Patterns streamline communication by moving the design dialog to a higher level</span>.The vocabulary of a specific pattern helps developers communicate between each other.</li></ul><li>Assigning specific names and concepts to already known design patterns is a valuable tool in itself.</li><li>A possible trap of using patterns:</li><ul><li>Forcing a solution to fit a pattern when it can’t</li><li>Using patterns just to try them out rather than picking an appropriate one</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Other Heuristics</span></div></div></div></div></div></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Aim for strong cohesion.</span></li><ul><li>Cohesion refers to how closely all the routines in a class or all the code in a routine support a central purpose</li><li>Important because the more that code in a class supports a central purpose, the more easily your brain can remember everything the code does.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Build hierarchies of abstraction</span></li><ul><li>Hierarchies were an important tool for managing complex sets of information for at least 2000 years.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Formalize contracts between communicating classes.</span></li><li><span style="font-style: italic; text-decoration: underline;">Assign responsibilities.</span> This means thinking about how responsibilities should be assigned to objects.</li><li><span style="font-style: italic; text-decoration: underline;">Design for test.</span> Think about what the system should look like to make testing it as easy as possible.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid Failure.</span> <span style="font-style: italic;">Design Paradigms: Case Histories of Error and Judgment in Engineering (Petroski 1994)</span> chronicles the history of failure in bridge design. Argues many bridge failures have occurred because of focusing on previous successes and not adequately considering possible failure modes.</li><ul><li>Focus on how your design may fail, don’t just copy other successful designs.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Choose binding time consciously</span>. Code that binds early tends to be simpler, but it also tends to be less flexible.</li><li><span style="font-style: italic; text-decoration: underline;">Make Central Points of Control</span>.</li><ul><li>The principle of One Right Place: There should be One Right Place to look for any nontrivial piece of code, and One Right Place to make a likely maintenance change.</li><li>So, centralize control</li></ul><li><span style="font-style: italic; text-decoration: underline;">Consider using brute force</span>.</li><ul><li>A brute force solution that works is better than an elegant solution that doesn’t work.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Draw a Diagram</span></li><ul><li>A picture is worth 1000 words — kind of.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Keep design modular</span>. </li></ul><div><br/></div></div><div><span style="font-weight: bold;">Design Practices</span></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Iterate</span>.</li><ul><li>Design is an iterative process.</li><li>Many people have trouble ranging between high level and low-level considerations.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Divide and conquer</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Top-Down and Bottom-Up Design Approaches</span>.</li><ul><li>Top-down design begins at a high level of abstraction</li><li>Bottom-up design starts with specifics and works toward generalities</li><li>Arguments for top down</li><ul><li>Human mind can concentrate on only so much detail at a time</li></ul><li>Arguments for bottom up</li><ul><li>The top down approach might be to abstract to even get started, if you need something more tangible, try bottom up</li><li>Good for early identification of utility functions</li></ul><li>Things to keep in mind if you take the bottom up approach</li><ul><li>Ask yourself what you know the system needs to do</li><li>Identify concrete objects and responsibilities from that question</li><li>Identify common objects, and group them using subsystem organization, packages, composition within objects, or inheritance</li><li>Continue with the next level up, or go back to the top and try to work your way back down</li></ul></ul></ul><div><ul><li><span style="font-style: italic; text-decoration: underline;">Experimental Prototyping</span>.</li><ul><li>Sometimes you cannot know if a design will work until you better understand some implementation detail.</li><li>To address these issues, employ experimental prototyping</li><li>Prototyping works poorly when developers aren’t disciplined about writing the <span style="font-style: italic; text-decoration: underline;">absolute minimum</span> of code needed to answer a question</li><li>Prototyping also works poorly when the design question is not <span style="font-style: italic; text-decoration: underline;">specific</span> enough.</li><li>Prototyping code must be treated as <span style="font-style: italic; text-decoration: underline;">throwaway code</span>. One way to achieve this is to write prototypes in a completely different framework/language than the one used for the whole system.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Collaborative Design</span>.</li><ul><li>Two heads are often better than one. Forms of collaboration:</li><ul><li>Informally walk over to a co-worker and ask to bounce some ideas around</li><li>You and your co-worker sit together in a conference room and draw design alternatives on a whiteboard</li><li>You and your co-worker sit together at the keyboard and do detailed design in the programming language you’re using (i.e. pair programming)</li><li>You schedule a meeting to walk through your design ideas with one or more co-workers.</li><li>You schedule a formal inspection</li><li>Do some work, put it into a drawer, and consult yourself a week later about your work.</li><li>You ask someone outside your company for help: send questions to a specialized forum or newsgroup.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">How much design is enough?</span></li><ul><li>Depends on the experience of the team, expected lifetime of the system, desired level of reliability, and size of project and team</li><li>If I can’t decide how deeply to investigate a design before I begin coding, I tend to err on the side of going into more detail.</li><li>I rarely encounter projects that are suffering from having done too much design work</li><li>On the other hand, I have seen projects that are suffering from too much design documentation. Polished documentation is not paramount for design itself.</li></ul><li>Aside from capturing design work in a formal document, you can capture designs in numerous alternative ways:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Insert design documentation into the code itself</span>. Document key design decisions in code comments, typically in class and file headers. Improves the chance programmers will keep the design documentation reasonably up to date.</li><li><span style="font-style: italic; text-decoration: underline;">Capture design discussions and decisions on a Wiki</span>. Have your design discussion in writing, on a project Wiki. Supplement text with pictures.</li><li><span style="font-style: italic; text-decoration: underline;">Write email summaries</span>. After a design discussion, adopt the practice of designating someone to write a summary of the discussion— especially what was decided— and send it to the project team. Archive a copy in the project’s public e-mail folder.</li><li><span style="font-style: italic; text-decoration: underline;">Use a digital camera</span>. Taking pictures of whiteboard drawings and embedding them into traditional documents can be a low-effort way to get 80 percent of the benefit of saving design drawings.</li><li><span style="font-style: italic; text-decoration: underline;">Save design flip charts</span>. The documentation need not only be set in letter paper.</li><li><span style="font-style: italic; text-decoration: underline;">Use CRC (Class, Responsibility, Collaborator) cards</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Create UML diagrams at appropriate levels of detail</span>.</li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Comments on Popular Methodologies</span></div><div><ul><li>The more dogmatic you are about applying a design method, the fewer real-life problems you are going to solve.</li></ul><div><br/></div><div><hr/><div><span style="font-weight: bold;">McConnell: Chapter 6 — Working Classes</span></div><hr/></div></div></div></div></div></div></div><div><ul><li>Classes are a primary tool for complexity management.</li></ul><div><span style="font-weight: bold;">Class Foundations: Abstract Data Types (ADTs)</span></div></div><div><ul><li>An abstract data type is a collection of data and operations that work on that data.</li><li>Benefits of using ADTs:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Hiding implementation details</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Changes don’t affect the whole program</span>.</li><li><span style="font-style: italic; text-decoration: underline;">You can make the interface more informative</span>.</li><li><span style="font-style: italic; text-decoration: underline;">It’s easier to improve performance</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The program is more obviously correct</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The program becomes more self documenting</span>.</li><li><span style="font-style: italic; text-decoration: underline;">You don’t have to pass data all over your program</span>.</li><li><span style="font-style: italic; text-decoration: underline;">You’re able to work with real-world entities rather than with low-level implementation structures</span>.</li></ul><li>Try to make the names of classes and access routines independent of how the data is stored, and refer to the abstract data type instead.</li><li>Good class interfaces:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Present a consistent level of abstraction in the class interface</span>. </li><ul><li>Each class should implement one and only one ADT</li><li>If you use inheritance, make sure the child class satisfies the “is a” relationship with the parent</li></ul><li><span style="font-style: italic; text-decoration: underline;">Be sure you understand what abstraction the class is implementing</span>. When you have to choose between two similar abstractions, make sure you choose the right one.</li><li><span style="font-style: italic; text-decoration: underline;">Provide services in paris with their opposites</span>. If you have an operation that turns a light on, you will probably want one that turns it off. Check each public routine to determine if you need its complement.</li><li><span style="font-style: italic; text-decoration: underline;">Move unrelated information to another class</span>. If half of the class’s routines work with half the class’s data and half with the other data, then separate the class into two distinct classes.</li><li><span style="font-style: italic; text-decoration: underline;">Make interfaces programmatic rather than semantic when possible</span>. Each interface has a programmatic part and a semantic part.</li><ul><li>Programmatic part consists of the data types and other attributes of the interface that can be enforced by the compiler</li><li>Semantic part of the interface consists of the assumptions about how the interface will be used, which cannot be enforced by the compiler.</li><ul><li>The semantic part must be clearly documented, but interfaces should be minimally dependent on documentation.</li><li>Better apply compile-time checkable solutions to semantic parts like assertions or other techniques.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Beware of erosion of the interface’s abstraction under modification</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t add public members that are inconsistent with the interface abstraction</span>. Each time you add a routine to a class interface ask “Is this routine consistent with the abstraction provided by the existing interface?”</li><li><span style="font-style: italic; text-decoration: underline;">Consider abstraction and cohesion together</span>. These two concepts are related.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Good Encapsulation</span></div></div><div><ul><li><span style="font-style: italic; text-decoration: underline;">Minimize accessibility of classes and members</span>. Favor the strictest level of privacy that still works. If exposing the routine is consistent with the abstraction, however, it’s probably fine to expose it.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t expose member data in public</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid putting private implementation details into a class’s interface</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t make assumptions about the class’s users</span>. You cannot make the assumption about how your interface will or will not be used.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid friend classes</span>. They violate the principle of encapsulation.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t put a routine into the public interface just because it uses only public routines</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Favor read-time convenience to write-time convenience</span>. Code is read more than it is written.</li><li><span style="font-style: italic; text-decoration: underline;">Be very, very wary of semantic violations of encapsulation</span>. </li><ul><li>Here are some examples of how encapsulation can be broken semantically:</li><ul><li>Not calling Class A’s InitializeOperations() routine because you know that Class A’s PerformFirstOperation() routine calls it automatically</li><li>Not calling the database.Connect() routine before you call employee.Retrieve(database) because you know that the employee.Retreive() function will connect to the database if there isn’ already a connection</li><li>Using Class B’s MAXIMUM_ELEMENTS constant instead of using ClassA.MAXIMUM_ELEMENTS, because you know that they’re both equal to the same value.</li></ul><li>The problem with each of these examples is that they make the client code dependent on implementation specifics that are not part of the interface.</li><li>If you don’t understand somebody’s interface, ask them about it and make no assumptions outside the interface. Consequently, the implementor of the interface should not respond to you directly but change documentation/interface and ask if you can understand the interface after the changes. If this is not done, there will be semantical assumptions in your use of the interface by definition.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Watch for coupling that is too tight</span>. </li><ul><li>Minimize accessibility of classes and members</li><li>Avoid friend classes</li><li>Make data private rather than protected in a base class to make derived classes less tightly coupled to the base class</li><li>Avoid exposing member data in a class’s public interface</li><li>Be wary of semantic violations of encapsulation</li><li>Observe the <span style="font-style: italic;">Law of Demeter</span></li></ul></ul><div><br/></div></div><div><span style="font-weight: bold;">Design and Implementation Issues</span></div><div><ul><li>This section discusses issues related to containment, inheritance, member functions and data, class coupling, constructors, and value-vs.-reference objects.</li><li><span style="font-style: italic; text-decoration: underline;">Containment (“has a” relationship)</span></li><ul><li>The idea that a class contains a primitive data element or object. Containment, not inheritance, is the work-horse technique in object-oriented programming</li><li>People mention inheritance more only because it is more error-prone</li><li><span style="font-style: italic; text-decoration: underline;">Implement “has a” through containment</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Implement “has a” through private inheritance as a last resort</span>. This way the containing class is able to access protected member functions or data of the class that’s contained. This usually tends to point to design errors that should be resolved, though.</li><li><span style="font-style: italic; text-decoration: underline;">Be critical of classes that contain more than about 7 data members</span>. If a class contains more than 7 members, it is hard for programmers to keep track of all the internal variables successfully.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Inheritance (“is a” relationship)</span>.</li><ul><li>Inheritance is the idea that one class is the specialization of another.</li><li>Inheritance helps avoid the need to repeat code and data in multiple locations by centralizing it within a base class.</li><li>Decisions you have to make before using inheritance:</li><ul><li>For each member routine, will the routine be visible to derived classes? Will it have a default implementation? Will the default implementation be overridable?</li><li>For each data member, will the data ember be visible to derived classes?</li></ul><li><span style="font-style: italic; text-decoration: underline;">Implement “is a” through public inheritance</span>. If the derived class is not going to adhere completely to the same interface contract defined by the base class, inheritance is not the right implementation technique. Consider containment or making a change further up the inheritance hierarchy.</li><li><span style="font-style: italic; text-decoration: underline;">Design and document for inheritance or prohibit it</span>.  Inheritance adds complexity to a program, and, as such, it’s a dangerous technique. If a class isn’t designed to be inherited from, make its members non-virtual in C++, final in Java.</li><li><span style="font-style: italic; text-decoration: underline;">Adhere to the Leskov Substitution Principle (LSP)</span>. You shouldn’t inherit from a base class unless the derived class truly “is a” more specific version of the base class. Subclasses must be usable through the base class interface without the need for the user to know the difference, i.e. all the routines defined in the base class should mean the same thing when they’re used in each of the derived classes.</li><li><span style="font-style: italic; text-decoration: underline;">Be sure to inherit only what you want to inherit</span>. Three flavors of inherited routines:</li><ul><li><span style="text-decoration: underline;">An abstract overridable routine</span>. Means the derived class inherits the routine’s interface but not its implementation.</li><li><span style="text-decoration: underline;">An overridable routine</span>. means that the derived class inherits the routine’s interface and a default implementation and it is allowed to override the default implementation.</li><li><span style="text-decoration: underline;">A non-overridable routine</span>. Means that the derived class inherits the routine and it’s default implementation without being able to override it.</li><li>If you want to use a class’s implementation but not its interface, use containment rather than inheritance.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Don’t “override” a non-overridable member function</span>. Don’t reuse names of non-overridable base-class routines in derived classes.</li><li><span style="font-style: italic; text-decoration: underline;">Move common interfaces, data, and behavior as high as possible in the inheritance tree</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Be suspicious of class of which there is only one instance</span>. A single instance might indicate that the design confuses objects for classes. Consider if you could just create a new object rather than a distance class.</li><li><span style="font-style: italic; text-decoration: underline;">Be suspicious of base classes of which there is only one derived class</span>. The best way to prepare for future work is not to design extra layers of base classes that <span style="font-style: italic;">might be needed some day</span>. That means not creating any more inheritance structure than is absolutely necessary.</li><li><span style="font-style: italic; text-decoration: underline;">Be suspicious of classes that override a routine and do nothing inside the derived routine</span>.This typically indicates an error in the design of the base class. Issues with overriding routines by having them do nothing:</li><ul><li>It violates the interface contract provided by the base class by changing its semantics</li><li>This approach quickly gets out of control when you extend it to other derived classes.</li><li>Hard to maintain because base class implies nothing about the behavior of derived classes.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Avoid deep inheritance trees</span>. In practice, most people have trouble juggling more than two or three levels of inheritance in their brains at once. Deep inheritance trees are proven to increase fault rates.</li><li><span style="font-style: italic; text-decoration: underline;">Prefer polymorphism to extensive type checking</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Make all data private, not protected</span>.</li></ul><li>Always remember that inheritance tends to work against the primary technical imperative you have as a programmer, which is to manage complexity.</li><li>When to use inheritance vs. when to use containment?</li><ul><li>If multiple classes share common data, but not behavior, create a common object that those classes can contain</li><li>If multiple classes share common behavior but not data, derive them from a common base class that defines the common routines.</li><li>If multiple classes share common data and behavior, inherit from a common base class that defines the common data and routines</li><li>inherit when you want the base class to control your interface; contain when you want to control your interface.</li></ul><li>Member functions and data. Guidelines for implementing member functions and data effectively:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Keep number of routines in class as small as possible</span>. More class routines are associated with higher fault rate.</li><li><span style="font-style: italic; text-decoration: underline;">Disallow implicitly generated member functions and operators you don’t want</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Minimize the number of different routines called by a class</span>. Again, number of faults correlates.</li><li><span style="font-style: italic; text-decoration: underline;">Minimize indirect routine calls to other classes</span>. using account.ContactPerson().DaytimeContactInfo() is a coding horror!</li><ul><li><span style="font-style: italic; text-decoration: underline;">Law of Demeter</span>: If object A instantiates an object B, it can call any of object B’s routines. But it should avoid calling routines on objects provided by object B.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Minimize the extent to which a class collaborates with other classes</span>. Minimize the following:</li><ul><li>Number of kinds of objects instantiated</li><li>Number of different direct routine calls on instantiated objects</li><li>Number of routine calls on objects returned by other instantiated objectects</li></ul></ul><li>Constructor guidelines:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Initialize all member data in all constructors, if possible</span>. Initialize all data members in all constructors is an inexpensive defensive programming practice.</li><li><span style="font-style: italic; text-decoration: underline;">Enforce the singleton property by using a private constructor</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Prefer deep copies to shallow copies until proven otherwise</span>. Deep copies rarely cause measurable performance impacts, and programmers are notoriously bad at predicting which types of objects might cause problems with deep copies.</li></ul><li>Reasons to create a class:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Model real-world objects</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Model abstract objects</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Reduce complexity</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Isolate complexity</span>. When an error inevitably arises, it will be easier to find if it isn’t spread through the code but is localized within a class.</li><li><span style="font-style: italic; text-decoration: underline;">Hide implementation details</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Limit effects of changes</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Hide global data</span>. If you need to use global data, you can hide its implementation details behind a class interface.</li><li><span style="font-style: italic; text-decoration: underline;">Streamline parameter passing</span>. If you are passing a parameter among several routines that might indicate a need to factor those routines into a class that share the parameter as object data.</li><li><span style="font-style: italic; text-decoration: underline;">Make central points of control</span>. It’s a good idea to control each task in one place. Using one class to read from and write to a database is a form of centralized control.</li><li><span style="font-style: italic; text-decoration: underline;">Facilitate reusable code</span>. Code put into well-factored classes can be reused in other programs more easily than the same code embedded in one larger class.</li><li><span style="font-style: italic; text-decoration: underline;">Plan for a family of programs</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Packaging related operations</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Accomplish a specific refactoring</span>.</li></ul><li>Classes to avoid</li><ul><li><span style="font-style: italic; text-decoration: underline;">Avoid creating god classes</span><span style="font-style: italic;">. </span>Avoid creating omniscient classes that are all-powerful and constantly query other classes’ Get() and Set() routines.</li><li><span style="font-style: italic; text-decoration: underline;">Eliminate irrelevant classes</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid classes named after verbs</span>. Classes that only contain behavior and no data are really routines that should be refactored into other classes.</li></ul><li>Class-related areas that vary significantly depending on language:</li><ul><li>Behavior of overridden constructors and destructors in an inheritance tree</li><li>Behavior of constructors and destructors under exception-handling conditions</li><li>Importance of default constructors</li><li>Time at which a destructor is called</li><li>Wisdom of overriding the language’s built-in operators, including assignment and equality</li><li>How memory is handled as objects are created and destroyed or as they go out of scope</li></ul><li>Beyond Classes: Packages</li><ul><li>Modularity can be implemented in packages, not only classes</li><li>It was evident that we could better support the goals of abstraction and encapsulation if we had good tools for aggregating groups of objects.</li></ul></ul></div><div><br/></div></body></html>