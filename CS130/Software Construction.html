<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:33:08 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:35:24 +0000"/><title>Software Construction</title></head><body><div/><div><span style="font-weight: bold;">McConnell: Chapter 4 — Key Construction Decisions</span></div><hr/><ul><li>This chapter focuses on preparations that individual programmers and technical leads are responsible for.</li></ul><div><br/></div><div><span style="font-weight: bold;">Choice of Programming Language</span></div><ul><li>The Sapri-Whorf hypothesis says that your ability to think a thought depends on knowing words capable of expressing the thought. If you don’t know the words, you can’t express the thought and you might not even be able to formulate it.</li></ul><div><br/></div><div><span style="font-weight: bold;">Programming Conventions</span></div><ul><li>In a complex program, architectural guidelines give the program structural balance and construction guidelines provide low-level harmony, articulating each class as a faithful part of a comprehensive design.</li><li>Without a unifying discipline, your creation will be a jumble of sloppy variations in style.</li><li>Before construction begins, spell out the programming conventions you’ll use.</li><li>How you spend your programming days will depend on where you are on the technology wave:</li><ul><li>If you are in the late part of the wave, you can plan to spend most of your day steadily writing new functionalities</li><li>If you are in the early part of the wave, you will spend a sizable amount of your time trying to figure out your programming language’s undocumented features and debugging errors in library code.</li></ul><li>Programmers who program “into” a language first decide what thoughts they want to express, and then they determine how to express those thoughts using the tools provided by the specific language.</li><li>If your language lacks constructs that you want to use or is prone to other kinds of problems, try to compensate for them. Invent your own coding conventions and standards.</li></ul><div><br/></div><div><span style="font-weight: bold;">Selection of Major Construction Practices</span></div><ul><li>Need to choose which good practices you will emphasize for the current project</li><li>Major construction practices</li><ul><li>Coding</li><ul><li>Define how much design will be done up front and how much will be done at the keyboard</li><li>Define coding conventions for names, comments, and layouts</li><li>Define specific coding practices that are implied by the architecture, how will error conditions be handled, how security will be addressed, what conventions will be used for class interfaces, what standards will apply to reused code, how much to consider performance while coding…</li><li>Identify which part of the technology wave you are on</li></ul><li>Teamwork</li><ul><li>Define the integration procedure, i.e. what must be done before checking the code into the master sources</li><li>Define if pair programming should be used</li></ul><li>Quality Assurance</li><ul><li>Define if programmers should write test cases for their code before writing the code</li><li>Define if programmers should write unit test for their code</li><li>Define if programmers should step through their code in the debugger before committing it</li><li>Define if programmers should integration test their code before a commit</li></ul><li>Tools</li><ul><li>Define the revision control tool</li><li>Define the language, version, and compiler to be used</li><li>Define a framework such as J2EE or .NET or explicitly decide not to use any</li><li>Define if use of non-standard language features is allowed</li><li>Define which editors, refactoring tools, debuggers, test frameworks, syntax checkers will be used</li></ul></ul></ul><div><hr/></div><div/><div><span style="font-weight: bold;">McConnell: Chapter 5 — Design in Construction</span></div><hr/><ul><li>Design is the activity that links requirements to coding and debugging</li><li>Software engineering in the real is a problem that can only be specified once the whole or part of the solution is implemented.</li><li>Design process is characterized by many dead-allies you encounter on the road to specifying a functional design</li><li>Making mistakes is the point of design; a good solution is often only subtly different from a poor one</li><li>Design is about tradeoffs and priorities</li><li>Design involves specifying restrictions required to effectively solve a problem given the resources available</li><li>Design provides a heuristic</li><li>Design is emergent</li></ul><div><br/></div><div><span style="font-weight: bold;">Key design concepts</span></div><ul><li>Software’s primary technical imperative is managing complexity. Read “No Silver Bullets: Essence and Accidents of Software Engineering”</li><li>Importance of managing complexity:</li><ul><li>When projects fail for reasons that are primarily technical, the reason is often uncontrolled complexity.</li><li>Managing complexity is the most important technical topic  in software development</li></ul><li>Due to the unmanageable amount of complexity in each program, we as software developers shouldn’t try to cram whole programs in our brains at once; instead we should organize the programs in such a way that we can safely focus on one part of it at a time.</li><li>The goal is to minimize the amount of a program you have to think about at any one time.</li><li>Carefully defined objects separate concerns so that you can focus on one thing at a time.</li></ul><div><br/></div><div><span style="font-weight: bold;">How to Attack Complexity</span></div><ul><li>Causes of overly costly, ineffective designs:</li><ul><li>A complex solution to a simple problem</li><li>A simple, incorrect solution to a complex problem</li><li>An inappropriate, complex solution to a complex problem</li></ul><li>Two approaches to managing complexity:</li><ul><li>minimize the amount of essential complexity that anyone’s brain has to deal with at any one time</li><li>Keep accidental complexity from needlessly proliferating</li></ul><li>Once you understand that all other technical goals in software are secondary to managing complexity, many design considerations become straightforward</li></ul><div><br/></div><div><span style="font-weight: bold;">Desirable Characteristics of a Design</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Minimal complexity</span>. The primary goal of design should be to minimize complexity. Simple and easy-to-understand is more important than clever.</li><li><span style="font-style: italic; text-decoration: underline;">Ease of maintenance</span>. Think of the maintenance programmer as your audience.</li><li><span style="font-style: italic; text-decoration: underline;">Loose coupling</span>. Hold connections among different parts of a program to a minimum.</li><li><span style="font-style: italic; text-decoration: underline;">Extensibility</span>. Extensibility means that you can enhance a system without affecting other pieces.</li><li><span style="font-style: italic; text-decoration: underline;">Reusability</span>. </li><li><span style="font-style: italic; text-decoration: underline;">High fan-in</span>. Refers to having a high number of classes that use a given class. High fan-in implies that a system has been designed to make good use of utility classes at the lower levels in the system.</li><li><span style="font-style: italic; text-decoration: underline;">Low-to-medium fan-out</span>. Have any given class use a low-to-medium number of other classes.</li><li><span style="font-style: italic; text-decoration: underline;">Portability</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Leanness</span>. Design system so that it has no extra parts.</li><li><span style="font-style: italic; text-decoration: underline;">Stratification</span>. Software layering.</li><li><span style="font-style: italic; text-decoration: underline;">Standard techniques</span>. Use standardized and common approaches to your design so that they can be easily explained to other developers.</li></ul><div><br/></div><div><span style="font-weight: bold;">Levels of Design</span></div><ul><li>Levels at which design should be described include:</li><ul><li>Software system level</li><li>Division into subsystems/packages. Be sure to explicitly restrict communication between subsystems. Without any restriction, each subsystem will end up talking to each other subsystem and it would all grow into a big mess. There better be a good reason for initiating communication between two subsystems. Easier to restrict communication early and relax it later. Why restricting communication is important:</li><ul><li>How many different parts of the system does a developer need to understand at least a little bit to change something in the graphics subsystem?</li><li>What happens if you try to use the business rules in another system?</li><li>What happens when you want to put a new UI on the system, perhaps a command-line UI for testing?</li><li>What happens when you want to put data storage on a remote machine?</li><li>The communication graph between subsystems should be an Acyclic Graph</li><li>The simplest communication connection is having one subsystem call routines from another</li><li>A more involved relationship is to have one subsystem contain classes from another</li><li>The most involved relationship is to have classes in one subsystem inherit from classes in another.</li></ul><li>Division into classes within packages</li><li>Division into data and routines within classes</li><li>Internal routine design</li></ul><li>Commonly encountered subsystems:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Business rules</span>. These are the laws, regulations, policies, and procedures that you encode into a computer system.</li><li><span style="font-style: italic; text-decoration: underline;">User interface</span>. Create a subsystem to isolate user-interface components so that the user interface can evolve without damaging the rest of the program.</li><li><span style="font-style: italic; text-decoration: underline;">Database access</span>. You should hide the implementation details of accessing a database so that most of the program doesn’t need to worry about the messy details of manipulating low-level structures and can deal with the data in terms of how it’s used at the business-problem level.</li><li><span style="font-style: italic; text-decoration: underline;">System dependencies</span>. Package operating-system dependencies into a subsystem for the same reason you package hardware dependencies.</li></ul><li>The major design activity at the level of division into classes is to make sure that all the subsystems have been decomposed to a level of detail fine enough that you can implement their parts as individual classes.</li><li>The internal routine design is always done by necessity, though sometimes it’s done unconsciously and poorly rather than consciously and well.</li></ul><div><br/></div><div><span style="font-weight: bold;">Design Building Blocks: Heuristics</span></div><ul><li>The primary purpose of the following heuristics is to help manage complexity</li><li><span style="font-style: italic; text-decoration: underline;">Find Real-World Objects</span>.</li><ul><li>Identify the objects and their attributes</li><li>Determine what can be done to each object</li><li>Determine what each object is allowed to do to other objects</li><li>Determine the parts of each object that will be visible to other objects</li><li>Define each object’s public interface</li></ul><li>Possible barriers to information hiding:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Excessive distribution of information</span>. Centralized information makes information hiding a lot easier.</li><li><span style="font-style: italic; text-decoration: underline;">Circular dependencies</span>. As when a routine in class A calls a routine in class B, and a routine in class B calls a routine in class A. These also make a system hard to test because you can’t test either A or B until at least part of the other is ready.</li><li><span style="font-style: italic; text-decoration: underline;">Class data mistaken for global data</span>. While the road to programming hell is paved with global variables, class data presents far fewer risks. Two problems of global data:</li><ul><li>Routines operate on global data without knowing that other routines are operating on it</li><li>Routines are aware that other routines are operating on the global data but they don’t know exactly what they’re doing to it.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Perceived performance penalties</span>.The concern is that accessing data items indirectly incurs run-time performance penalties for additional levels of object intentions, routine class, and so on. However, at the point of design, this concern is premature. Until you can measure system performance and pinpoint specific bottlenecks, the best way to prepare for code-level performance work is to create a highly modular design.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Value of Information Hiding</span></div><ul><li>Information hiding is one of the few theoretical techniques that has indisputably proven its value in practice.</li><li>Information hiding is part of the foundation of both structured design and object-oriented design.</li><li>Information hiding inspires and promotes design devisions that thinking about objects does not.</li><li>Asking about what needs to be hidden supports good design decisions at all levels</li></ul><div><br/></div><div><span style="font-weight: bold;">Identify Areas Likely to Change</span></div><ul><li>Accommodating changes is one of the most challenging aspects of good program design</li><li>The goal is to isolate unstable areas so that the effect of a change will be limited to one routine, class or package.</li><ul><li><span style="font-style: italic; text-decoration: underline;">Identify items that seem likely to change</span>. If the requirements are done well, this step should be straightforward.</li><li><span style="font-style: italic; text-decoration: underline;">Separate items that are likely to change</span>. Compartmentalize each volatile component identified in step 1.</li><li><span style="font-style: italic; text-decoration: underline;">Isolate items that seem likely to change</span>. Design the interclass interfaces to be insensitive to the potential changes.</li><li><span style="font-style: italic; text-decoration: underline;">Business rules</span>. Business rules tend to be the source of frequent software changes.</li><li><span style="font-style: italic; text-decoration: underline;">Hardware dependencies</span>. Important for moving the program to a new environment.</li><li><span style="font-style: italic; text-decoration: underline;">Input and output</span>. Input/output tends to be a volatile area. In general, it is good to examine all external interfaces for possible changes.</li><li><span style="font-style: italic; text-decoration: underline;">Nonstandard language features</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Difficult design and construction areas</span>. It’s a good idea to hide difficult design and construction areas because they might be done poorly and you might need to do them again.</li><li><span style="font-style: italic; text-decoration: underline;">Status variables</span>. Status variables indicate the state of a program and tend to be changed more frequently. Adding flexibility to status variables includes:</li><ul><li>Don’t use a boolean variable as a status variable. Use an enumerated type so that you can add more sophisticated state detection later.</li><li>Use access routines rather than checking the variables directly. This also allows for more sophisticated state detection.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Data size constraints</span>. When you declare an array of size 100, you’re exposing information to the world that the world doesn’t need to see. Use a layer of indirection by declaring a constant like MAX_EMPLOYEES and set it to 100.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Anticipating Different Degrees of Change</span></div><ul><li>Only extremely unlikely changes should be allowed to have drastic consequences for more than one class in a system.</li><li>Consider qualitative changes as well: making the program thread-safe, making it localizable, …</li></ul><div><br/></div><div><span style="font-weight: bold;">Keep Coupling Loose</span></div><ul><li>Here are several criteria to use in evaluating coupling between modules</li><ul><li><span style="font-style: italic; text-decoration: underline;">Size</span>. Refers to the number of connections between modules.</li><li><span style="font-style: italic; text-decoration: underline;">Visibility</span>. Visibility referes to the prominence of the connection between two modules. If connections must exist they should be salient and obvious.</li><li><span style="font-style: italic; text-decoration: underline;">Flexibility</span>. Refers to how easily you can change the connections between modules. The more easily other modules can call a module, the more loosely coupled it is, and that’s good because it’s more maintainable and flexible.</li></ul><li>Kinds of coupling:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Simple data-parameter coupling</span>. Two modules are coupled in this way if all parameters passed between them are of primitive type and all data is passed by means of parameter lists. This kind of coupling is normal and acceptable.</li><li><span style="font-style: italic; text-decoration: underline;">Simple object coupling</span>.A module is simple-object coupled to an object if it instantiates that object. This kind of coupling is OK.</li><li><span style="font-style: italic; text-decoration: underline;">Object-parameter coupling</span>. Two objects are object-parameter coupled if Object1 requires Object2 to pass it Object3. This is tighter than having Object2 just pass primitive data types because it requires Object2 to know about Object3.</li><li><span style="font-style: italic; text-decoration: underline;">Semantic coupling</span>. One module makes use not of some syntactic element of another module but of some semantic knowledge of the other module’s inner workings.</li><ul><li>Dangerous because changing code in the used module changes behavior of the using module indirectly, which makes debugging very hard.</li></ul></ul><li>Classes and routines are first and foremost intellectual tools for reducing complexity. If they’re not making your life simpler they’re not doing their job.</li></ul><div><br/></div><div><span style="font-weight: bold;">Look for Common Design Patterns</span></div><ul><li>The book <span style="font-style: italic; text-decoration: underline;">Design Patterns (1995) is the definitive description of design patterns.</span></li><li>Benefits of pattern designs that fully custom design doesn’t have:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Patterns reduce complexity by providing ready-made abstractions</span>. Programmers will understand better what you mean when you implement your solutions through well known patterns.</li><li><span style="font-style: italic; text-decoration: underline;">Patterns reduce errors by institutionalizing details of common solutions</span>. Patterns embody the wisdom accumulated from years of attempting to solve those problems, and they also embody the corrections to the false attempts that people have made in solving those problems. Using design patterns is this conceptually similar to using library code instead of writing your own.</li><li><span style="font-style: italic; text-decoration: underline;">Patterns provide heuristic value by suggesting design alternatives</span>. A designer who is familiar with common patterns can easily run through a list of patterns and ask “Which of these patterns fits my design problem?”</li><li><span style="font-style: italic; text-decoration: underline;">Patterns streamline communication by moving the design dialog to a higher level</span>.The vocabulary of a specific pattern helps developers communicate between each other.</li></ul><li>Assigning specific names and concepts to already known design patterns is a valuable tool in itself.</li><li>A possible trap of using patterns:</li><ul><li>Forcing a solution to fit a pattern when it can’t</li><li>Using patterns just to try them out rather than picking an appropriate one</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Other Heuristics</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Aim for strong cohesion.</span></li><ul><li>Cohesion refers to how closely all the routines in a class or all the code in a routine support a central purpose</li><li>Important because the more that code in a class supports a central purpose, the more easily your brain can remember everything the code does.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Build hierarchies of abstraction</span></li><ul><li>Hierarchies were an important tool for managing complex sets of information for at least 2000 years.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Formalize contracts between communicating classes.</span></li><li><span style="font-style: italic; text-decoration: underline;">Assign responsibilities.</span> This means thinking about how responsibilities should be assigned to objects.</li><li><span style="font-style: italic; text-decoration: underline;">Design for test.</span> Think about what the system should look like to make testing it as easy as possible.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid Failure.</span> <span style="font-style: italic;">Design Paradigms: Case Histories of Error and Judgment in Engineering (Petroski 1994)</span> chronicles the history of failure in bridge design. Argues many bridge failures have occurred because of focusing on previous successes and not adequately considering possible failure modes.</li><ul><li>Focus on how your design may fail, don’t just copy other successful designs.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Choose binding time consciously</span>. Code that binds early tends to be simpler, but it also tends to be less flexible.</li><li><span style="font-style: italic; text-decoration: underline;">Make Central Points of Control</span>.</li><ul><li>The principle of One Right Place: There should be One Right Place to look for any nontrivial piece of code, and One Right Place to make a likely maintenance change.</li><li>So, centralize control</li></ul><li><span style="font-style: italic; text-decoration: underline;">Consider using brute force</span>.</li><ul><li>A brute force solution that works is better than an elegant solution that doesn’t work.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Draw a Diagram</span></li><ul><li>A picture is worth 1000 words — kind of.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Keep design modular</span>. </li></ul><div><br/></div><div><span style="font-weight: bold;">Design Practices</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Iterate</span>.</li><ul><li>Design is an iterative process.</li><li>Many people have trouble ranging between high level and low-level considerations.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Divide and conquer</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Top-Down and Bottom-Up Design Approaches</span>.</li><ul><li>Top-down design begins at a high level of abstraction</li><li>Bottom-up design starts with specifics and works toward generalities</li><li>Arguments for top down</li><ul><li>Human mind can concentrate on only so much detail at a time</li></ul><li>Arguments for bottom up</li><ul><li>The top down approach might be to abstract to even get started, if you need something more tangible, try bottom up</li><li>Good for early identification of utility functions</li></ul><li>Things to keep in mind if you take the bottom up approach</li><ul><li>Ask yourself what you know the system needs to do</li><li>Identify concrete objects and responsibilities from that question</li><li>Identify common objects, and group them using subsystem organization, packages, composition within objects, or inheritance</li><li>Continue with the next level up, or go back to the top and try to work your way back down</li></ul></ul></ul><ul><li><span style="font-style: italic; text-decoration: underline;">Experimental Prototyping</span>.</li><ul><li>Sometimes you cannot know if a design will work until you better understand some implementation detail.</li><li>To address these issues, employ experimental prototyping</li><li>Prototyping works poorly when developers aren’t disciplined about writing the <span style="font-style: italic; text-decoration: underline;">absolute minimum</span> of code needed to answer a question</li><li>Prototyping also works poorly when the design question is not <span style="font-style: italic; text-decoration: underline;">specific</span> enough.</li><li>Prototyping code must be treated as <span style="font-style: italic; text-decoration: underline;">throwaway code</span>. One way to achieve this is to write prototypes in a completely different framework/language than the one used for the whole system.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Collaborative Design</span>.</li><ul><li>Two heads are often better than one. Forms of collaboration:</li><ul><li>Informally walk over to a co-worker and ask to bounce some ideas around</li><li>You and your co-worker sit together in a conference room and draw design alternatives on a whiteboard</li><li>You and your co-worker sit together at the keyboard and do detailed design in the programming language you’re using (i.e. pair programming)</li><li>You schedule a meeting to walk through your design ideas with one or more co-workers.</li><li>You schedule a formal inspection</li><li>Do some work, put it into a drawer, and consult yourself a week later about your work.</li><li>You ask someone outside your company for help: send questions to a specialized forum or newsgroup.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">How much design is enough?</span></li><ul><li>Depends on the experience of the team, expected lifetime of the system, desired level of reliability, and size of project and team</li><li>If I can’t decide how deeply to investigate a design before I begin coding, I tend to err on the side of going into more detail.</li><li>I rarely encounter projects that are suffering from having done too much design work</li><li>On the other hand, I have seen projects that are suffering from too much design documentation. Polished documentation is not paramount for design itself.</li></ul><li>Aside from capturing design work in a formal document, you can capture designs in numerous alternative ways:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Insert design documentation into the code itself</span>. Document key design decisions in code comments, typically in class and file headers. Improves the chance programmers will keep the design documentation reasonably up to date.</li><li><span style="font-style: italic; text-decoration: underline;">Capture design discussions and decisions on a Wiki</span>. Have your design discussion in writing, on a project Wiki. Supplement text with pictures.</li><li><span style="font-style: italic; text-decoration: underline;">Write email summaries</span>. After a design discussion, adopt the practice of designating someone to write a summary of the discussion— especially what was decided— and send it to the project team. Archive a copy in the project’s public e-mail folder.</li><li><span style="font-style: italic; text-decoration: underline;">Use a digital camera</span>. Taking pictures of whiteboard drawings and embedding them into traditional documents can be a low-effort way to get 80 percent of the benefit of saving design drawings.</li><li><span style="font-style: italic; text-decoration: underline;">Save design flip charts</span>. The documentation need not only be set in letter paper.</li><li><span style="font-style: italic; text-decoration: underline;">Use CRC (Class, Responsibility, Collaborator) cards</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Create UML diagrams at appropriate levels of detail</span>.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Comments on Popular Methodologies</span></div><ul><li>The more dogmatic you are about applying a design method, the fewer real-life problems you are going to solve.</li></ul><div><br/></div><hr/><div><span style="font-weight: bold;">McConnell: Chapter 6 — Working Classes</span></div><hr/><ul><li>Classes are a primary tool for complexity management.</li></ul><div><span style="font-weight: bold;">Class Foundations: Abstract Data Types (ADTs)</span></div><ul><li>An abstract data type is a collection of data and operations that work on that data.</li><li>Benefits of using ADTs:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Hiding implementation details</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Changes don’t affect the whole program</span>.</li><li><span style="font-style: italic; text-decoration: underline;">You can make the interface more informative</span>.</li><li><span style="font-style: italic; text-decoration: underline;">It’s easier to improve performance</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The program is more obviously correct</span>.</li><li><span style="font-style: italic; text-decoration: underline;">The program becomes more self documenting</span>.</li><li><span style="font-style: italic; text-decoration: underline;">You don’t have to pass data all over your program</span>.</li><li><span style="font-style: italic; text-decoration: underline;">You’re able to work with real-world entities rather than with low-level implementation structures</span>.</li></ul><li>Try to make the names of classes and access routines independent of how the data is stored, and refer to the abstract data type instead.</li><li>Good class interfaces:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Present a consistent level of abstraction in the class interface</span>. </li><ul><li>Each class should implement one and only one ADT</li><li>If you use inheritance, make sure the child class satisfies the “is a” relationship with the parent</li></ul><li><span style="font-style: italic; text-decoration: underline;">Be sure you understand what abstraction the class is implementing</span>. When you have to choose between two similar abstractions, make sure you choose the right one.</li><li><span style="font-style: italic; text-decoration: underline;">Provide services in paris with their opposites</span>. If you have an operation that turns a light on, you will probably want one that turns it off. Check each public routine to determine if you need its complement.</li><li><span style="font-style: italic; text-decoration: underline;">Move unrelated information to another class</span>. If half of the class’s routines work with half the class’s data and half with the other data, then separate the class into two distinct classes.</li><li><span style="font-style: italic; text-decoration: underline;">Make interfaces programmatic rather than semantic when possible</span>. Each interface has a programmatic part and a semantic part.</li><ul><li>Programmatic part consists of the data types and other attributes of the interface that can be enforced by the compiler</li><li>Semantic part of the interface consists of the assumptions about how the interface will be used, which cannot be enforced by the compiler.</li><ul><li>The semantic part must be clearly documented, but interfaces should be minimally dependent on documentation.</li><li>Better apply compile-time checkable solutions to semantic parts like assertions or other techniques.</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Beware of erosion of the interface’s abstraction under modification</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t add public members that are inconsistent with the interface abstraction</span>. Each time you add a routine to a class interface ask “Is this routine consistent with the abstraction provided by the existing interface?”</li><li><span style="font-style: italic; text-decoration: underline;">Consider abstraction and cohesion together</span>. These two concepts are related.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Good Encapsulation</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">Minimize accessibility of classes and members</span>. Favor the strictest level of privacy that still works. If exposing the routine is consistent with the abstraction, however, it’s probably fine to expose it.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t expose member data in public</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid putting private implementation details into a class’s interface</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t make assumptions about the class’s users</span>. You cannot make the assumption about how your interface will or will not be used.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid friend classes</span>. They violate the principle of encapsulation.</li><li><span style="font-style: italic; text-decoration: underline;">Don’t put a routine into the public interface just because it uses only public routines</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Favor read-time convenience to write-time convenience</span>. Code is read more than it is written.</li><li><span style="font-style: italic; text-decoration: underline;">Be very, very wary of semantic violations of encapsulation</span>. </li><ul><li>Here are some examples of how encapsulation can be broken semantically:</li><ul><li>Not calling Class A’s InitializeOperations() routine because you know that Class A’s PerformFirstOperation() routine calls it automatically</li><li>Not calling the database.Connect() routine before you call employee.Retrieve(database) because you know that the employee.Retreive() function will connect to the database if there isn’ already a connection</li><li>Using Class B’s MAXIMUM_ELEMENTS constant instead of using ClassA.MAXIMUM_ELEMENTS, because you know that they’re both equal to the same value.</li></ul><li>The problem with each of these examples is that they make the client code dependent on implementation specifics that are not part of the interface.</li><li>If you don’t understand somebody’s interface, ask them about it and make no assumptions outside the interface. Consequently, the implementor of the interface should not respond to you directly but change documentation/interface and ask if you can understand the interface after the changes. If this is not done, there will be semantical assumptions in your use of the interface by definition.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Watch for coupling that is too tight</span>. </li><ul><li>Minimize accessibility of classes and members</li><li>Avoid friend classes</li><li>Make data private rather than protected in a base class to make derived classes less tightly coupled to the base class</li><li>Avoid exposing member data in a class’s public interface</li><li>Be wary of semantic violations of encapsulation</li><li>Observe the <span style="font-style: italic;">Law of Demeter</span></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Design and Implementation Issues</span></div><ul><li>This section discusses issues related to containment, inheritance, member functions and data, class coupling, constructors, and value-vs.-reference objects.</li><li><span style="font-style: italic; text-decoration: underline;">Containment (“has a” relationship)</span></li><ul><li>The idea that a class contains a primitive data element or object. Containment, not inheritance, is the work-horse technique in object-oriented programming</li><li>People mention inheritance more only because it is more error-prone</li><li><span style="font-style: italic; text-decoration: underline;">Implement “has a” through containment</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Implement “has a” through private inheritance as a last resort</span>. This way the containing class is able to access protected member functions or data of the class that’s contained. This usually tends to point to design errors that should be resolved, though.</li><li><span style="font-style: italic; text-decoration: underline;">Be critical of classes that contain more than about 7 data members</span>. If a class contains more than 7 members, it is hard for programmers to keep track of all the internal variables successfully.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Inheritance (“is a” relationship)</span>.</li><ul><li>Inheritance is the idea that one class is the specialization of another.</li><li>Inheritance helps avoid the need to repeat code and data in multiple locations by centralizing it within a base class.</li><li>Decisions you have to make before using inheritance:</li><ul><li>For each member routine, will the routine be visible to derived classes? Will it have a default implementation? Will the default implementation be overridable?</li><li>For each data member, will the data ember be visible to derived classes?</li></ul><li><span style="font-style: italic; text-decoration: underline;">Implement “is a” through public inheritance</span>. If the derived class is not going to adhere completely to the same interface contract defined by the base class, inheritance is not the right implementation technique. Consider containment or making a change further up the inheritance hierarchy.</li><li><span style="font-style: italic; text-decoration: underline;">Design and document for inheritance or prohibit it</span>.  Inheritance adds complexity to a program, and, as such, it’s a dangerous technique. If a class isn’t designed to be inherited from, make its members non-virtual in C++, final in Java.</li><li><span style="font-style: italic; text-decoration: underline;">Adhere to the Leskov Substitution Principle (LSP)</span>. You shouldn’t inherit from a base class unless the derived class truly “is a” more specific version of the base class. Subclasses must be usable through the base class interface without the need for the user to know the difference, i.e. all the routines defined in the base class should mean the same thing when they’re used in each of the derived classes.</li><li><span style="font-style: italic; text-decoration: underline;">Be sure to inherit only what you want to inherit</span>. Three flavors of inherited routines:</li><ul><li><span style="text-decoration: underline;">An abstract overridable routine</span>. Means the derived class inherits the routine’s interface but not its implementation.</li><li><span style="text-decoration: underline;">An overridable routine</span>. means that the derived class inherits the routine’s interface and a default implementation and it is allowed to override the default implementation.</li><li><span style="text-decoration: underline;">A non-overridable routine</span>. Means that the derived class inherits the routine and it’s default implementation without being able to override it.</li><li>If you want to use a class’s implementation but not its interface, use containment rather than inheritance.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Don’t “override” a non-overridable member function</span>. Don’t reuse names of non-overridable base-class routines in derived classes.</li><li><span style="font-style: italic; text-decoration: underline;">Move common interfaces, data, and behavior as high as possible in the inheritance tree</span>. </li><li><span style="font-style: italic; text-decoration: underline;">Be suspicious of class of which there is only one instance</span>. A single instance might indicate that the design confuses objects for classes. Consider if you could just create a new object rather than a distance class.</li><li><span style="font-style: italic; text-decoration: underline;">Be suspicious of base classes of which there is only one derived class</span>. The best way to prepare for future work is not to design extra layers of base classes that <span style="font-style: italic;">might be needed some day</span>. That means not creating any more inheritance structure than is absolutely necessary.</li><li><span style="font-style: italic; text-decoration: underline;">Be suspicious of classes that override a routine and do nothing inside the derived routine</span>.This typically indicates an error in the design of the base class. Issues with overriding routines by having them do nothing:</li><ul><li>It violates the interface contract provided by the base class by changing its semantics</li><li>This approach quickly gets out of control when you extend it to other derived classes.</li><li>Hard to maintain because base class implies nothing about the behavior of derived classes.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Avoid deep inheritance trees</span>. In practice, most people have trouble juggling more than two or three levels of inheritance in their brains at once. Deep inheritance trees are proven to increase fault rates.</li><li><span style="font-style: italic; text-decoration: underline;">Prefer polymorphism to extensive type checking</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Make all data private, not protected</span>.</li></ul><li>Always remember that inheritance tends to work against the primary technical imperative you have as a programmer, which is to manage complexity.</li><li>When to use inheritance vs. when to use containment?</li><ul><li>If multiple classes share common data, but not behavior, create a common object that those classes can contain</li><li>If multiple classes share common behavior but not data, derive them from a common base class that defines the common routines.</li><li>If multiple classes share common data and behavior, inherit from a common base class that defines the common data and routines</li><li>inherit when you want the base class to control your interface; contain when you want to control your interface.</li></ul><li>Member functions and data. Guidelines for implementing member functions and data effectively:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Keep number of routines in class as small as possible</span>. More class routines are associated with higher fault rate.</li><li><span style="font-style: italic; text-decoration: underline;">Disallow implicitly generated member functions and operators you don’t want</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Minimize the number of different routines called by a class</span>. Again, number of faults correlates.</li><li><span style="font-style: italic; text-decoration: underline;">Minimize indirect routine calls to other classes</span>. using account.ContactPerson().DaytimeContactInfo() is a coding horror!</li><ul><li><span style="font-style: italic; text-decoration: underline;">Law of Demeter</span>: If object A instantiates an object B, it can call any of object B’s routines. But it should avoid calling routines on objects provided by object B.</li></ul><li><span style="font-style: italic; text-decoration: underline;">Minimize the extent to which a class collaborates with other classes</span>. Minimize the following:</li><ul><li>Number of kinds of objects instantiated</li><li>Number of different direct routine calls on instantiated objects</li><li>Number of routine calls on objects returned by other instantiated objectects</li></ul></ul><li>Constructor guidelines:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Initialize all member data in all constructors, if possible</span>. Initialize all data members in all constructors is an inexpensive defensive programming practice.</li><li><span style="font-style: italic; text-decoration: underline;">Enforce the singleton property by using a private constructor</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Prefer deep copies to shallow copies until proven otherwise</span>. Deep copies rarely cause measurable performance impacts, and programmers are notoriously bad at predicting which types of objects might cause problems with deep copies.</li></ul><li>Reasons to create a class:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Model real-world objects</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Model abstract objects</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Reduce complexity</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Isolate complexity</span>. When an error inevitably arises, it will be easier to find if it isn’t spread through the code but is localized within a class.</li><li><span style="font-style: italic; text-decoration: underline;">Hide implementation details</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Limit effects of changes</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Hide global data</span>. If you need to use global data, you can hide its implementation details behind a class interface.</li><li><span style="font-style: italic; text-decoration: underline;">Streamline parameter passing</span>. If you are passing a parameter among several routines that might indicate a need to factor those routines into a class that share the parameter as object data.</li><li><span style="font-style: italic; text-decoration: underline;">Make central points of control</span>. It’s a good idea to control each task in one place. Using one class to read from and write to a database is a form of centralized control.</li><li><span style="font-style: italic; text-decoration: underline;">Facilitate reusable code</span>. Code put into well-factored classes can be reused in other programs more easily than the same code embedded in one larger class.</li><li><span style="font-style: italic; text-decoration: underline;">Plan for a family of programs</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Packaging related operations</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Accomplish a specific refactoring</span>.</li></ul><li>Classes to avoid</li><ul><li><span style="font-style: italic; text-decoration: underline;">Avoid creating god classes</span><span style="font-style: italic;">. </span>Avoid creating omniscient classes that are all-powerful and constantly query other classes’ Get() and Set() routines.</li><li><span style="font-style: italic; text-decoration: underline;">Eliminate irrelevant classes</span>.</li><li><span style="font-style: italic; text-decoration: underline;">Avoid classes named after verbs</span>. Classes that only contain behavior and no data are really routines that should be refactored into other classes.</li></ul><li>Class-related areas that vary significantly depending on language:</li><ul><li>Behavior of overridden constructors and destructors in an inheritance tree</li><li>Behavior of constructors and destructors under exception-handling conditions</li><li>Importance of default constructors</li><li>Time at which a destructor is called</li><li>Wisdom of overriding the language’s built-in operators, including assignment and equality</li><li>How memory is handled as objects are created and destroyed or as they go out of scope</li></ul><li>Beyond Classes: Packages</li><ul><li>Modularity can be implemented in packages, not only classes</li><li>It was evident that we could better support the goals of abstraction and encapsulation if we had good tools for aggregating groups of objects.</li></ul></ul><div><br/></div></body></html>