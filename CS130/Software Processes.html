<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.3 (455969)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-02-08 07:20:42 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-08 07:22:47 +0000"/><title>Software Processes</title></head><body><div><hr/></div><div><span style="font-weight: bold;">Lecture Notes: January 29 — Software processes</span></div><hr/><div><span style="font-weight: bold;">Extreme Programming (the dynamic perspective)</span></div><ul><li>Phase 1 — planning: set of <span style="font-style: italic; text-decoration: underline;">stories</span></li><ul><li>decide to do either the <span style="font-style: italic;">highest value</span> or<span style="font-style: italic;"> highest risk</span> task</li></ul><li>Phase 2 — design: </li><ul><li><span style="font-style: italic; text-decoration: underline;">CRC cards</span> (Class Responsibility Collaborate)</li><ul><li>One card per class</li><li>With listed responsibility and all other classes our card is suppose to talk to in order to fulfill the responsibility</li></ul><li><span style="font-style: italic; text-decoration: underline;">Spike solutions</span>: </li><ul><li>Prototypes that address risk</li></ul></ul><li>Phase 3 — coding:</li><ul><li><span style="font-style: italic; text-decoration: underline;">Code refactoring</span></li><li><span style="font-style: italic; text-decoration: underline;">Tinder boxes</span>: all modules come along with a comprehensive set of test cases (each commit must result in working code)</li><ul><li>test before code</li></ul><li><span style="font-style: italic; text-decoration: underline;">Pair programming</span>: </li><ul><li>one person has the keyboard and is thinking <span style="font-style: italic;">tactically</span></li><li>other person stands around and thinks <span style="font-style: italic;">strategically </span></li><li>code tends to be more reliable</li><li>good way to propagate information around developers (educational benefit due to communication of expertise)</li><li>people encourage each other to work hard</li><li>Downside: two people instead of one to pay</li></ul></ul><li>Phase 4 — testing:</li><ul><li>Does not include all types of testing</li><li>Just <span style="font-style: italic;">acceptance testing </span>with customer</li></ul><li>Repeat (2-3 week structures) + keep track (management):</li><ul><li><span style="font-style: italic; text-decoration: underline;">project velocity</span>: how many stories per week?</li></ul></ul><div><span style="font-weight: bold;">Extreme Programming (the practice perspective)</span></div><ul><li>XP values:</li><ul><li><span style="font-style: italic; text-decoration: underline;">communication</span>: </li><ul><li>verbal, informal</li></ul><li><span style="font-style: italic; text-decoration: underline;">simplicity</span>:</li><ul><li>Don’t worry about coming up with a general solution, just solve the specific problem</li><li>code for today and don’t over engineer</li></ul><li><span style="font-style: italic; text-decoration: underline;">discipline</span>:</li><ul><li>discipline to keep things simple when customer wants to make things more complicated</li><li>don’t let the scope expand</li></ul><li><span style="font-style: italic; text-decoration: underline;">feedback</span>:</li><ul><li>comes from customer</li></ul><li><span style="font-style: italic; text-decoration: underline;">respect</span>:</li><ul><li>everybody is in charge</li><li>everybody respects each others concerns</li></ul></ul></ul><div><span style="font-weight: bold;">Downsides of XP</span></div><ul><li>No formal design </li><ul><li>CRC cards are vague compared to good designs</li><li>implies that XP is not good for big stuff</li></ul><li>No formal requirements</li><ul><li>implies that it is harder to catch requirement bugs</li><li>cannot ask for reviews since there is no requirements document</li></ul><li>Volatile requirements</li><ul><li>requirements can constantly change a lot</li><li>causes a lot of potential wasted work</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Industrial XP (XP at scale)</span></div><ul><li><span style="font-style: italic; text-decoration: underline;">readiness assessment</span> of</li><ul><li>environment people will be working in</li><li>team of developers</li><li>organization</li><li>culture</li><li>used to establish if the situation is right for doing a given project successfully</li></ul><li><span style="font-style: italic; text-decoration: underline;">community</span> </li><ul><li>all stakeholders (legal, sales, …) so that you know who to contact when a change is proposed</li></ul><li><span style="font-style: italic; text-decoration: underline;">project chartering</span></li><ul><li>will we take on this project and if so, what are its bounds?</li><li>maybe the project shouldn’t/cannot be done</li></ul><li><span style="font-style: italic; text-decoration: underline;">test driven management</span></li><ul><li>managers should specify which tests will establish quality of developers’ development process</li><li>measurable destinations</li></ul><li><span style="font-style: italic; text-decoration: underline;">retrospectives</span></li><ul><li>A technical review with a goal of improving next time</li></ul><li><span style="font-style: italic; text-decoration: underline;">continuous learning</span></li></ul><div><br/></div><div><span style="font-weight: bold;">Downsides of agile in general</span></div><ul><li>It’s too tempting to skip refactoring</li><li>Prioritization is taken for granted</li><li>Some developers are not that good at collaborating</li><li>Some customers aren’t that good at collaborating</li><li>Test driven development cannot test everything (especially for user interfaces)</li></ul><div><br/></div><div><span style="font-weight: bold;">System Engineering</span></div><ul><li>Software engineering + “everything else”</li><ul><li>hardware</li><li>database/data</li><li>people</li><li>documentation</li><li>procedures</li></ul><li>Systems engineering demands to be thought of at multiple levels of abstraction</li><ul><li>e.g. business process engineering abstraction layers:</li><ul><li>Enterprise strategy (worry of CEO)</li><li>Business area design</li><li>Business system design</li><li>Construction and integration</li></ul></ul><li>Stages in system engineering:</li><ul><li>Phase 1— <span style="font-style: italic; text-decoration: underline;">Conceptual design</span> —&gt; System vision document</li><li>Phase 2 — <span style="font-style: italic; text-decoration: underline;">Procurement</span> (buying all the stuff required for the system)</li><ul><li>regulations</li><li>competition</li><li>budget</li><li>buy vs. build</li></ul><li>Phase 3 — <span style="font-style: italic; text-decoration: underline;">Development</span>:</li><ul><li>waterfall model is popular in system engineering</li></ul><li>Phase 4 — <span style="font-style: italic; text-decoration: underline;">Operation</span>:</li><ul><li>being prepared for things going wrong</li><li>flexibility, adaptability</li></ul></ul><li><span style="font-style: italic; text-decoration: underline;">Hayley-Pirbhai modeling</span> </li><ul><li>simple, scalable system models</li><li>user interface</li><li>input interface</li><li>output interface</li><li>processing interface</li><li>maintenence interface</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">System modeling</span></div><ul><li>Analysis products must be <span style="font-style: italic;">maintainable</span></li><ul><li>If you come up with a nice diagram, it should be in a form in which it can be changed.</li></ul><li>Specs must be decomposable</li><ul><li>You can take your system model and break it into peaces so that you can focus on subsystems without a need to think about the entire system</li><li>Graphics are preferred</li></ul><li>Focus and what is to be done, and not how it is to be done</li><li>System models should elaborate on:</li><ul><li><span style="font-style: italic; text-decoration: underline;">assumptions</span> (what are my assumptions?)</li><li><span style="font-style: italic; text-decoration: underline;">simplifications</span> (cannot precisely describe entire system, so need simplification)</li><li><span style="font-style: italic; text-decoration: underline;">limitations</span> (what are the intentional limits of the system?)</li><li><span style="font-style: italic; text-decoration: underline;">constraints</span> (constraints imposed on developers by customer, e.g., must run on Windows 7)</li><li><span style="font-style: italic; text-decoration: underline;">preferences</span> (prefer Oracle, but not necessary)</li><li>For any of these, simulations can help</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Data modeling</span></div><ul><li>concepts</li><ul><li><span style="font-style: italic; text-decoration: underline;">data object</span>: e.g., a row in a table</li><li><span style="font-style: italic; text-decoration: underline;">attribute</span>: property of data object (column in a table)</li><li><span style="font-style: italic; text-decoration: underline;">relation</span>: e.g., a table</li><li><span style="font-style: italic; text-decoration: underline;">cardinality</span>: says whether a relation is 1-1, 1-many, …</li><li><span style="font-style: italic; text-decoration: underline;">modality</span>: says whether a relation is required for an object (e.g., every child must have a parent)</li></ul><li><span style="font-style: italic; text-decoration: underline;">schema</span> for a database:</li><ul><li>a design that specifies all of the above</li></ul><li><span style="font-style: italic; text-decoration: underline;">data flow modeling</span></li><ul><li>model the computation of the system as a flow of data from sources to sinks</li><li>To analyze your program:</li><ul><li>design what each of the bubble in the flow chart do</li><li>expand bubble to a level N+1 diagram for more detail</li><li>repeat or say I’m so low level that I can write code now</li></ul></ul></ul><div><span style="font-weight: bold;">Use case modeling</span></div><ul><li>Intended for early stages of design as well as later stages</li><li>derived from theater (like a scenario in a play)</li><li><span style="font-style: italic; text-decoration: underline;">actors</span>: people or devices playing a role</li><li><span style="font-style: italic; text-decoration: underline;">scenarios</span>: use cases or scripts</li><ul><li><span style="font-style: italic;">motivation</span>: why are the actors doing what they are doing</li><li><span style="font-style: italic;">setting (aka preconditions)</span>: things that are true right before use case starts</li><li><span style="font-style: italic;">triggers</span>: the change that made the use case happen</li><li><span style="font-style: italic;">tasks</span>: what does each actor do? (variations and exceptions to usual path)</li><li><span style="font-style: italic;">information flow</span>: how does information flow between actors?</li><li><br/></li></ul></ul><div><span style="font-weight: bold;">Software modeling</span></div><ul><li><br/></li></ul><hr/><div><span style="font-size: 13px; font-weight: bold;">Lecture Notes: January 24 — Software processes</span></div><hr/><ul><li>How do people interact to write programs?</li><li>Software construction issues</li><li>Construction vs. Engineering</li><ul><li>Construction workers vs. Architects/Civil engineers</li><li><span style="font-style: italic;">Issue of scale</span>: For small stuff you don’t need engineering, but for big projects you must have detailed planning (engineering)</li><ul><li>Number of lines of code</li><li>Number of people developing</li><li>Expected lifetime of the program</li><li>Number and type of regulations</li></ul><li>Coding and debugging is central to software development in the same way that hammering and cutting are to the construction of a building</li><li><span style="font-style: italic;">Issue of type of project</span></li></ul><li>Metaphors for software engineering</li><ul><li>Fred Brooks: <span style="font-style: italic;">Plan to throw your software away because you will anyhow.</span> </li><ul><li>Most software projects fail</li></ul><li><span style="font-style: italic;">Think of software as encyclopedia development.</span></li></ul><li>Plan-driven processes</li><ul><li>Prescriptive</li><li>Emphasize order (everybody knows what’s happening)</li><li>Emphasize consistency</li><li>Minimize communication with other developers</li></ul><li><span style="font-style: italic;">Waterfall model. </span>Finish one task to start the other:</li><ul><li>Requirements and modeling of problem and solution</li><li>Architecture and design</li><li>Low-level component design</li><li>Coding</li><li>Now you have to</li></ul></ul><div/><div><span style="font-weight: bold;">Somerville: Chapter 2 — Software processes</span></div><hr/><ul><li>A software process is a set of related activities that leads to the production of a software product</li><li>The four fundamental steps to software engineering</li><ul><li><span style="font-style: italic;">Software specification</span></li><li><span style="font-style: italic;">Software design and implementation</span></li><li><span style="font-style: italic;">Software validation</span></li><li><span style="font-style: italic;">Software evolution</span></li></ul><li>All four are part of software processes</li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Software processes can be improved by process standardization where the diver- sity in software processes across an organization is reduced. This leads to improved communication and a reduction in training time, and makes automated process sup- port more economical.</span></li><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">Process models (abstracted representations of software processes):</span></li><ul><li><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial; font-style: italic;">The waterfall model</span><span style="font-size: 14px; color: rgb(35, 31, 32); font-family: Arial;">. Represents the fundamental process activities as separate process phases.</span></li></ul></ul><div><img src="Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%201.09.25%20PM.png" height="300" width="534"/></div><ul><ul><li><span style="font-style: italic;">Incremental development. </span>This approach interleaves the activities of specification, development, and validation. The system is developed in a series of versions.</li><li><span style="font-style: italic;">Reuse-oriented software engineering.</span> Based on the existence of a significant number of reusable components. The system development process focuses on integrating these components into a system rather than developing them from scratch.</li></ul><li>Parts of the system which are difficult to specify in advance, such as the user interface, should always be developed using an incremental approach</li></ul><div><br/></div><div><span style="font-weight: bold;">The Waterfall Model</span></div><ul><li>A plan-driven process — you must, in principle, plan and schedule all of the process activities before starting work on them.</li><li>The principle stages of the waterfall model directly reflect the fundamental development activities:</li><ul><li><span style="font-style: italic;">Requirements analysis and definition. </span></li><li><span style="font-style: italic;">System and software design. </span>Allocates the requirements to either hardware or software systems by establishing an overall system architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.</li><li><span style="font-style: italic;">Implementation and unit testing. </span></li><li><span style="font-style: italic;">Integration and system testing.</span></li><li><span style="font-style: italic;">Operation and maintenance.</span></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Incremental Development</span></div><div><img src="Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%202.11.26%20PM.png" height="266" width="490"/></div><ul><li>Better than the waterfall model for most business, e-commerce, and personal systems.</li><li>Benefits compared to waterfall model:</li><ul><li>The cost of accommodating changing customer requirements is reduced.</li><li>It is easier to get customer feedback on the development work that has been done.</li><li>More rapid delivery and deployment of useful software to the customer is possible.</li></ul><li>Incremental development can be</li><ul><li><span style="font-style: italic;">Plan-driven</span>: the system increments are identified in advance</li><li><span style="font-style: italic;">Agile</span>: the early increments are identified but the development of later increments depends on progress and customer priorities.</li></ul><li>From a management perspective the incremental approach has two problems</li><ul><li>The process is not visible. Managers need regular deliverables to measure progress.</li><li>System structure tends to degrade as new increments are added. Unless time and money is spent on refactoring to improve the software, regular change tends to corrupt its structure. Incorporating further software changes becomes increasingly difficult and costly.</li></ul><li>These issues are particularly pronounced for large, complex, long-lifetime systems, where different teams develop different parts of the system. Large systems need a stable framework or architecture and the responsibilities of the different teams working on parts of the system need to be clearly defined with respect to that architecture.</li></ul><div><br/></div><div><span style="font-weight: bold;">Reuse-oriented software engineering</span></div><ul><li>Reuse-oriented approaches rely on a large base of reusable software components and an integrating framework for the composition of these components.</li><li>Stages of reuse-oriented software engineering are:</li><ul><li><span style="font-style: italic;">Component analysis. </span>Given the requirements specification, a search is made for components to implement that specification</li><li><span style="font-style: italic;">Requirements modification. </span>The requirements are modified based on information about the components that have been discovered.</li><li><span style="font-style: italic;">System design with reuse</span></li><li><span style="font-style: italic;">Development and integration</span></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Requirements Engineering</span></div><div><img src="Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%204.57.32%20PM.png" height="275" width="533"/></div><div><br/></div><div><span style="font-weight: bold;">Software design and implementation</span></div><div><img src="Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%204.58.54%20PM.png" height="367" width="474"/></div><ul><li>Four activities that may be part of the design process for information systems:</li><ul><li><span style="font-style: italic;">Architectural design. </span>Identify the overall structure of the system.</li><li><span style="font-style: italic;">Interface design. </span>Identify the interfaces between system components.</li><li><span style="font-style: italic;">Component design.</span> Design how each system component will operate, including specific functional requirements for each component.</li><li><span style="font-style: italic;">Database design.</span> Design the system data structures and how these are to be represented in a database</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Software validation</span></div><ul><li>Software verification and validation is intended to show that a system both conforms to its specification and that it meets the expectations of the system customer</li><li>The stages in the testing process are</li><ul><li><span style="font-style: italic;">Development testing. </span>The components making up the system are tested by the people developing the system.</li><li><span style="font-style: italic;">System testing. </span>This process is concerned with finding errors that result from unanticipated interactions between components and component interface problems.</li><li><span style="font-style: italic;">Acceptance testing.</span> The system is tested with data supplied by the system customer rather than with simulated test data.</li></ul><li><span style="font-style: italic;">Beta testing </span>is another option. Here, the beta customer are given a product to play with and test, while reporting errors and bugs.</li></ul><div><br/></div><div><span style="font-weight: bold;">Coping with change</span></div><ul><li>It is essential that whatever software process model is used it can accommodate changes to the software being developed.</li><li>There are two related approaches that may be used to reduce the costs of rework</li><ul><li><span style="font-style: italic;">Change avoidance</span>, where the software process includes activities that can anticipate possible changes before significant rework is required. Prototyping can be a good tool for anticipating changing requirements since it can be used by stakeholders prior to serious development.</li><li><span style="font-style: italic;">Change tolerance</span>, where the process is designed so that changes can be accommodated at relatively low cost. Usually involves some type of incremental development.</li></ul><li><span style="font-style: italic;">Refactoring</span>, improving the structure and organization of a program, is also an important mechanism that supports change tolerance.</li></ul><div><br/></div><div><span style="font-weight: bold;">Prototyping</span></div><div><img src="Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%205.24.37%20PM.png" height="165" width="545"/></div><ul><li>During requirements engineering, a prototype can help with the elicitation and validation of system requirements.</li><li>In the system design process, a prototype can be used to explore particular software solutions and to support user interface design.</li><li>Rapid prototyping with end-user involvement is the only sensible way to develop graphical user interfaces for software systems.</li><li>To reduce costs, prototyping can be done with relaxed non-functional requirements, reduced functionality, and no or little error-handling</li><li>Issues that might arise with prototyping:</li><ul><li>It may be impossible to tune the prototype to meet non-functional requirements</li><li>Rapid change during development means that the prototype is probably undocumented, which is not good enough for long-term maintenance.</li><li>The system structure may get compromised in order to conform to prototype</li><li>Organizational quality standards are normally relaxed for prototype development.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Incremental delivery</span></div><ul><li>Each increment provides a part of the system’s functionality and is fully deployed to the user by the end of its cycle. Usually, the highest priority functionalities are delivered first.</li><li>Advantages of incremental delivery include:</li><ul><li>Customers can use the early increments as prototypes and gain experience that informs their requirements for later system increments.</li><li>Customers do not have to wait for entire system to derive value from using it</li><li>The process is developed with the mindset of adding new functionality being easy</li><li>Since the highest priority tasks are delivered first, the most importance services get the most user testing</li></ul><li>Issues with incremental delivery:</li><ul><li>It can be hard to identify common facilities that are needed by all increments.</li><li>Iterative development does not generally give useful feedback if it is done on systems that are developed to replace older systems.</li><li>In the incremental approach, there is no complete system specification until the final increment is specified. This might be hard for large contractors, like the government, to accommodate.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Bohm’s spiral model</span></div><ul><li>A risk-driven software process framework.</li><li>Each loop in the spiral is split into four sectors:</li><ul><li><span style="font-style: italic;">Objective setting. </span>Objectives for current phase of project are defined. Project risks are identified. Alternative strategies, based on these risks, may be planned.</li><li><span style="font-style: italic;">Risk assessment and reduction. </span>For each of the identified risks, a detailed analysis is carried out. Steps are taken to reduce the risk.</li><li><span style="font-style: italic;">Development and validation.</span> After risk evaluation, a development model for the system is chosen.</li><li><span style="font-style: italic;">Planning. </span>The project is reviewed and a decision made whether to continue with a further loop of the spiral.</li></ul></ul><div><br/></div><div><span style="font-weight: bold;">The Rational Unified Process (RUP)</span></div><ul><li>Described from 3 perspectives:</li><ul><li><span style="font-style: italic;">A dynamic perspective</span>, which shows the phases of the model over time</li><li><span style="font-style: italic;">A static perspective</span>, which shows the process activities that are enacted</li><li><span style="font-style: italic;">A practice perspective</span>, which suggests general good practices to be used during the process</li></ul><li>Four phases of RUP:</li><ul><li><span style="font-style: italic;">Inception</span></li><ul><li>Establish a business case for the system </li><li>Define stakeholders and define how they interact with the system</li><li>Assess what contribution the system makes to the business</li></ul><li><span style="font-style: italic;">Elaboration</span></li><ul><li>Develop an understanding of the problem domain</li><li>Establish architectural framework for the system</li><li>Identify key project risk</li><li>Develop project plan</li><li>On completion, you should have a requirements model for the system, an architectural description, and a development plan</li></ul><li><span style="font-style: italic;">Construction</span></li><ul><li>The construction phase involves system design, programming, and testing. On completion, you should have a working software system and associated documentation that is ready for delivery to users.</li></ul><li><span style="font-style: italic;">Transition. </span>Moving the system from the development community to the user community and making it work in a real environment. Sometimes expensive and problematic. On completion, you should have a documented software system that is working correctly in its operational environment.</li></ul><li>Six fundamental software engineering best practices:</li><ul><li><span style="font-style: italic;">Develop software interatively. </span>Plan increments based on customer priorities.</li><li><span style="font-style: italic;">Manage requirements. </span>Explicitly document the customer’s requirements and keep track of changes to these requirements. Analyze the impact of changes on the system before accepting them.</li><li><span style="font-style: italic;">Use component-based architectures. </span>Structure the system architecture into independent components.</li><li><span style="font-style: italic;">Visually model software. </span>Use graphical models to present static and dynamic views of the software.</li><li><span style="font-style: italic;">Verify software quality. </span>Ensure that the software meets the organization quality standards.</li><li><span style="font-style: italic;">Control changes to software. </span>Manage changes to the software using a change management system and configuration management procedures and tools.</li></ul><li>Embedded software development is not ideal for using RUP.</li><li>RUP separates phases of development and workflows</li><ul><li>Phases are dynamic and have goals</li><li>Workflows are static and are technical activities that are not associated with a single phase but may be used throughout the development to achieve the goals of each phase.</li></ul></ul><div><br/></div></body></html>